
\section{Methods} \label{sec:methods}

 Save This PageHome » openjdk-7 » sun » misc » [javadoc | source]
sun.misc
public final class: Unsafe [javadoc | source] 
java.lang.Object
   sun.misc.Unsafe
A collection of methods for performing low-level, unsafe operations. Although the class and all methods are public, use of this class is limited because only trusted code can obtain instances of it.
Also see:
getUnsafe
author: John - R. Rose
Field Summary
public static final  int	INVALID_FIELD_OFFSET   	This constant differs from all results that will ever be returned from #staticFieldOffset , #objectFieldOffset , or #arrayBaseOffset . 
public static final  int	ARRAY_BOOLEAN_BASE_OFFSET   	The value of {@code arrayBaseOffset(boolean[].class)} 
public static final  int	ARRAY_BYTE_BASE_OFFSET   	The value of {@code arrayBaseOffset(byte[].class)} 
public static final  int	ARRAY_SHORT_BASE_OFFSET   	The value of {@code arrayBaseOffset(short[].class)} 
public static final  int	ARRAY_CHAR_BASE_OFFSET   	The value of {@code arrayBaseOffset(char[].class)} 
public static final  int	ARRAY_INT_BASE_OFFSET   	The value of {@code arrayBaseOffset(int[].class)} 
public static final  int	ARRAY_LONG_BASE_OFFSET   	The value of {@code arrayBaseOffset(long[].class)} 
public static final  int	ARRAY_FLOAT_BASE_OFFSET   	The value of {@code arrayBaseOffset(float[].class)} 
public static final  int	ARRAY_DOUBLE_BASE_OFFSET   	The value of {@code arrayBaseOffset(double[].class)} 
public static final  int	ARRAY_OBJECT_BASE_OFFSET   	The value of {@code arrayBaseOffset(Object[].class)} 
public static final  int	ARRAY_BOOLEAN_INDEX_SCALE   	The value of {@code arrayIndexScale(boolean[].class)} 
public static final  int	ARRAY_BYTE_INDEX_SCALE   	The value of {@code arrayIndexScale(byte[].class)} 
public static final  int	ARRAY_SHORT_INDEX_SCALE   	The value of {@code arrayIndexScale(short[].class)} 
public static final  int	ARRAY_CHAR_INDEX_SCALE   	The value of {@code arrayIndexScale(char[].class)} 
public static final  int	ARRAY_INT_INDEX_SCALE   	The value of {@code arrayIndexScale(int[].class)} 
public static final  int	ARRAY_LONG_INDEX_SCALE   	The value of {@code arrayIndexScale(long[].class)} 
public static final  int	ARRAY_FLOAT_INDEX_SCALE   	The value of {@code arrayIndexScale(float[].class)} 
public static final  int	ARRAY_DOUBLE_INDEX_SCALE   	The value of {@code arrayIndexScale(double[].class)} 
public static final  int	ARRAY_OBJECT_INDEX_SCALE   	The value of {@code arrayIndexScale(Object[].class)} 
public static final  int	ADDRESS_SIZE   	The value of {@code addressSize()} 
Method from sun.misc.Unsafe Summary:
addressSize,   allocateInstance,   allocateMemory,   arrayBaseOffset,   arrayIndexScale,   compareAndSwapInt,   compareAndSwapLong,   compareAndSwapObject,   copyMemory,   copyMemory,   defineAnonymousClass,   defineClass,   defineClass,   ensureClassInitialized,   fieldOffset,   freeMemory,   getAddress,   getBoolean,   getBoolean,   getBooleanVolatile,   getByte,   getByte,   getByte,   getByteVolatile,   getChar,   getChar,   getChar,   getCharVolatile,   getDouble,   getDouble,   getDouble,   getDoubleVolatile,   getFloat,   getFloat,   getFloat,   getFloatVolatile,   getInt,   getInt,   getInt,   getIntVolatile,   getLoadAverage,   getLong,   getLong,   getLong,   getLongVolatile,   getObject,   getObject,   getObjectVolatile,   getShort,   getShort,   getShort,   getShortVolatile,   getUnsafe,   monitorEnter,   monitorExit,   objectFieldOffset,   pageSize,   park,   putAddress,   putBoolean,   putBoolean,   putBooleanVolatile,   putByte,   putByte,   putByte,   putByteVolatile,   putChar,   putChar,   putChar,   putCharVolatile,   putDouble,   putDouble,   putDouble,   putDoubleVolatile,   putFloat,   putFloat,   putFloat,   putFloatVolatile,   putInt,   putInt,   putInt,   putIntVolatile,   putLong,   putLong,   putLong,   putLongVolatile,   putObject,   putObject,   putObjectVolatile,   putOrderedInt,   putOrderedLong,   putOrderedObject,   putShort,   putShort,   putShort,   putShortVolatile,   reallocateMemory,   setMemory,   setMemory,   staticFieldBase,   staticFieldBase,   staticFieldOffset,   throwException,   tryMonitorEnter,   unpark
Methods from java.lang.Object:
clone,   equals,   finalize,   getClass,   hashCode,   notify,   notifyAll,   toString,   wait,   wait,   wait
Method from sun.misc.Unsafe Detail:
 public native int addressSize()
Report the size in bytes of a native pointer, as stored via #putAddress .  This value will be either 4 or 8.  Note that the sizes of
other primitive types (as stored in native memory blocks) is determined
fully by their information content.
 public native Object allocateInstance(Class cls) throws InstantiationException
Allocate an instance but do not run any constructor.
Initializes the class if it has not yet been.
 public native long allocateMemory(long bytes)
Allocates a new block of native memory, of the given size in bytes.  The
contents of the memory are uninitialized; they will generally be
garbage.  The resulting native pointer will never be zero, and will be
aligned for all value types.  Dispose of this memory by calling #freeMemory , or resize it with #reallocateMemory .
 public native int arrayBaseOffset(Class arrayClass)
Report the offset of the first element in the storage allocation of a
given array class.  If #arrayIndexScale  returns a non-zero value
for the same class, you may use that scale factor, together with this
base offset, to form new offsets to access elements of arrays of the
given class.
 public native int arrayIndexScale(Class arrayClass)
Report the scale factor for addressing elements in the storage
allocation of a given array class.  However, arrays of "narrow" types
will generally not work properly with accessors like #getByte(Object, int) , so the scale factor for such classes is reported
as zero.
 public final native boolean compareAndSwapInt(Object o,
    long offset,
    int expected,
    int x)
Atomically update Java variable to x if it is currently
holding expected.
 public final native boolean compareAndSwapLong(Object o,
    long offset,
    long expected,
    long x)
Atomically update Java variable to x if it is currently
holding expected.
 public final native boolean compareAndSwapObject(Object o,
    long offset,
    Object expected,
    Object x)
Atomically update Java variable to x if it is currently
holding expected.
 public  void copyMemory(long srcAddress,
    long destAddress,
    long bytes) 
Sets all bytes in a given block of memory to a copy of another block. This provides a single-register addressing mode, as discussed in #getInt(Object,long) . Equivalent to copyMemory(null, srcAddress, null, destAddress, bytes).
 public native  void copyMemory(Object srcBase,
    long srcOffset,
    Object destBase,
    long destOffset,
    long bytes)
Sets all bytes in a given block of memory to a copy of another
block.

This method determines each block's base address by means of two parameters,
and so it provides (in effect) a double-register addressing mode,
as discussed in #getInt(Object,long) .  When the object reference is null,
the offset supplies an absolute base address.


The transfers are in coherent (atomic) units of a size determined
by the address and length parameters.  If the effective addresses and
length are all even modulo 8, the transfer takes place in 'long' units.
If the effective addresses and length are (resp.) even modulo 4 or 2,
the transfer takes place in units of 'int' or 'short'.

 public native Class defineAnonymousClass(Class hostClass,
    byte[] data,
    Object[] cpPatches)
Define a class but do not make it known to the class loader or system dictionary.

For each CP entry, the corresponding CP patch must either be null or have
the a format that matches its tag:


Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
Utf8: a string (must have suitable syntax if used as signature or name)
Class: any java.lang.Class object
String: any object (not just a java.lang.String)
InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments
 public native Class defineClass(String name,
    byte[] b,
    int off,
    int len)
 public native Class defineClass(String name,
    byte[] b,
    int off,
    int len,
    ClassLoader loader,
    ProtectionDomain protectionDomain)
Tell the VM to define a class, without security checks.  By default, the
class loader and protection domain come from the caller's class.
 public native  void ensureClassInitialized(Class c)
Ensure the given class has been initialized. This is often
needed in conjunction with obtaining the static field base of a
class.
 public int fieldOffset(Field f) 
Deprecated! As - of 1.4.1, use #staticFieldOffset for static fields and #objectFieldOffset for non-static fields.

Returns the offset of a field, truncated to 32 bits. This method is implemented as follows:
public int fieldOffset(Field f) {
    if (Modifier.isStatic(f.getModifiers()))
        return (int) staticFieldOffset(f);
    else
        return (int) objectFieldOffset(f);
}
 public native  void freeMemory(long address)
Disposes of a block of native memory, as obtained from #allocateMemory  or #reallocateMemory .  The address passed to
this method may be null, in which case no action is taken.
 public native long getAddress(long address)
Fetches a native pointer from a given memory address.  If the address is
zero, or does not point into a block obtained from #allocateMemory , the results are undefined.

 If the native pointer is less than 64 bits wide, it is extended as
an unsigned number to a Java long.  The pointer may be indexed by any
given byte offset, simply by adding that offset (as a simple integer) to
the long representing the pointer.  The number of bytes actually read
from the target address maybe determined by consulting #addressSize .

 public native boolean getBoolean(Object o,
    long offset)
 public boolean getBoolean(Object o,
    int offset) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native boolean getBooleanVolatile(Object o,
    long offset)
Volatile version of #getBoolean(Object, long) 
 public native byte getByte(long address)
Fetches a value from a given memory address.  If the address is zero, or
does not point into a block obtained from #allocateMemory , the
results are undefined.
 public native byte getByte(Object o,
    long offset)
 public byte getByte(Object o,
    int offset) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native byte getByteVolatile(Object o,
    long offset)
Volatile version of #getByte(Object, long) 
 public native char getChar(long address)
 public native char getChar(Object o,
    long offset)
 public char getChar(Object o,
    int offset) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native char getCharVolatile(Object o,
    long offset)
Volatile version of #getChar(Object, long) 
 public native double getDouble(long address)
 public native double getDouble(Object o,
    long offset)
 public double getDouble(Object o,
    int offset) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native double getDoubleVolatile(Object o,
    long offset)
Volatile version of #getDouble(Object, long) 
 public native float getFloat(long address)
 public native float getFloat(Object o,
    long offset)
 public float getFloat(Object o,
    int offset) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native float getFloatVolatile(Object o,
    long offset)
Volatile version of #getFloat(Object, long) 
 public native int getInt(long address)
 public native int getInt(Object o,
    long offset)
Fetches a value from a given Java variable.
More specifically, fetches a field or array element within the given
object o at the given offset, or (if o is
null) from the memory address whose numerical value is the given
offset.

The results are undefined unless one of the following cases is true:


The offset was obtained from #objectFieldOffset  on
the java.lang.reflect.Field  of some Java field and the object
referred to by o is of a class compatible with that
field's class.

The offset and object reference o (either null or
non-null) were both obtained via #staticFieldOffset 
and #staticFieldBase  (respectively) from the
reflective Field  representation of some Java field.

The object referred to by o is an array, and the offset
is an integer of the form B+N*S, where N is
a valid index into the array, and B and S are
the values obtained by #arrayBaseOffset  and #arrayIndexScale  (respectively) from the array's class.  The value
referred to is the Nth element of the array.



If one of the above cases is true, the call references a specific Java
variable (field or array element).  However, the results are undefined
if that variable is not in fact of the type returned by this method.


This method refers to a variable by means of two parameters, and so
it provides (in effect) a double-register addressing mode
for Java variables.  When the object reference is null, this method
uses its offset as an absolute address.  This is similar in operation
to methods such as #getInt(long) , which provide (in effect) a
single-register addressing mode for non-Java variables.
However, because Java variables may have a different layout in memory
from non-Java variables, programmers should not assume that these
two addressing modes are ever equivalent.  Also, programmers should
remember that offsets from the double-register addressing mode cannot
be portably confused with longs used in the single-register addressing
mode.

 public int getInt(Object o,
    int offset) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

This method, like all others with 32-bit offsets, was native in a previous release but is now a wrapper which simply casts the offset to a long value. It provides backward compatibility with bytecodes compiled against 1.4.
 public native int getIntVolatile(Object o,
    long offset)
Volatile version of #getInt(Object, long) 
 public native int getLoadAverage(double[] loadavg,
    int nelems)
Gets the load average in the system run queue assigned
to the available processors averaged over various periods of time.
This method retrieves the given nelem samples and
assigns to the elements of the given loadavg array.
The system imposes a maximum of 3 samples, representing
averages over the last 1,  5,  and  15 minutes, respectively.
 public native long getLong(long address)
 public native long getLong(Object o,
    long offset)
 public long getLong(Object o,
    int offset) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native long getLongVolatile(Object o,
    long offset)
Volatile version of #getLong(Object, long) 
 public native Object getObject(Object o,
    long offset)
Fetches a reference value from a given Java variable.
 public Object getObject(Object o,
    int offset) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native Object getObjectVolatile(Object o,
    long offset)
Fetches a reference value from a given Java variable, with volatile
load semantics. Otherwise identical to #getObject(Object, long) 
 public native short getShort(long address)
 public native short getShort(Object o,
    long offset)
 public short getShort(Object o,
    int offset) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native short getShortVolatile(Object o,
    long offset)
Volatile version of #getShort(Object, long) 
 public static Unsafe getUnsafe() 
Provides the caller with the capability of performing unsafe operations.
The returned Unsafe object should be carefully guarded by the caller, since it can be used to read and write data at arbitrary memory addresses. It must never be passed to untrusted code.

Most methods in this class are very low-level, and correspond to a small number of hardware instructions (on typical machines). Compilers are encouraged to optimize these methods accordingly.

Here is a suggested idiom for using unsafe operations:

class MyTrustedClass {
  private static final Unsafe unsafe = Unsafe.getUnsafe();
  ...
  private long myCountAddress = ...;
  public int getCount() { return unsafe.getByte(myCountAddress); }
}
(It may assist compilers to make the local variable be final.)
 public native  void monitorEnter(Object o)
Lock the object.  It must get unlocked via #monitorExit .
 public native  void monitorExit(Object o)
Unlock the object.  It must have been locked via #monitorEnter .
 public native long objectFieldOffset(Field f)
Report the location of a given static field, in conjunction with #staticFieldBase .
Do not expect to perform any sort of arithmetic on this offset;
it is just a cookie which is passed to the unsafe heap memory accessors.


Any given field will always have the same offset, and no two distinct
fields of the same class will ever have the same offset.


As of 1.4.1, offsets for fields are represented as long values,
although the Sun JVM does not use the most significant 32 bits.
It is hard to imagine a JVM technology which needs more than
a few bits to encode an offset within a non-array object,
However, for consistency with other methods in this class,
this method reports its result as a long value.

 public native int pageSize()
Report the size in bytes of a native memory page (whatever that is).
This value will always be a power of two.
 public native  void park(boolean isAbsolute,
    long time)
Block current thread, returning when a balancing
unpark occurs, or a balancing unpark has
already occurred, or the thread is interrupted, or, if not
absolute and time is not zero, the given time nanoseconds have
elapsed, or if absolute, the given deadline in milliseconds
since Epoch has passed, or spuriously (i.e., returning for no
"reason"). Note: This operation is in the Unsafe class only
because unpark is, so it would be strange to place it
elsewhere.
 public native  void putAddress(long address,
    long x)
Stores a native pointer into a given memory address.  If the address is
zero, or does not point into a block obtained from #allocateMemory , the results are undefined.

 The number of bytes actually written at the target address maybe
determined by consulting #addressSize .

 public native  void putBoolean(Object o,
    long offset,
    boolean x)
 public  void putBoolean(Object o,
    int offset,
    boolean x) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native  void putBooleanVolatile(Object o,
    long offset,
    boolean x)
Volatile version of #putBoolean(Object, long, boolean) 
 public native  void putByte(long address,
    byte x)
Stores a value into a given memory address.  If the address is zero, or
does not point into a block obtained from #allocateMemory , the
results are undefined.
 public native  void putByte(Object o,
    long offset,
    byte x)
 public  void putByte(Object o,
    int offset,
    byte x) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native  void putByteVolatile(Object o,
    long offset,
    byte x)
Volatile version of #putByte(Object, long, byte) 
 public native  void putChar(long address,
    char x)
 public native  void putChar(Object o,
    long offset,
    char x)
 public  void putChar(Object o,
    int offset,
    char x) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native  void putCharVolatile(Object o,
    long offset,
    char x)
Volatile version of #putChar(Object, long, char) 
 public native  void putDouble(long address,
    double x)
 public native  void putDouble(Object o,
    long offset,
    double x)
 public  void putDouble(Object o,
    int offset,
    double x) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native  void putDoubleVolatile(Object o,
    long offset,
    double x)
Volatile version of #putDouble(Object, long, double) 
 public native  void putFloat(long address,
    float x)
 public native  void putFloat(Object o,
    long offset,
    float x)
 public  void putFloat(Object o,
    int offset,
    float x) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native  void putFloatVolatile(Object o,
    long offset,
    float x)
Volatile version of #putFloat(Object, long, float) 
 public native  void putInt(long address,
    int x)
 public native  void putInt(Object o,
    long offset,
    int x)
Stores a value into a given Java variable.

The first two parameters are interpreted exactly as with
#getInt(Object, long)  to refer to a specific
Java variable (field or array element).  The given value
is stored into that variable.


The variable must be of the same type as the method
parameter x.

 public  void putInt(Object o,
    int offset,
    int x) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native  void putIntVolatile(Object o,
    long offset,
    int x)
Volatile version of #putInt(Object, long, int) 
 public native  void putLong(long address,
    long x)
 public native  void putLong(Object o,
    long offset,
    long x)
 public  void putLong(Object o,
    int offset,
    long x) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native  void putLongVolatile(Object o,
    long offset,
    long x)
Volatile version of #putLong(Object, long, long) 
 public native  void putObject(Object o,
    long offset,
    Object x)
Stores a reference value into a given Java variable.

Unless the reference x being stored is either null
or matches the field type, the results are undefined.
If the reference o is non-null, car marks or
other store barriers for that object (if the VM requires them)
are updated.

 public  void putObject(Object o,
    int offset,
    Object x) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native  void putObjectVolatile(Object o,
    long offset,
    Object x)
Stores a reference value into a given Java variable, with
volatile store semantics. Otherwise identical to #putObject(Object, long, Object) 
 public native  void putOrderedInt(Object o,
    long offset,
    int x)
Ordered/Lazy version of #putIntVolatile(Object, long, int) 
 public native  void putOrderedLong(Object o,
    long offset,
    long x)
Ordered/Lazy version of #putLongVolatile(Object, long, long) 
 public native  void putOrderedObject(Object o,
    long offset,
    Object x)
Version of #putObjectVolatile(Object, long, Object) 
that does not guarantee immediate visibility of the store to
other threads. This method is generally only useful if the
underlying field is a Java volatile (or if an array cell, one
that is otherwise only accessed using volatile accesses).
 public native  void putShort(long address,
    short x)
 public native  void putShort(Object o,
    long offset,
    short x)
 public  void putShort(Object o,
    int offset,
    short x) 
Deprecated! As - of 1.4.1, cast the 32-bit offset argument to a long. See #staticFieldOffset .

 public native  void putShortVolatile(Object o,
    long offset,
    short x)
Volatile version of #putShort(Object, long, short) 
 public native long reallocateMemory(long address,
    long bytes)
Resizes a new block of native memory, to the given size in bytes.  The
contents of the new block past the size of the old block are
uninitialized; they will generally be garbage.  The resulting native
pointer will be zero if and only if the requested size is zero.  The
resulting native pointer will be aligned for all value types.  Dispose
of this memory by calling #freeMemory , or resize it with #reallocateMemory .  The address passed to this method may be null, in
which case an allocation will be performed.
 public  void setMemory(long address,
    long bytes,
    byte value) 
Sets all bytes in a given block of memory to a fixed value (usually zero). This provides a single-register addressing mode, as discussed in #getInt(Object,long) .
Equivalent to setMemory(null, address, bytes, value).

 public native  void setMemory(Object o,
    long offset,
    long bytes,
    byte value)
Sets all bytes in a given block of memory to a fixed value
(usually zero).

This method determines a block's base address by means of two parameters,
and so it provides (in effect) a double-register addressing mode,
as discussed in #getInt(Object,long) .  When the object reference is null,
the offset supplies an absolute base address.


The stores are in coherent (atomic) units of a size determined
by the address and length parameters.  If the effective address and
length are all even modulo 8, the stores take place in 'long' units.
If the effective address and length are (resp.) even modulo 4 or 2,
the stores take place in units of 'int' or 'short'.

 public Object staticFieldBase(Class c) 
Deprecated! As - of 1.4.1, use #staticFieldBase(Field) to obtain the base pertaining to a specific Field . This method works only for JVMs which store all statics for a given class in one place.

Returns the base address for accessing some static field in the given class. This method is implemented as follows:
public Object staticFieldBase(Class c) {
    Field[] fields = c.getDeclaredFields();
    for (int i = 0; i < fields.length; i++) {
        if (Modifier.isStatic(fields[i].getModifiers())) {
            return staticFieldBase(fields[i]);
        }
    }
    return null;
}
 public native Object staticFieldBase(Field f)
Report the location of a given static field, in conjunction with #staticFieldOffset .
Fetch the base "Object", if any, with which static fields of the
given class can be accessed via methods like #getInt(Object,
long) .  This value may be null.  This value may refer to an object
which is a "cookie", not guaranteed to be a real Object, and it should
not be used in any way except as argument to the get and put routines in
this class.

 public native long staticFieldOffset(Field f)
Report the location of a given field in the storage allocation of its
class.  Do not expect to perform any sort of arithmetic on this offset;
it is just a cookie which is passed to the unsafe heap memory accessors.

Any given field will always have the same offset and base, and no
two distinct fields of the same class will ever have the same offset
and base.


As of 1.4.1, offsets for fields are represented as long values,
although the Sun JVM does not use the most significant 32 bits.
However, JVM implementations which store static fields at absolute
addresses can use long offsets and null base pointers to express
the field locations in a form usable by #getInt(Object,long) .
Therefore, code which will be ported to such JVMs on 64-bit platforms
must preserve all bits of static field offsets.

 public native  void throwException(Throwable ee)
Throw the exception without telling the verifier.
 public native boolean tryMonitorEnter(Object o)
Tries to lock the object.  Returns true or false to indicate
whether the lock succeeded.  If it did, the object must be
unlocked via #monitorExit .
 public native  void unpark(Object thread)
Unblock the given thread blocked on park, or, if it is
not blocked, cause the subsequent call to park not to
block.  Note: this operation is "unsafe" solely because the
caller must somehow ensure that the thread has not been
destroyed. Nothing special is usually required to ensure this
when called from Java (in which there will ordinarily be a live
reference to the thread) but this is not nearly-automatically
so when calling from native code.