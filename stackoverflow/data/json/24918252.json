{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":24918252,
    "title":"What JVM synchronization practices can I ignore assuming I know I will run on x64 cpus?",
    "comments":[
      
    ],
    "tags":[
      "java",
      "concurrency",
      "jvm",
      "java-memory-model"
    ],
    "creationDate":"2014-07-23",
    "lastActivityDate":"2014-08-04",
    "lastEditDate":"2014-07-26",
    "score":8,
    "viewCount":320,
    "owner":{
      "type":"StackOverflowUser",
      "id":14316,
      "displayName":"pdeva",
      "reputation":5138
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I know that the JVM memory model is made for lowest common denominator of CPUs, so it has to assume the weakest possible model of a cpu on which the JVM can run (eg ARM).</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[24918252]-[1955787278]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I know that the JVM memory model is made for lowest common denominator of CPUs, so it has to assume the weakest possible model of a cpu on which the JVM can run (eg ARM).</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "jvm":2,
                  "assum":1,
                  "weakest":1,
                  "lowest":1,
                  "model":2,
                  "denomin":1,
                  "run":1,
                  "arm":1,
                  "common":1,
                  "cpu":1,
                  "cpus":1,
                  "made":1,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Now, considering that x64 has a fairly strong memory model, what synchronization practices can I ignore assuming I know my program will only run on 64bit x86 CPUs? Also does this apply when my program is being run through virtualization?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[24918252]-[-1892375872]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Now, considering that x64 has a fairly strong memory model, what synchronization practices can I ignore assuming I know my program will only run on 64bit x86 CPUs? Also does this apply when my program is being run through virtualization?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "program":2,
                  "ignor":1,
                  "assum":1,
                  "fair":1,
                  "bit":1,
                  "model":1,
                  "run":2,
                  "strong":1,
                  "virtual":1,
                  "cpus":1,
                  "appli":1,
                  "practic":1,
                  "synchron":1,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p><strong>Example:</strong><br /> It is known that JVM's memory model requires synchronizing read/writes access to longs and doubles but one can assume that read/writes of other 32 bit primitives like int, float etc are atomic. </p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[24918252]-[1641069745]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p><strong>Example:</strong><br /> It is known that JVM's memory model requires synchronizing read/writes access to longs and doubles but one can assume that read/writes of other 32 bit primitives like int, float etc are atomic. </p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "read":2,
                  "jvm":1,
                  "assum":1,
                  "bit":1,
                  "model":1,
                  "requir":1,
                  "strong":2,
                  "long":1,
                  "atom":1,
                  "doubl":1,
                  "primit":1,
                  "write":2,
                  "access":1,
                  "synchron":1,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>However, if i know that I am running on a 64 bit x86 machine, can i ignore using locks on longs/doubles knowing that the cpu will atomically read/write 64 bit values and just keep them volatile (like i would with ints/floats)?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[24918252]-[-317322545]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>However, if i know that I am running on a 64 bit x86 machine, can i ignore using locks on longs/doubles knowing that the cpu will atomically read/write 64 bit values and just keep them volatile (like i would with ints/floats)?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "read":1,
                  "ignor":1,
                  "bit":2,
                  "float":1,
                  "run":1,
                  "lock":1,
                  "know":1,
                  "long":1,
                  "machin":1,
                  "int":1,
                  "cpu":1,
                  "valu":1,
                  "atom":1,
                  "doubl":1,
                  "write":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":24973890,
      "questionId":24918252,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":38916360,
          "postId":24973890,
          "creationDate":"2014-07-29",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":999043,
            "displayName":"Ralf H",
            "reputation":900
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Actually, I am not sure what problem the OP is getting at. If you are concerned with tearing 64bit writes to main memory, we are looking at a scenario where one core writes that value and the other one reads. If those cores share the same L1 cache, and Holger is correct, unaligned access may fail. If they are on different caches, the other core will observe only the result as it is written back to main memory (or the highest common cache level). Not sure how write-back operations work here."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24973890-cu38916360]-[-1200859442]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Actually, I am not sure what problem the OP is getting at. If you are concerned with tearing 64bit writes to main memory, we are looking at a scenario where one core writes that value and the other one reads. If those cores share the same L1 cache, and Holger is correct, unaligned access may fail. If they are on different caches, the other core will observe only the result as it is written back to main memory (or the highest common cache level). Not sure how write-back operations work here."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "scenario":1,
                        "read":1,
                        "unalign":1,
                        "fail":1,
                        "cach":3,
                        "observ":1,
                        "bit":1,
                        "problem":1,
                        "correct":1,
                        "result":1,
                        "tear":1,
                        "main":2,
                        "work":1,
                        "concern":1,
                        "oper":1,
                        "share":1,
                        "holger":1,
                        "common":1,
                        "highest":1,
                        "written":1,
                        "back":2,
                        "core":3,
                        "write":3,
                        "access":1,
                        "level":1,
                        "memori":2
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":38908711,
          "postId":24973890,
          "creationDate":"2014-07-29",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2711488,
            "displayName":"Holger",
            "reputation":28154
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"A JIT compiler would not tear a 64-bit value into 32-bit writes intentionally on x64 but afaik the simple 64-bit access is atomic only if the storage location is properly aligned. So for non-`volatile` fields a JVM might use a more relaxed alignment leading to word tearing even on x64. That would not be an optimization but rather the absence of it. Or, well, it could be part of a memory-saving strategy\u2026"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24973890-cu38908711]-[584168912]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"A JIT compiler would not tear a 64-bit value into 32-bit writes intentionally on x64 but afaik the simple 64-bit access is atomic only if the storage location is properly aligned. So for non-`volatile` fields a JVM might use a more relaxed alignment leading to word tearing even on x64. That would not be an optimization but rather the absence of it. Or, well, it could be part of a memory-saving strategy\u2026"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "jit":1,
                        "jvm":1,
                        "lead":1,
                        "bit":3,
                        "simpl":1,
                        "field":1,
                        "intent":1,
                        "proper":1,
                        "align":2,
                        "tear":2,
                        "afaik":1,
                        "strategi":1,
                        "optim":1,
                        "atom":1,
                        "compil":1,
                        "part":1,
                        "absenc":1,
                        "storag":1,
                        "save":1,
                        "relax":1,
                        "word":1,
                        "write":1,
                        "locat":1,
                        "access":1,
                        "memori":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":38962934,
          "postId":24973890,
          "creationDate":"2014-07-31",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":14316,
            "displayName":"pdeva",
            "reputation":5138
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@StuartMarks the advantage, if there is possibly one, is that one could write code that is cleaner/has fewer lines. of course the whole point of the post is to understand what, if any, such advantage is possible"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24973890-cu38962934]-[2041609364]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@StuartMarks the advantage, if there is possibly one, is that one could write code that is cleaner/has fewer lines. of course the whole point of the post is to understand what, if any, such advantage is possible"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"StuartMarks",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "post":1,
                        "point":1,
                        "fewer":1,
                        "cleaner":1,
                        "line":1,
                        "understand":1,
                        "possibl":1,
                        "stuart":1,
                        "code":1,
                        "advantag":2,
                        "mark":1,
                        "write":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":38918470,
          "postId":24973890,
          "creationDate":"2014-07-29",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1441122,
            "displayName":"Stuart Marks",
            "reputation":15984
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@Holger Sheer speculation here: a JIT compiler might peel some iterations from a for-loop over longs and only write the low-order 32 bits since it can presume the high-order 32 bits don't change. If another thread were to write a full 64-bit value, the result might be a 64-bit value that was never actually written by any thread. I have no idea if this has any practical value, but it would seem to be legal for a JIT to do this for a non-volatile long."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24973890-cu38918470]-[-1851577709]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@Holger Sheer speculation here: a JIT compiler might peel some iterations from a for-loop over longs and only write the low-order 32 bits since it can presume the high-order 32 bits don't change. If another thread were to write a full 64-bit value, the result might be a 64-bit value that was never actually written by any thread. I have no idea if this has any practical value, but it would seem to be legal for a JIT to do this for a non-volatile long."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"Holger",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "jit":2,
                        "chang":1,
                        "loop":1,
                        "bit":4,
                        "peel":1,
                        "result":1,
                        "full":1,
                        "idea":1,
                        "specul":1,
                        "long":1,
                        "legal":1,
                        "thread":2,
                        "low":1,
                        "sheer":1,
                        "holger":1,
                        "order":2,
                        "presum":1,
                        "written":1,
                        "iter":1,
                        "compil":1,
                        "practic":1,
                        "write":2,
                        "high":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":38918579,
          "postId":24973890,
          "creationDate":"2014-07-29",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1441122,
            "displayName":"Stuart Marks",
            "reputation":15984
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@RalfH Yeah I'm not sure what OP is after either. OP seems to want to make assumptions for Java programs based on the hardware it's running on, but it's hard for me to understand what advantage could be gained from doing that. The disadvantage is that the JIT might violate assumptions the OP is trying to make simply because it doesn't happen in hardware."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24973890-cu38918579]-[-922408567]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@RalfH Yeah I'm not sure what OP is after either. OP seems to want to make assumptions for Java programs based on the hardware it's running on, but it's hard for me to understand what advantage could be gained from doing that. The disadvantage is that the JIT might violate assumptions the OP is trying to make simply because it doesn't happen in hardware."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"RalfH",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "jit":1,
                        "program":1,
                        "violat":1,
                        "hard":1,
                        "happen":1,
                        "ralf":1,
                        "run":1,
                        "understand":1,
                        "disadvantag":1,
                        "base":1,
                        "advantag":1,
                        "simpli":1,
                        "assumpt":2,
                        "gain":1,
                        "yeah":1,
                        "hardwar":2,
                        "make":2
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":38874732,
          "postId":24973890,
          "creationDate":"2014-07-28",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1441122,
            "displayName":"Stuart Marks",
            "reputation":15984
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@G.BlakeMeike Thanks! Yes, synchronization has been optimized considerably. I've added a note to this effect. But I never say &quot;free&quot; or &quot;nearly free&quot;... then somebody will say, &quot;OK, can I have a billion of them?&quot; :-)"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24973890-cu38874732]-[-1472840618]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@G.BlakeMeike Thanks! Yes, synchronization has been optimized considerably. I've added a note to this effect. But I never say &quot;free&quot; or &quot;nearly free&quot;... then somebody will say, &quot;OK, can I have a billion of them?&quot; :-)"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"G",
                              "comments":[
                                
                              ]
                            },
                            {
                              "type":"IdentifierNode",
                              "name":"BlakeMeike",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "consider":1,
                        "effect":1,
                        "optim":1,
                        "billion":1,
                        "note":1,
                        "ad":1,
                        "quot":6,
                        "meik":1,
                        "blake":1,
                        "free":2,
                        "synchron":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":38865146,
          "postId":24973890,
          "creationDate":"2014-07-28",
          "score":2,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":945226,
            "displayName":"G. Blake Meike",
            "reputation":2938
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Great answer! It might be worth noting that most of those synchronization practices are nearly free... unless they are necessary."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24973890-cu38865146]-[-1852285150]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Great answer! It might be worth noting that most of those synchronization practices are nearly free... unless they are necessary."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "worth":1,
                        "note":1,
                        "answer":1,
                        "practic":1,
                        "great":1,
                        "free":1,
                        "synchron":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":38931351,
          "postId":24973890,
          "creationDate":"2014-07-30",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2711488,
            "displayName":"Holger",
            "reputation":28154
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@Stuart Marks: it could have a practical use if the optimizer is capable of utilizing SSE. Then calculating in 32-Bit rather than 64-Bit means doubling the number of possible parallel computations."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24973890-cu38931351]-[-1561978512]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@Stuart Marks: it could have a practical use if the optimizer is capable of utilizing SSE. Then calculating in 32-Bit rather than 64-Bit means doubling the number of possible parallel computations."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"Stuart",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "number":1,
                        "bit":2,
                        "util":1,
                        "capabl":1,
                        "mean":1,
                        "calcul":1,
                        "stuart":1,
                        "optim":1,
                        "comput":1,
                        "doubl":1,
                        "mark":1,
                        "practic":1,
                        "sse":1,
                        "parallel":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2014-07-26",
      "lastActivityDate":"2014-07-28",
      "lastEditDate":"2014-07-28",
      "score":13,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":1441122,
        "displayName":"Stuart Marks",
        "reputation":15984
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>I know that the JVM memory model is made for lowest common denominator of CPUs, so it has to assume the weakest possible model of a cpu on which the JVM can run (eg ARM).</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[1489331591]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>I know that the JVM memory model is made for lowest common denominator of CPUs, so it has to assume the weakest possible model of a cpu on which the JVM can run (eg ARM).</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jvm":2,
                    "assum":1,
                    "weakest":1,
                    "lowest":1,
                    "model":2,
                    "denomin":1,
                    "run":1,
                    "blockquot":2,
                    "arm":1,
                    "common":1,
                    "cpu":1,
                    "cpus":1,
                    "made":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>That's not correct. The JMM resulted from a compromise among a variety of competing forces: the desire for a weaker memory model so that programs can go faster on hardware that have weak memory models; the desire of compiler writers who want certain optimizations to be allowed; and the desire for the result of parallel Java programs to be correct and predictable, and if possible(!) understandable to Java programmers. See <a href=\"http://cacm.acm.org/magazines/2010/8/96610-memory-models-a-case-for-rethinking-parallel-languages-and-hardware/fulltext\">Sarita Adve's CACM article</a> for a general overview of memory model issues.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[-1099224452]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>That's not correct. The JMM resulted from a compromise among a variety of competing forces: the desire for a weaker memory model so that programs can go faster on hardware that have weak memory models; the desire of compiler writers who want certain optimizations to be allowed; and the desire for the result of parallel Java programs to be correct and predictable, and if possible(!) understandable to Java programmers. See <a href=\"http://cacm.acm.org/magazines/2010/8/96610-memory-models-a-case-for-rethinking-parallel-languages-and-hardware/fulltext\">Sarita Adve's CACM article</a> for a general overview of memory model issues.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "program":2,
                    "weaker":1,
                    "languag":1,
                    "faster":1,
                    "model":4,
                    "writer":1,
                    "compromis":1,
                    "adv":1,
                    "correct":2,
                    "weak":1,
                    "result":2,
                    "varieti":1,
                    "understand":1,
                    "issu":1,
                    "articl":1,
                    "optim":1,
                    "general":1,
                    "fulltext":1,
                    "allow":1,
                    "programm":1,
                    "hardwar":2,
                    "overview":1,
                    "magazin":1,
                    "cacm":2,
                    "desir":3,
                    "compil":1,
                    "predict":1,
                    "forc":1,
                    "org":1,
                    "acm":1,
                    "href":1,
                    "http":1,
                    "jmm":1,
                    "sarita":1,
                    "rethink":1,
                    "parallel":2,
                    "compet":1,
                    "memori":4
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>Considering that x64 has a fairly strong memory model, what synchronization practices can I ignore assuming I know my program will only run on [x64] CPUs?</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[194390781]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>Considering that x64 has a fairly strong memory model, what synchronization practices can I ignore assuming I know my program will only run on [x64] CPUs?</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "program":1,
                    "ignor":1,
                    "assum":1,
                    "fair":1,
                    "model":1,
                    "run":1,
                    "strong":1,
                    "blockquot":2,
                    "cpus":1,
                    "practic":1,
                    "synchron":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>None. The issue is that the memory model applies not only to the underlying hardware, but it also applies to the JVM that's executing your program, and mostly in practice, the JVM's JIT compiler. The compiler might decide to apply certain optimizations that are allowed within the memory model, but if your program is making unwarranted assumptions about the memory behavior based on the underlying hardware, your program will break.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[414264579]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>None. The issue is that the memory model applies not only to the underlying hardware, but it also applies to the JVM that's executing your program, and mostly in practice, the JVM's JIT compiler. The compiler might decide to apply certain optimizations that are allowed within the memory model, but if your program is making unwarranted assumptions about the memory behavior based on the underlying hardware, your program will break.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jit":1,
                    "decid":1,
                    "jvm":2,
                    "program":3,
                    "model":2,
                    "issu":1,
                    "base":1,
                    "optim":1,
                    "assumpt":1,
                    "allow":1,
                    "hardwar":2,
                    "make":1,
                    "under":2,
                    "compil":2,
                    "appli":3,
                    "behavior":1,
                    "practic":1,
                    "execut":1,
                    "unwarr":1,
                    "memori":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>You asked about x64 and atomic 64-bit writes. It may be that no word tearing will ever occur on an x64 machine. I doubt that any JIT compiler would tear a 64-bit value into 32-bit writes as an optimization, but you never know. However, it seems unlikely that you could use this feature to avoid synchronization or volatile fields in your program. Without these, writes to these variables might never become visible to other threads, or they could arbitrarily be re-ordered with respect to other writes, possibly leading to bugs in your program.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[-1753219388]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>You asked about x64 and atomic 64-bit writes. It may be that no word tearing will ever occur on an x64 machine. I doubt that any JIT compiler would tear a 64-bit value into 32-bit writes as an optimization, but you never know. However, it seems unlikely that you could use this feature to avoid synchronization or volatile fields in your program. Without these, writes to these variables might never become visible to other threads, or they could arbitrarily be re-ordered with respect to other writes, possibly leading to bugs in your program.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jit":1,
                    "program":2,
                    "lead":1,
                    "bit":3,
                    "field":1,
                    "occur":1,
                    "tear":2,
                    "arbitrarili":1,
                    "visibl":1,
                    "possibl":1,
                    "avoid":1,
                    "optim":1,
                    "thread":1,
                    "machin":1,
                    "bug":1,
                    "order":1,
                    "doubt":1,
                    "atom":1,
                    "respect":1,
                    "compil":1,
                    "featur":1,
                    "ask":1,
                    "variabl":1,
                    "word":1,
                    "write":4,
                    "synchron":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>My advice is first to apply synchronization properly to get your program correct. You might be pleasantly surprised. The synchronization operations have been heavily optimized and can be very fast in the common case. If you find there are bottlenecks, consider using optimizations like lock splitting, the use of volatiles, or converting to non-blocking algorithms.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[-1999759043]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>My advice is first to apply synchronization properly to get your program correct. You might be pleasantly surprised. The synchronization operations have been heavily optimized and can be very fast in the common case. If you find there are bottlenecks, consider using optimizations like lock splitting, the use of volatiles, or converting to non-blocking algorithms.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "program":1,
                    "find":1,
                    "proper":1,
                    "advic":1,
                    "correct":1,
                    "volatil":1,
                    "lock":1,
                    "surpris":1,
                    "oper":1,
                    "optim":2,
                    "block":1,
                    "common":1,
                    "algorithm":1,
                    "split":1,
                    "fast":1,
                    "pleasant":1,
                    "bottleneck":1,
                    "heavili":1,
                    "appli":1,
                    "convert":1,
                    "synchron":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><strong>UPDATE</strong></p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[1052074519]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><strong>UPDATE</strong></p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "strong":2,
                    "updat":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The OP has updated the question to be a bit more specific about using <code>volatile</code> instead of locks and synchronization.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[-445566574]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The OP has updated the question to be a bit more specific about using <code>volatile</code> instead of locks and synchronization.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "question":1,
                    "bit":1,
                    "updat":1,
                    "lock":1,
                    "code":2,
                    "specif":1,
                    "synchron":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>It turns out that <code>volatile</code> not only has memory visibility semantics. It also makes <code>long</code> and <code>double</code> access atomic, which is not the case for non-<code>volatile</code> variables of those types. See the <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7\">JLS section 17.7</a>. You should be able to rely on <code>volatile</code> to provide atomicity on any hardware, not just x64.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[1645388402]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>It turns out that <code>volatile</code> not only has memory visibility semantics. It also makes <code>long</code> and <code>double</code> access atomic, which is not the case for non-<code>volatile</code> variables of those types. See the <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7\">JLS section 17.7</a>. You should be able to rely on <code>volatile</code> to provide atomicity on any hardware, not just x64.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jls":4,
                    "provid":1,
                    "oracl":1,
                    "visibl":1,
                    "section":1,
                    "doc":1,
                    "code":10,
                    "semant":1,
                    "hardwar":1,
                    "spec":1,
                    "javas":1,
                    "turn":1,
                    "make":1,
                    "atom":2,
                    "reli":1,
                    "type":1,
                    "html":2,
                    "variabl":1,
                    "href":1,
                    "http":1,
                    "access":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>While I'm at it, for additional information about the Java Memory Model, see Aleksey Shipilev's <a href=\"http://shipilev.net/blog/2014/jmm-pragmatics/\">JMM Pragmatics talk transcript</a>. (Aleksey is also the <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">JMH</a> guy.) There's lots of detail in this talk, and some interesting exercises to test one's understanding. One overall takeaway of the talk is that it's often a mistake to rely on one's intuition about how the memory model works, e.g. in terms of cache lines or write buffers. The JMM is a <em>formalism</em> about memory operations and various contraints (<em>synchronizes-with</em>, <em>happens-before</em>, etc.) that determine ordering of those operations. This can have quite counterintuitive results. It's unwise to try to outsmart the JMM by thinking about specific hardware properties. It'll come back to bite you.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24973890]-[-452847229]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>While I'm at it, for additional information about the Java Memory Model, see Aleksey Shipilev's <a href=\"http://shipilev.net/blog/2014/jmm-pragmatics/\">JMM Pragmatics talk transcript</a>. (Aleksey is also the <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">JMH</a> guy.) There's lots of detail in this talk, and some interesting exercises to test one's understanding. One overall takeaway of the talk is that it's often a mistake to rely on one's intuition about how the memory model works, e.g. in terms of cache lines or write buffers. The JMM is a <em>formalism</em> about memory operations and various contraints (<em>synchronizes-with</em>, <em>happens-before</em>, etc.) that determine ordering of those operations. This can have quite counterintuitive results. It's unwise to try to outsmart the JMM by thinking about specific hardware properties. It'll come back to bite you.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "openjdk":1,
                    "properti":1,
                    "test":1,
                    "determin":1,
                    "guy":1,
                    "cach":1,
                    "model":2,
                    "addit":1,
                    "line":1,
                    "project":1,
                    "tool":1,
                    "result":1,
                    "understand":1,
                    "pragmat":2,
                    "term":1,
                    "talk":3,
                    "bite":1,
                    "buffer":1,
                    "takeaway":1,
                    "counterintuit":1,
                    "jmh":2,
                    "unwis":1,
                    "work":1,
                    "net":2,
                    "code":1,
                    "oper":2,
                    "mistak":1,
                    "transcript":1,
                    "blog":1,
                    "interest":1,
                    "inform":1,
                    "order":1,
                    "think":1,
                    "specif":1,
                    "back":1,
                    "hardwar":1,
                    "exercis":1,
                    "outsmart":1,
                    "lot":1,
                    "detail":1,
                    "reli":1,
                    "shipilev":2,
                    "href":2,
                    "http":2,
                    "jmm":4,
                    "formal":1,
                    "contraint":1,
                    "write":1,
                    "intuit":1,
                    "aleksey":2,
                    "synchron":1,
                    "memori":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":24922347,
      "questionId":24918252,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":38766593,
          "postId":24922347,
          "creationDate":"2014-07-24",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":999043,
            "displayName":"Ralf H",
            "reputation":900
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"actually, reordering is done in the cpu after decoding the instructions from memory and building &micro;ops. It may be supported by proper compiler optimizations, though. These have to take into consideration the number of registers available, certain instruction timings and latencies and lots of other cpu-specific information."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24922347-cu38766593]-[1045995326]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"actually, reordering is done in the cpu after decoding the instructions from memory and building &micro;ops. It may be supported by proper compiler optimizations, though. These have to take into consideration the number of registers available, certain instruction timings and latencies and lots of other cpu-specific information."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "number":1,
                        "support":1,
                        "latenc":1,
                        "consider":1,
                        "reorder":1,
                        "proper":1,
                        "regist":1,
                        "build":1,
                        "optim":1,
                        "inform":1,
                        "micro":1,
                        "specif":1,
                        "cpu":2,
                        "lot":1,
                        "decod":1,
                        "compil":1,
                        "time":1,
                        "instruct":2,
                        "op":1,
                        "memori":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":38778706,
          "postId":24922347,
          "creationDate":"2014-07-25",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1853458,
            "displayName":"veritas",
            "reputation":1225
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Please see 3rd point Control Flow Optimizations http://publib.boulder.ibm.com/infocenter/javasdk/v1r4m2/index.jsp?topic=%2Fcom.ibm.java.doc.diagnostics.142j9%2Fhtml%2Fhowjitopt.html"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24922347-cu38778706]-[-2124437194]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Please see 3rd point Control Flow Optimizations http://publib.boulder.ibm.com/infocenter/javasdk/v1r4m2/index.jsp?topic=%2Fcom.ibm.java.doc.diagnostics.142j9%2Fhtml%2Fhowjitopt.html"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "infocent":1,
                        "point":1,
                        "fhtml":1,
                        "doc":1,
                        "diagnost":1,
                        "optim":1,
                        "boulder":1,
                        "fcom":1,
                        "flow":1,
                        "jsp":1,
                        "fhowjitopt":1,
                        "javasdk":1,
                        "control":1,
                        "topic":1,
                        "ibm":2,
                        "publib":1,
                        "html":1,
                        "http":1,
                        "index":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2014-07-23",
      "lastActivityDate":"2014-07-23",
      "score":2,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":1853458,
        "displayName":"veritas",
        "reputation":1225
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Compiler Writes Have taken care of What you wanted to do. Many of the volatile read/write barriers will eventually be no-op on x64. Also do think reordering may also be induced because of compiler optimization and may not depend on Hardware. For exmple benign data races - for example String hashCode. See : <a href=\"http://jeremymanson.blogspot.com/2008/12/benign-data-races-in-java.html\"rel=\"nofollow\">http://jeremymanson.blogspot.com/2008/12/benign-data-races-in-java.html</a></p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24922347]-[-1795678490]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Compiler Writes Have taken care of What you wanted to do. Many of the volatile read/write barriers will eventually be no-op on x64. Also do think reordering may also be induced because of compiler optimization and may not depend on Hardware. For exmple benign data races - for example String hashCode. See : <a href=\"http://jeremymanson.blogspot.com/2008/12/benign-data-races-in-java.html\"rel=\"nofollow\">http://jeremymanson.blogspot.com/2008/12/benign-data-races-in-java.html</a></p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"hashCode",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "benign":3,
                    "exmpl":1,
                    "depend":1,
                    "want":1,
                    "reorder":1,
                    "barrier":1,
                    "data":3,
                    "rel":1,
                    "care":1,
                    "eventu":1,
                    "blogspot":2,
                    "code":1,
                    "jeremymanson":2,
                    "optim":1,
                    "hash":1,
                    "nofollow":1,
                    "race":3,
                    "hardwar":1,
                    "compil":2,
                    "html":2,
                    "href":1,
                    "http":2,
                    "write":2,
                    "induc":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Also Please refer the page for what instructions may be no-op on x64. See : <a href=\"http://gee.cs.oswego.edu/dl/jmm/cookbook.html\"rel=\"nofollow\">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a> see Multiprocessors Section.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24922347]-[1536033194]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Also Please refer the page for what instructions may be no-op on x64. See : <a href=\"http://gee.cs.oswego.edu/dl/jmm/cookbook.html\"rel=\"nofollow\">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a> see Multiprocessors Section.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "oswego":2,
                    "page":1,
                    "rel":1,
                    "cookbook":2,
                    "gee":2,
                    "section":1,
                    "nofollow":1,
                    "refer":1,
                    "multiprocessor":1,
                    "html":2,
                    "href":1,
                    "http":2,
                    "jmm":2,
                    "instruct":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><strong>I will advise not to do any optimizations specific for hardware. You may end up writing Unmaintainable Code. Compiler Writers Have already put up sufficient HardWork</strong>.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24922347]-[-561963013]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><strong>I will advise not to do any optimizations specific for hardware. You may end up writing Unmaintainable Code. Compiler Writers Have already put up sufficient HardWork</strong>.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"HardWork",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "advis":1,
                    "hard":1,
                    "writer":1,
                    "strong":2,
                    "work":1,
                    "code":1,
                    "optim":1,
                    "suffici":1,
                    "specif":1,
                    "hardwar":1,
                    "put":1,
                    "end":1,
                    "compil":1,
                    "unmaintain":1,
                    "write":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"HardWork",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":25030484,
      "questionId":24918252,
      "comments":[
        
      ],
      "creationDate":"2014-07-30",
      "lastActivityDate":"2014-07-30",
      "score":1,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":1569604,
        "displayName":"maslan",
        "reputation":228
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>It not only depends on CPU, but also on the JVM, operating system etc.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25030484]-[-1428169442]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>It not only depends on CPU, but also on the JVM, operating system etc.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jvm":1,
                    "system":1,
                    "depend":1,
                    "oper":1,
                    "cpu":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>One thing you might be sure: don't assume anything if it comes to thread synchronization.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25030484]-[-2046306603]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>One thing you might be sure: don't assume anything if it comes to thread synchronization.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "synchron":1,
                    "thing":1,
                    "thread":1,
                    "assum":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":25076347,
      "questionId":24918252,
      "comments":[
        
      ],
      "creationDate":"2014-08-01",
      "lastActivityDate":"2014-08-01",
      "lastEditDate":"2014-08-01",
      "score":4,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":2111035,
        "displayName":"Chris K",
        "reputation":5861
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><strong>Always include the memory barriers where the JVM memory model states that they are needed and then let the JVM optimize them when it can for different platforms.</strong></p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25076347]-[1880360517]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><strong>Always include the memory barriers where the JVM memory model states that they are needed and then let the JVM optimize them when it can for different platforms.</strong></p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jvm":2,
                    "model":1,
                    "state":1,
                    "barrier":1,
                    "strong":2,
                    "includ":1,
                    "optim":1,
                    "need":1,
                    "platform":1,
                    "memori":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Knowing that you run only on x86 CPUs does not mean that you can drop using memory barriers. Unless perhaps you know that you will only run on single core x86 cpus ;) Which, in todays multi core world no body really knows. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25076347]-[27624133]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Knowing that you run only on x86 CPUs does not mean that you can drop using memory barriers. Unless perhaps you know that you will only run on single core x86 cpus ;) Which, in todays multi core world no body really knows. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "singl":1,
                    "world":1,
                    "barrier":1,
                    "run":2,
                    "drop":1,
                    "know":1,
                    "cpus":2,
                    "bodi":1,
                    "core":2,
                    "multi":1,
                    "today":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Why? Because the java memory model has two main concerns. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25076347]-[1882286643]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Why? Because the java memory model has two main concerns. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "model":1,
                    "main":1,
                    "concern":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<ol> \n <li>visibility of data between cores and </li> \n <li>happens before guarantees, aka re-ordering. </li> \n</ol>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25076347]-[-1132625925]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<ol> \n <li>visibility of data between cores and </li> \n <li>happens before guarantees, aka re-ordering. </li> \n</ol>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "data":1,
                    "visibl":1,
                    "guarante":1,
                    "aka":1,
                    "order":1,
                    "core":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Without a memory barrier in play, the order of operations that become visible to other cores could become very confusing; and that is even with the stronger guarantees offered by x86. x86 only ensures consistency once the data makes it to the cpu caches, and while its ordering guarantees are very strong they only kick in once Hotspot has told the CPU to write out to the cache. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25076347]-[-900600434]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Without a memory barrier in play, the order of operations that become visible to other cores could become very confusing; and that is even with the stronger guarantees offered by x86. x86 only ensures consistency once the data makes it to the cpu caches, and while its ordering guarantees are very strong they only kick in once Hotspot has told the CPU to write out to the cache. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "cach":2,
                    "play":1,
                    "barrier":1,
                    "data":1,
                    "told":1,
                    "visibl":1,
                    "strong":1,
                    "hotspot":1,
                    "oper":1,
                    "guarante":2,
                    "kick":1,
                    "consist":1,
                    "order":2,
                    "cpu":2,
                    "make":1,
                    "offer":1,
                    "confus":1,
                    "stronger":1,
                    "core":1,
                    "write":1,
                    "ensur":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Without the volatile/synchronized then it will be up to the compilers (javac and hotspot) as to when they will do those writes and in what order. It is perfectly valid for them to decide to keep data for extended periods within the registers. Once a volatile or synchronized memory barrier is crossed, then the JVM knows to tell the CPU to send the data out to the cache. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25076347]-[826587125]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Without the volatile/synchronized then it will be up to the compilers (javac and hotspot) as to when they will do those writes and in what order. It is perfectly valid for them to decide to keep data for extended periods within the registers. Once a volatile or synchronized memory barrier is crossed, then the JVM knows to tell the CPU to send the data out to the cache. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "decid":1,
                    "jvm":1,
                    "cach":1,
                    "barrier":1,
                    "data":2,
                    "regist":1,
                    "perfect":1,
                    "extend":1,
                    "hotspot":1,
                    "order":1,
                    "cpu":1,
                    "cross":1,
                    "valid":1,
                    "compil":1,
                    "javac":1,
                    "write":1,
                    "period":1,
                    "send":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>As Doug Lea documents in the <a href=\"http://gee.cs.oswego.edu/dl/jmm/cookbook.html\"rel=\"nofollow\">JSR-133 Cookbook</a> most of the x86 barriers are reduced to no-op instructions that guarantee the ordering. Thus the JVM will make the instructions as efficient as possible for us. Code to the Java Memory Model, and let Hotspot work its magic. If Hotspot can prove that synchronised is not required, it can drop it entirely. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25076347]-[-1912674967]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>As Doug Lea documents in the <a href=\"http://gee.cs.oswego.edu/dl/jmm/cookbook.html\"rel=\"nofollow\">JSR-133 Cookbook</a> most of the x86 barriers are reduced to no-op instructions that guarantee the ordering. Thus the JVM will make the instructions as efficient as possible for us. Code to the Java Memory Model, and let Hotspot work its magic. If Hotspot can prove that synchronised is not required, it can drop it entirely. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jvm":1,
                    "prove":1,
                    "reduc":1,
                    "model":1,
                    "document":1,
                    "doug":1,
                    "oswego":1,
                    "barrier":1,
                    "requir":1,
                    "jsr":1,
                    "rel":1,
                    "effici":1,
                    "cookbook":2,
                    "synchronis":1,
                    "gee":1,
                    "work":1,
                    "hotspot":2,
                    "drop":1,
                    "code":1,
                    "guarante":1,
                    "nofollow":1,
                    "order":1,
                    "make":1,
                    "magic":1,
                    "html":1,
                    "href":1,
                    "http":1,
                    "jmm":1,
                    "lea":1,
                    "instruct":2,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Lastly, the double checked locking pattern was proven to be broken on multi core x86 too; despite its stronger memory guarantees. Some nice detail of this was writen by Bartos Milewski on his C++ <a href=\"http://bartoszmilewski.com/2008/11/05/who-ordered-memory-fences-on-an-x86/\"rel=\"nofollow\">blog</a> and again this time specific to Java <a href=\"http://bartoszmilewski.com/2008/11/\"rel=\"nofollow\">here</a></p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25076347]-[-1717171172]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Lastly, the double checked locking pattern was proven to be broken on multi core x86 too; despite its stronger memory guarantees. Some nice detail of this was writen by Bartos Milewski on his C++ <a href=\"http://bartoszmilewski.com/2008/11/05/who-ordered-memory-fences-on-an-x86/\"rel=\"nofollow\">blog</a> and again this time specific to Java <a href=\"http://bartoszmilewski.com/2008/11/\"rel=\"nofollow\">here</a></p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "proven":1,
                    "pattern":1,
                    "milewski":1,
                    "fenc":1,
                    "rel":2,
                    "writen":1,
                    "lock":1,
                    "nice":1,
                    "last":1,
                    "guarante":1,
                    "blog":1,
                    "nofollow":2,
                    "check":1,
                    "order":1,
                    "specif":1,
                    "detail":1,
                    "stronger":1,
                    "time":1,
                    "core":1,
                    "href":2,
                    "http":2,
                    "barto":1,
                    "multi":1,
                    "bartoszmilewski":2,
                    "broken":1,
                    "memori":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":24918338,
      "questionId":24918252,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":39035528,
          "postId":24918338,
          "creationDate":"2014-08-01",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":773623,
            "displayName":"Jonathan Drapeau",
            "reputation":2171
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Add those comments directly in your answer, people won't need to read them to get the full answer, which is better for the future."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[24918338-cu39035528]-[1760614868]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Add those comments directly in your answer, people won't need to read them to get the full answer, which is better for the future."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "read":1,
                        "full":1,
                        "direct":1,
                        "futur":1,
                        "comment":1,
                        "answer":2,
                        "peopl":1,
                        "add":1,
                        "won":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2014-07-23",
      "lastActivityDate":"2014-08-04",
      "lastEditDate":"2014-08-04",
      "score":5,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":999043,
        "displayName":"Ralf H",
        "reputation":900
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>you would still need to handle thread-safety, so volatility semantics and memory fences will still matter</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24918338]-[-117295844]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>you would still need to handle thread-safety, so volatility semantics and memory fences will still matter</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "fenc":1,
                    "volatil":1,
                    "thread":1,
                    "safeti":1,
                    "semant":1,
                    "matter":1,
                    "handl":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>What I mean here is, eg in Oracle Java, most low-level sync operations end up in Unsafe (docjar.com/docs/api/sun/misc/Unsafe.html#getUnsafe), which in turn has a long list of native methods. So in the end, those synchronization practices and lots of other low-level operations are encapsuled by the JVM where they belong. x64 has not the same jvm as x86.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24918338]-[1150293456]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>What I mean here is, eg in Oracle Java, most low-level sync operations end up in Unsafe (docjar.com/docs/api/sun/misc/Unsafe.html#getUnsafe), which in turn has a long list of native methods. So in the end, those synchronization practices and lots of other low-level operations are encapsuled by the JVM where they belong. x64 has not the same jvm as x86.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"getUnsafe",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jvm":2,
                    "method":1,
                    "docjar":1,
                    "sun":1,
                    "oracl":1,
                    "belong":1,
                    "doc":1,
                    "oper":2,
                    "low":2,
                    "sync":1,
                    "misc":1,
                    "turn":1,
                    "lot":1,
                    "end":2,
                    "api":1,
                    "unsaf":3,
                    "html":1,
                    "practic":1,
                    "encapsul":1,
                    "list":1,
                    "level":2,
                    "synchron":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>after reading your edited question again: the atomicity of your load/store operations was a topic <a href=\"http://stackoverflow.com/questions/3123326/atomicity-in-32-64-bit\">here</a>. So no, you don't have to worry about atomic 64bit load/stores on x64. But since this is not the end of all sync issues, see the other answers.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[24918338]-[1568749469]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>after reading your edited question again: the atomicity of your load/store operations was a topic <a href=\"http://stackoverflow.com/questions/3123326/atomicity-in-32-64-bit\">here</a>. So no, you don't have to worry about atomic 64bit load/stores on x64. But since this is not the end of all sync issues, see the other answers.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "question":2,
                    "bit":2,
                    "store":2,
                    "load":2,
                    "issu":1,
                    "oper":1,
                    "edit":1,
                    "stackoverflow":1,
                    "sync":1,
                    "answer":1,
                    "end":1,
                    "atom":3,
                    "topic":1,
                    "worri":1,
                    "href":1,
                    "http":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}