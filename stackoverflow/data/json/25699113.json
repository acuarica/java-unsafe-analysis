{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":25699113,
    "title":"Simulation thread and data writer thread parallelism",
    "comments":[
      {
        "type":"StackOverflowComment",
        "id":40169139,
        "postId":25699113,
        "creationDate":"2014-09-06",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1103872,
          "displayName":"Marko Topolnik",
          "reputation":88730
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"50 x 10,000 = 500,000 per second. That's hardly much effort for the CPU if it's just about copying the references into another structure."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[25699113-cu40169139]-[1349466726]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"50 x 10,000 = 500,000 per second. That's hardly much effort for the CPU if it's just about copying the references into another structure."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "effort":1,
                      "structur":1,
                      "cpu":1,
                      "refer":1,
                      "copi":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":40169254,
        "postId":25699113,
        "creationDate":"2014-09-06",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1774484,
          "displayName":"Benjamin Albert",
          "reputation":467
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"Why do you want to write the data while the simulation thread is running, any specific reason?"
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[25699113-cu40169254]-[-66193044]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"Why do you want to write the data while the simulation thread is running, any specific reason?"
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "run":1,
                      "data":1,
                      "simul":1,
                      "reason":1,
                      "thread":1,
                      "specif":1,
                      "write":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":40169384,
        "postId":25699113,
        "creationDate":"2014-09-06",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":3266556,
          "displayName":"Ryan Marv",
          "reputation":34
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"Because this way I wouldn't have to synchronize the access to the collections, it may be faster if the simulation thread does the copying and the write thread takes it from there. Maybe not.. I'm curious how most people do this, or what the general approach is."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[25699113-cu40169384]-[2126421526]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"Because this way I wouldn't have to synchronize the access to the collections, it may be faster if the simulation thread does the copying and the write thread takes it from there. Maybe not.. I'm curious how most people do this, or what the general approach is."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "faster":1,
                      "simul":1,
                      "thread":2,
                      "general":1,
                      "take":1,
                      "curious":1,
                      "wouldn":1,
                      "approach":1,
                      "collect":1,
                      "peopl":1,
                      "write":1,
                      "copi":1,
                      "access":1,
                      "synchron":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "tags":[
      "java",
      "multithreading",
      "simulation"
    ],
    "creationDate":"2014-09-06",
    "lastActivityDate":"2014-09-06",
    "score":0,
    "viewCount":52,
    "owner":{
      "type":"StackOverflowUser",
      "id":3266556,
      "displayName":"Ryan Marv",
      "reputation":34
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>This a general programming question. Let's say I have a thread doing a specific simulation, where speed is quite important. At every iteration I want to extract data from it and write it to a file. </p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[25699113]-[-1108052174]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>This a general programming question. Let's say I have a thread doing a specific simulation, where speed is quite important. At every iteration I want to extract data from it and write it to a file. </p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "program":1,
                  "question":1,
                  "data":1,
                  "simul":1,
                  "thread":1,
                  "import":1,
                  "general":1,
                  "specif":1,
                  "iter":1,
                  "file":1,
                  "write":1,
                  "speed":1,
                  "extract":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Is it a better practice to hand over the data to a different thread and let the simulation thread focus on his job, or since speed is very important, make the simulation thread do the data recording too without any copying of data. (in my case it is 3-5 deques of integers with a size of 1000-10000)</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[25699113]-[1683117898]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Is it a better practice to hand over the data to a different thread and let the simulation thread focus on his job, or since speed is very important, make the simulation thread do the data recording too without any copying of data. (in my case it is 3-5 deques of integers with a size of 1000-10000)</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "size":1,
                  "hand":1,
                  "data":3,
                  "job":1,
                  "simul":2,
                  "dequ":1,
                  "integ":1,
                  "thread":3,
                  "import":1,
                  "focus":1,
                  "make":1,
                  "practic":1,
                  "copi":1,
                  "record":1,
                  "speed":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Firstly it surely depends on how much data we are copying, but what else can it depend on? Can the cost of synchronization and copying be worth? Is it a good practice to create small runnables at each iteration to handle the recording task in case of 50 or more iterations per second?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[25699113]-[-2031288275]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Firstly it surely depends on how much data we are copying, but what else can it depend on? Can the cost of synchronization and copying be worth? Is it a good practice to create small runnables at each iteration to handle the recording task in case of 50 or more iterations per second?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "task":1,
                  "depend":2,
                  "sure":1,
                  "good":1,
                  "data":1,
                  "small":1,
                  "worth":1,
                  "cost":1,
                  "iter":2,
                  "runnabl":1,
                  "first":1,
                  "practic":1,
                  "creat":1,
                  "handl":1,
                  "copi":2,
                  "record":1,
                  "synchron":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":25699310,
      "questionId":25699113,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":40170030,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":3266556,
            "displayName":"Ryan Marv",
            "reputation":34
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Great answer, thanks, I'm gonna dig myself into this. Although would you just maintain one writer thread, or make a new one at every iteration with a quick purpose? Because if the writer thread wouldn't finish before the next iteration's data flow comes then its data writing tasks may queue up and further complications will occur. On the other hand if you create a new thread at each iteration they themselves can work in parallel."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170030]-[442334931]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Great answer, thanks, I'm gonna dig myself into this. Although would you just maintain one writer thread, or make a new one at every iteration with a quick purpose? Because if the writer thread wouldn't finish before the next iteration's data flow comes then its data writing tasks may queue up and further complications will occur. On the other hand if you create a new thread at each iteration they themselves can work in parallel."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "task":1,
                        "writer":2,
                        "queue":1,
                        "occur":1,
                        "complic":1,
                        "hand":1,
                        "data":2,
                        "finish":1,
                        "work":1,
                        "gonna":1,
                        "thread":3,
                        "flow":1,
                        "iter":3,
                        "wouldn":1,
                        "make":1,
                        "answer":1,
                        "dig":1,
                        "quick":1,
                        "creat":1,
                        "purpos":1,
                        "great":1,
                        "parallel":1,
                        "write":1,
                        "maintain":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40170133,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1103872,
            "displayName":"Marko Topolnik",
            "reputation":88730
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"The memory barrier business only makes sense if you don't mutate the data structure after publishing to the other thread, and that seems to be the reason why OP intended to copy the structure. So the most important advice would be to make the simulation thread 1. fill a structure, 2. hand it off to the writing thread, 3. create a new structure to fill with more data."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170133]-[-553430169]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"The memory barrier business only makes sense if you don't mutate the data structure after publishing to the other thread, and that seems to be the reason why OP intended to copy the structure. So the most important advice would be to make the simulation thread 1. fill a structure, 2. hand it off to the writing thread, 3. create a new structure to fill with more data."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "sens":1,
                        "advic":1,
                        "barrier":1,
                        "hand":1,
                        "data":2,
                        "simul":1,
                        "reason":1,
                        "mutat":1,
                        "structur":4,
                        "publish":1,
                        "intend":1,
                        "thread":3,
                        "import":1,
                        "busi":1,
                        "fill":2,
                        "make":2,
                        "creat":1,
                        "write":1,
                        "copi":1,
                        "memori":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40170176,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":1,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1103872,
            "displayName":"Marko Topolnik",
            "reputation":88730
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Also, whether handing off to another thread actually helps performance is highly dependent on the CPU core count vs. the count of active threads on the JVM. A state-of-the art simulation would be expected to leverage multicore computing for its own purposes (data-parallel computation is usually dominant in simulations)."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170176]-[-1205342255]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Also, whether handing off to another thread actually helps performance is highly dependent on the CPU core count vs. the count of active threads on the JVM. A state-of-the art simulation would be expected to leverage multicore computing for its own purposes (data-parallel computation is usually dominant in simulations)."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "jvm":1,
                        "art":1,
                        "count":2,
                        "leverag":1,
                        "depend":1,
                        "state":1,
                        "multicor":1,
                        "hand":1,
                        "data":1,
                        "simul":2,
                        "domin":1,
                        "help":1,
                        "thread":2,
                        "comput":2,
                        "activ":1,
                        "expect":1,
                        "cpu":1,
                        "perform":1,
                        "core":1,
                        "purpos":1,
                        "parallel":1,
                        "high":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40170211,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":1,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1103872,
            "displayName":"Marko Topolnik",
            "reputation":88730
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@OP: if your writing thread falls behind the simulation, then your cause is lost because you can't improve I/O speed by throwing more CPU at it."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170211]-[718029530]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@OP: if your writing thread falls behind the simulation, then your cause is lost because you can't improve I/O speed by throwing more CPU at it."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"OP",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "simul":1,
                        "lost":1,
                        "improv":1,
                        "fall":1,
                        "thread":1,
                        "cpu":1,
                        "throw":1,
                        "write":1,
                        "speed":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40170239,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":1,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1103872,
            "displayName":"Marko Topolnik",
            "reputation":88730
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"On memory-mapped files: even regular, blocking I/O makes use of the system cache and the disk writes are performed asynchronously."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170239]-[-2017196572]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"On memory-mapped files: even regular, blocking I/O makes use of the system cache and the disk writes are performed asynchronously."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "asynchron":1,
                        "cach":1,
                        "system":1,
                        "disk":1,
                        "map":1,
                        "regular":1,
                        "block":1,
                        "perform":1,
                        "make":1,
                        "file":1,
                        "write":1,
                        "memori":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40170601,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2111035,
            "displayName":"Chris K",
            "reputation":5861
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@MarkoTopolnik a fair point, SSDs especially go async under the hood, that said memory mapping files in Java combined with direct memory access is 10x or more faster than going via OutputStream/Writers/Channel alternatives."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170601]-[-377451915]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@MarkoTopolnik a fair point, SSDs especially go async under the hood, that said memory mapping files in Java combined with direct memory access is 10x or more faster than going via OutputStream/Writers/Channel alternatives."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"MarkoTopolnik",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"OutputStream",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "channel":1,
                        "fair":1,
                        "point":1,
                        "faster":1,
                        "ssds":1,
                        "writer":1,
                        "map":1,
                        "altern":1,
                        "direct":1,
                        "hood":1,
                        "async":1,
                        "marko":1,
                        "combin":1,
                        "stream":1,
                        "topolnik":1,
                        "file":1,
                        "output":1,
                        "access":1,
                        "memori":2
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"OutputStream",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40170668,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2111035,
            "displayName":"Chris K",
            "reputation":5861
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@MarkoTopolnik you raise another good point regarding falling behind I/O speed. I was working on the assumption that the stats would be overwriting previous stats, as the JVM does in one of its status files. Thus changes that are lost in time may not make it to disk, which would be fine. In the case of it acting more as a log, then batching would kick in and only help up to a point. So good point. If the OP did mean a log of appending stats, then use of HFT Chronicle directly would be an excellent choice (and simpler than rolling ones own mechnanism."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170668]-[-786841796]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@MarkoTopolnik you raise another good point regarding falling behind I/O speed. I was working on the assumption that the stats would be overwriting previous stats, as the JVM does in one of its status files. Thus changes that are lost in time may not make it to disk, which would be fine. In the case of it acting more as a log, then batching would kick in and only help up to a point. So good point. If the OP did mean a log of appending stats, then use of HFT Chronicle directly would be an excellent choice (and simpler than rolling ones own mechnanism."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"MarkoTopolnik",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "jvm":1,
                        "point":3,
                        "disk":1,
                        "good":2,
                        "previous":1,
                        "stat":3,
                        "lost":1,
                        "work":1,
                        "hft":1,
                        "fall":1,
                        "direct":1,
                        "excel":1,
                        "kick":1,
                        "batch":1,
                        "roll":1,
                        "marko":1,
                        "assumpt":1,
                        "rais":1,
                        "status":1,
                        "choic":1,
                        "topolnik":1,
                        "make":1,
                        "file":1,
                        "mechnan":1,
                        "fine":1,
                        "time":1,
                        "act":1,
                        "chronicl":1,
                        "overwrit":1,
                        "log":2,
                        "simpler":1,
                        "speed":1,
                        "append":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40170688,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1103872,
            "displayName":"Marko Topolnik",
            "reputation":88730
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"I think the speed comes not so much from memory mapping as from a better, lower-level implementation. Classic I/O does a lot of redundant buffer-to-buffer copying. We should better compare the performance of `Files.newByteChannel()` with it."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170688]-[1209343014]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"I think the speed comes not so much from memory mapping as from a better, lower-level implementation. Classic I/O does a lot of redundant buffer-to-buffer copying. We should better compare the performance of `Files.newByteChannel()` with it."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"Files",
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"IdentifierNode",
                            "name":"newByteChannel",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "channel":1,
                        "redund":1,
                        "map":1,
                        "classic":1,
                        "buffer":2,
                        "lower":1,
                        "compar":1,
                        "perform":1,
                        "implement":1,
                        "lot":1,
                        "file":1,
                        "copi":1,
                        "speed":1,
                        "level":1,
                        "memori":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40170736,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2111035,
            "displayName":"Chris K",
            "reputation":5861
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@MarkoTopolnik and when you say a 'lot of redundant copy'; doesn't it just! :)"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170736]-[411300882]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@MarkoTopolnik and when you say a 'lot of redundant copy'; doesn't it just! :)"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"MarkoTopolnik",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "redund":1,
                        "marko":1,
                        "topolnik":1,
                        "lot":1,
                        "copi":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40170896,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1103872,
            "displayName":"Marko Topolnik",
            "reputation":88730
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Your note on the semantics of `lazySet` is very interesting... I have been studying the semantics of `volatile` and `lazySet` quite throroughly and actually could not find any specified difference. There is no guarantee from the Java Memory Model that, as soon as the `volatile` write completes, another thread is guaranteed to observe the write. The JMM gives no wall-clock guarantees of any kind, in fact. If you're interested in this, check out my [SO question on the topic](http://stackoverflow.com/questions/11761552/guarantees-given-by-the-java-memory-model)."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40170896]-[-1039024151]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Your note on the semantics of `lazySet` is very interesting... I have been studying the semantics of `volatile` and `lazySet` quite throroughly and actually could not find any specified difference. There is no guarantee from the Java Memory Model that, as soon as the `volatile` write completes, another thread is guaranteed to observe the write. The JMM gives no wall-clock guarantees of any kind, in fact. If you're interested in this, check out my [SO question on the topic](http://stackoverflow.com/questions/11761552/guarantees-given-by-the-java-memory-model)."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"lazySet",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"lazySet",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "find":1,
                        "question":2,
                        "observ":1,
                        "model":2,
                        "differ":1,
                        "set":2,
                        "lazi":2,
                        "fact":1,
                        "guarante":4,
                        "stackoverflow":1,
                        "thread":1,
                        "wall":1,
                        "clock":1,
                        "check":1,
                        "interest":2,
                        "note":1,
                        "semant":2,
                        "studi":1,
                        "topic":1,
                        "complet":1,
                        "kind":1,
                        "throrough":1,
                        "http":1,
                        "jmm":1,
                        "write":2,
                        "memori":2
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":40171192,
          "postId":25699310,
          "creationDate":"2014-09-06",
          "score":1,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2111035,
            "displayName":"Chris K",
            "reputation":5861
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@RyanMarv I would not create more than one I/O thread, there would be no advantage to this (only cost); unless perhaps you were using multiple hard drives. One reason that I suggested memory mapped files, is that you may not actually need to create another thread yourself at all. The OS can do it for you via its paging mechanism. Could you confirm whether you are looking to create a journal of entries or just a single entry that gets over written. You may be best served by using HFT Chronicle and staying away from the implementation challenges, unless you are interested in them of course."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25699310-cu40171192]-[-992114221]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@RyanMarv I would not create more than one I/O thread, there would be no advantage to this (only cost); unless perhaps you were using multiple hard drives. One reason that I suggested memory mapped files, is that you may not actually need to create another thread yourself at all. The OS can do it for you via its paging mechanism. Could you confirm whether you are looking to create a journal of entries or just a single entry that gets over written. You may be best served by using HFT Chronicle and staying away from the implementation challenges, unless you are interested in them of course."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"RyanMarv",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"MethodDeclaratorNode",
                        "modifiers":[
                          
                        ],
                        "returnType":{
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"to",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"this",
                          "comments":[
                            
                          ]
                        },
                        "parameters":{
                          "type":"FormalParametersNode",
                          "parameters":{
                            "type":"FormalParameterDeclsNode",
                            "modifiers":[
                              
                            ],
                            "parameterType":{
                              "type":"ReferenceTypeNode",
                              "ids":[
                                {
                                  "type":"ParameterizedTypeNode",
                                  "identifier":{
                                    "type":"IdentifierNode",
                                    "name":"only",
                                    "comments":[
                                      
                                    ]
                                  },
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "nextDeclarator":{
                              "type":"AdditionalFormalParameterDeclNode",
                              "variableDeclarator":{
                                "type":"VariableDeclaratorNode",
                                "identifier":{
                                  "type":"IdentifierNode",
                                  "name":"cost",
                                  "comments":[
                                    
                                  ]
                                },
                                "arrayDepth":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          },
                          "comments":[
                            
                          ]
                        },
                        "arrayReturnType":[
                          
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "drive":1,
                        "singl":1,
                        "hard":1,
                        "ryan":1,
                        "map":1,
                        "serv":1,
                        "journal":1,
                        "suggest":1,
                        "page":1,
                        "marv":1,
                        "reason":1,
                        "hft":1,
                        "thread":2,
                        "entri":2,
                        "advantag":1,
                        "challeng":1,
                        "interest":1,
                        "cost":1,
                        "written":1,
                        "mechan":1,
                        "confirm":1,
                        "implement":1,
                        "file":1,
                        "stay":1,
                        "creat":3,
                        "multipl":1,
                        "chronicl":1,
                        "memori":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"to",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"only",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        {
                          "type":"VariableDeclaratorNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"cost",
                            "comments":[
                              
                            ]
                          },
                          "arrayDepth":[
                            
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2014-09-06",
      "lastActivityDate":"2014-09-06",
      "lastEditDate":"2014-09-06",
      "score":2,
      "isAccepted":true,
      "owner":{
        "type":"StackOverflowUser",
        "id":2111035,
        "displayName":"Chris K",
        "reputation":5861
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>If you truly want low latency on this stat capturing, and you want it during the simulation itself then two techniques come to mind. They can be used together very effectively. Please note that these two approaches are fairly far from the standard Java trodden path, so measure first and confirm that you need these techniques before abusing them; they can be difficult to implement correctly.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25699310]-[-1919854302]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>If you truly want low latency on this stat capturing, and you want it during the simulation itself then two techniques come to mind. They can be used together very effectively. Please note that these two approaches are fairly far from the standard Java trodden path, so measure first and confirm that you need these techniques before abusing them; they can be difficult to implement correctly.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "latenc":1,
                    "fair":1,
                    "path":1,
                    "standard":1,
                    "correct":1,
                    "effect":1,
                    "abus":1,
                    "stat":1,
                    "simul":1,
                    "measur":1,
                    "low":1,
                    "difficult":1,
                    "mind":1,
                    "captur":1,
                    "note":1,
                    "techniqu":2,
                    "confirm":1,
                    "implement":1,
                    "approach":1,
                    "trodden":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<ol> \n <li><p>The fastest way to write the data to file during a simulation, without slowing down the simulation is to hand the work off to another thread. However care has to be taken on how the hand off occurs, as a memory barrier in the simulation thread will slow the simulation. Given the writer only cares that the values will come eventually I would consider using the memory barrier that sits behind AtomicLong.lazySet, it requests a thread safe write out to a memory address without blocking for the write to actually become visible to the other thread. Unfortunately direct access to this memory barrier is currently only availble via lazySet or via class sun.misc.Unsafe, which obviously is not part of the public Java API. However that should not be too large of a hurdle as it is on all current JVM implementations and Doug Lea is talking about moving parts of it into the mainstream. </p></li> \n <li><p>To avoid the slow, blocking file IO that Java uses; make use of a memory mapped file. This lets the OS perform async IO for you on your behalf, and is very efficient. It also supports use of the same memory barrier mentioned above.</p></li> \n</ol>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25699310]-[369044685]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<ol> \n <li><p>The fastest way to write the data to file during a simulation, without slowing down the simulation is to hand the work off to another thread. However care has to be taken on how the hand off occurs, as a memory barrier in the simulation thread will slow the simulation. Given the writer only cares that the values will come eventually I would consider using the memory barrier that sits behind AtomicLong.lazySet, it requests a thread safe write out to a memory address without blocking for the write to actually become visible to the other thread. Unfortunately direct access to this memory barrier is currently only availble via lazySet or via class sun.misc.Unsafe, which obviously is not part of the public Java API. However that should not be too large of a hurdle as it is on all current JVM implementations and Doug Lea is talking about moving parts of it into the mainstream. </p></li> \n <li><p>To avoid the slow, blocking file IO that Java uses; make use of a memory mapped file. This lets the OS perform async IO for you on your behalf, and is very efficient. It also supports use of the same memory barrier mentioned above.</p></li> \n</ol>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"AtomicLong",
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"IdentifierNode",
                        "name":"lazySet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"lazySet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ClassDeclarationNode",
                    "modifiers":[
                      
                    ],
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"sun",
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"LocalVariableDeclarationStatementNode",
                    "modifiers":[
                      
                    ],
                    "declarators":{
                      "type":"VariableDeclaratorsNode",
                      "declarators":[
                        {
                          "type":"VariableDeclaratorNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"uses",
                            "comments":[
                              
                            ]
                          },
                          "arrayDepth":[
                            
                          ],
                          "varType":{
                            "type":"ReferenceTypeNode",
                            "ids":[
                              {
                                "type":"ParameterizedTypeNode",
                                "identifier":{
                                  "type":"IdentifierNode",
                                  "name":"Java",
                                  "comments":[
                                    
                                  ]
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          }
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jvm":1,
                    "support":1,
                    "move":1,
                    "slow":3,
                    "request":1,
                    "sit":1,
                    "mainstream":1,
                    "writer":1,
                    "map":1,
                    "doug":1,
                    "occur":1,
                    "barrier":4,
                    "hand":2,
                    "data":1,
                    "set":2,
                    "sun":1,
                    "effici":1,
                    "talk":1,
                    "lazi":2,
                    "simul":4,
                    "visibl":1,
                    "care":2,
                    "eventu":1,
                    "fastest":1,
                    "safe":1,
                    "avoid":1,
                    "work":1,
                    "hurdl":1,
                    "direct":1,
                    "behalf":1,
                    "block":2,
                    "thread":4,
                    "mention":1,
                    "async":1,
                    "larg":1,
                    "perform":1,
                    "valu":1,
                    "implement":1,
                    "misc":1,
                    "address":1,
                    "make":1,
                    "file":3,
                    "atom":1,
                    "api":1,
                    "unsaf":1,
                    "part":2,
                    "current":1,
                    "let":1,
                    "lea":1,
                    "write":3,
                    "access":1,
                    "availbl":1,
                    "memori":6
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"Java",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    {
                      "type":"VariableDeclaratorNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"uses",
                        "comments":[
                          
                        ]
                      },
                      "arrayDepth":[
                        
                      ],
                      "varType":{
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"Java",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>For examples of both techniques, I strongly recommend reading the source code to HFT Chronicle by Peter Lawrey. In fact, HFT Chronicle may be just the library for you to use here. It offers a highly efficient and simple to use disk backed queue that can sustain a million or so messages per second. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25699310]-[-1958646332]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>For examples of both techniques, I strongly recommend reading the source code to HFT Chronicle by Peter Lawrey. In fact, HFT Chronicle may be just the library for you to use here. It offers a highly efficient and simple to use disk backed queue that can sustain a million or so messages per second. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "recommend":1,
                    "simpl":1,
                    "disk":1,
                    "queue":1,
                    "exampl":1,
                    "peter":1,
                    "effici":1,
                    "librari":1,
                    "strong":1,
                    "hft":2,
                    "code":1,
                    "fact":1,
                    "techniqu":1,
                    "back":1,
                    "offer":1,
                    "million":1,
                    "messag":1,
                    "sustain":1,
                    "lawrey":1,
                    "chronicl":2,
                    "sourc":1,
                    "high":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":25700138,
      "questionId":25699113,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":40170852,
          "postId":25700138,
          "creationDate":"2014-09-06",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2111035,
            "displayName":"Chris K",
            "reputation":5861
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"+1 for &quot;Better try first with simple, easily maintainable code .. without a confirmed need for that&quot;"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[25700138-cu40170852]-[-2098280323]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"+1 for &quot;Better try first with simple, easily maintainable code .. without a confirmed need for that&quot;"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "simpl":1,
                        "code":1,
                        "easili":1,
                        "confirm":1,
                        "quot":2,
                        "maintain":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2014-09-06",
      "lastActivityDate":"2014-09-06",
      "score":2,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":1103872,
        "displayName":"Marko Topolnik",
        "reputation":88730
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>In my work on a <a href=\"https://github.com/mtopolnik/request-age\"rel=\"nofollow\">stress-testing HTTP client</a> I stored the stats into an array and, when the array was ready to send to the GUI, I would create a new array for the tester client and hand off the full array to the network layer. This means that you don't need to pay for any copying, just for the allocation of a fresh array (an ultra-fast operation on the JVM, involving hand-coded assembler macros to utilize the best SIMD instructions available for the task).</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25700138]-[-1846069636]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>In my work on a <a href=\"https://github.com/mtopolnik/request-age\"rel=\"nofollow\">stress-testing HTTP client</a> I stored the stats into an array and, when the array was ready to send to the GUI, I would create a new array for the tester client and hand off the full array to the network layer. This means that you don't need to pay for any copying, just for the allocation of a fresh array (an ultra-fast operation on the JVM, involving hand-coded assembler macros to utilize the best SIMD instructions available for the task).</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "readi":1,
                    "jvm":1,
                    "network":1,
                    "github":1,
                    "test":1,
                    "involv":1,
                    "assembl":1,
                    "task":1,
                    "simd":1,
                    "request":1,
                    "alloc":1,
                    "util":1,
                    "fresh":1,
                    "hand":2,
                    "stat":1,
                    "full":1,
                    "macro":1,
                    "rel":1,
                    "mean":1,
                    "store":1,
                    "pay":1,
                    "https":1,
                    "age":1,
                    "work":1,
                    "tester":1,
                    "code":1,
                    "oper":1,
                    "layer":1,
                    "array":5,
                    "ultra":1,
                    "nofollow":1,
                    "stress":1,
                    "client":2,
                    "mtopolnik":1,
                    "fast":1,
                    "href":1,
                    "http":1,
                    "creat":1,
                    "gui":1,
                    "copi":1,
                    "instruct":1,
                    "send":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>I would also suggest not throwing yourself head-on into the realms of optimal memory barrier usage; the difference between a plain <code>volatile</code> write and an <code>AtomicReference.lazySet()</code> can only be measurable if your thread does almost nothing else but excercise the memory barrier (at least millions of writes per second). Depending on your target I/O throughput, you may not even need NIO to meet the goal. Better try first with simple, easily maintainable code than dig elbows-deep into highly specialized APIs without a confirmed need for that.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[25700138]-[-640627183]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>I would also suggest not throwing yourself head-on into the realms of optimal memory barrier usage; the difference between a plain <code>volatile</code> write and an <code>AtomicReference.lazySet()</code> can only be measurable if your thread does almost nothing else but excercise the memory barrier (at least millions of writes per second). Depending on your target I/O throughput, you may not even need NIO to meet the goal. Better try first with simple, easily maintainable code than dig elbows-deep into highly specialized APIs without a confirmed need for that.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"AtomicReference",
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"IdentifierNode",
                        "name":"lazySet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "simpl":1,
                    "depend":1,
                    "differ":1,
                    "head":1,
                    "barrier":2,
                    "suggest":1,
                    "set":1,
                    "lazi":1,
                    "goal":1,
                    "nio":1,
                    "measur":1,
                    "code":5,
                    "easili":1,
                    "optim":1,
                    "thread":1,
                    "deep":1,
                    "elbow":1,
                    "refer":1,
                    "confirm":1,
                    "plain":1,
                    "usag":1,
                    "target":1,
                    "atom":1,
                    "realm":1,
                    "meet":1,
                    "dig":1,
                    "api":1,
                    "million":1,
                    "special":1,
                    "excercis":1,
                    "throughput":1,
                    "throw":1,
                    "write":2,
                    "high":1,
                    "maintain":1,
                    "memori":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}