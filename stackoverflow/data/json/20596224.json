{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":20596224,
    "title":"Java, buffer lazily allocated, free-able on demand and addressed as byte []",
    "comments":[
      {
        "type":"StackOverflowComment",
        "id":30816248,
        "postId":20596224,
        "creationDate":"2013-12-15",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1103872,
          "displayName":"Marko Topolnik",
          "reputation":88730
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"I just don't see how that &quot;would happen in C++&quot;. You are generally describing how the low-level virtual memory-to-RAM commitment works, but that's as true of Java as of C++. The only difference is that C++ doesn't automatically initialize everything to zero, which allows the pages to stay uncommitted. They are still allocated, though."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[20596224-cu30816248]-[1603396613]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"I just don't see how that &quot;would happen in C++&quot;. You are generally describing how the low-level virtual memory-to-RAM commitment works, but that's as true of Java as of C++. The only difference is that C++ doesn't automatically initialize everything to zero, which allows the pages to stay uncommitted. They are still allocated, though."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "alloc":1,
                      "ram":1,
                      "commit":1,
                      "happen":1,
                      "differ":1,
                      "page":1,
                      "work":1,
                      "virtual":1,
                      "automat":1,
                      "low":1,
                      "general":1,
                      "true":1,
                      "quot":2,
                      "initi":1,
                      "stay":1,
                      "describ":1,
                      "uncommit":1,
                      "level":1,
                      "memori":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":30816446,
        "postId":20596224,
        "creationDate":"2013-12-15",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1103872,
          "displayName":"Marko Topolnik",
          "reputation":88730
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"So what you are after is a way to allocate memory in Java without initializing it."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[20596224-cu30816446]-[1186377135]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"So what you are after is a way to allocate memory in Java without initializing it."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "alloc":1,
                      "initi":1,
                      "memori":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":30816478,
        "postId":20596224,
        "creationDate":"2013-12-15",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":3104677,
          "displayName":"Mike J.",
          "reputation":26
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"I totally agree with you. For me the advantage of the C++ behaviour seems to be that it allows overcommit-ing of memory. I can allocate a large buffer and if I only use a bit of it that is ok, no harm done. With the Java approach that eats up memory that could be used by other processes."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[20596224-cu30816478]-[829054602]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"I totally agree with you. For me the advantage of the C++ behaviour seems to be that it allows overcommit-ing of memory. I can allocate a large buffer and if I only use a bit of it that is ok, no harm done. With the Java approach that eats up memory that could be used by other processes."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "bit":1,
                      "alloc":1,
                      "process":1,
                      "eat":1,
                      "buffer":1,
                      "ing":1,
                      "total":1,
                      "larg":1,
                      "advantag":1,
                      "overcommit":1,
                      "behaviour":1,
                      "agre":1,
                      "approach":1,
                      "harm":1,
                      "memori":2
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":30816512,
        "postId":20596224,
        "creationDate":"2013-12-15",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":3104677,
          "displayName":"Mike J.",
          "reputation":26
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"Yes, allocating without initializing is part of it. But I would also like it to be outside of the garbage collector reach. And to be able to access it as a byte [] so that I do not have to change existing code. Sounds tough to do :("
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[20596224-cu30816512]-[70778571]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"Yes, allocating without initializing is part of it. But I would also like it to be outside of the garbage collector reach. And to be able to access it as a byte [] so that I do not have to change existing code. Sounds tough to do :("
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "chang":1,
                      "reach":1,
                      "collector":1,
                      "alloc":1,
                      "exist":1,
                      "code":1,
                      "sound":1,
                      "initi":1,
                      "tough":1,
                      "part":1,
                      "garbag":1,
                      "access":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":30816557,
        "postId":20596224,
        "creationDate":"2013-12-15",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1103872,
          "displayName":"Marko Topolnik",
          "reputation":88730
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"`Unsafe#allocateMemory` fits your bill up to becoming a `byte[]`, which would breach the JLS and thus isn't a realistic option. I guess the closest you may get is to build a byte-oriented abstraction around it and adapt existing code."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[20596224-cu30816557]-[863075917]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"`Unsafe#allocateMemory` fits your bill up to becoming a `byte[]`, which would breach the JLS and thus isn't a realistic option. I guess the closest you may get is to build a byte-oriented abstraction around it and adapt existing code."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    {
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"allocateMemory",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "adapt":1,
                      "jls":1,
                      "alloc":1,
                      "exist":1,
                      "fit":1,
                      "option":1,
                      "abstract":1,
                      "build":1,
                      "code":1,
                      "bill":1,
                      "realist":1,
                      "isn":1,
                      "orient":1,
                      "breach":1,
                      "unsaf":1,
                      "guess":1,
                      "closest":1,
                      "memori":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":30816731,
        "postId":20596224,
        "creationDate":"2013-12-15",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":3104677,
          "displayName":"Mike J.",
          "reputation":26
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"That is one option but the existing code-base is not very well written and passes byte [] among many classes. It will be quite time-consuming. I am hoping for some magic (reflection?) that would allow perhaps modifying an existing byte [] to point to some memory allocated with Unsafe.allocateMemory."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[20596224-cu30816731]-[-1366586029]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"That is one option but the existing code-base is not very well written and passes byte [] among many classes. It will be quite time-consuming. I am hoping for some magic (reflection?) that would allow perhaps modifying an existing byte [] to point to some memory allocated with Unsafe.allocateMemory."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    {
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"Unsafe",
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"IdentifierNode",
                          "name":"allocateMemory",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "consum":1,
                      "point":1,
                      "alloc":2,
                      "exist":2,
                      "option":1,
                      "base":1,
                      "code":1,
                      "hope":1,
                      "written":1,
                      "modifi":1,
                      "pass":1,
                      "class":1,
                      "magic":1,
                      "unsaf":1,
                      "time":1,
                      "reflect":1,
                      "memori":2
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":30816769,
        "postId":20596224,
        "creationDate":"2013-12-15",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1103872,
          "displayName":"Marko Topolnik",
          "reputation":88730
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"But realize that a `byte[]` is nothing close to a homogenous chunk of address space. It has headers, type information, length field, GC flags, etc. It is designed to play along with the JVM band."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[20596224-cu30816769]-[1084016061]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"But realize that a `byte[]` is nothing close to a homogenous chunk of address space. It has headers, type information, length field, GC flags, etc. It is designed to play along with the JVM band."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "jvm":1,
                      "chunk":1,
                      "design":1,
                      "field":1,
                      "play":1,
                      "band":1,
                      "homogen":1,
                      "space":1,
                      "inform":1,
                      "flag":1,
                      "address":1,
                      "header":1,
                      "length":1,
                      "type":1,
                      "close":1,
                      "realiz":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":30816863,
        "postId":20596224,
        "creationDate":"2013-12-15",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":3104677,
          "displayName":"Mike J.",
          "reputation":26
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"Exactly. That is why, at least for me, it seems very hard to do."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[20596224-cu30816863]-[25886975]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"Exactly. That is why, at least for me, it seems very hard to do."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "hard":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":30816895,
        "postId":20596224,
        "creationDate":"2013-12-15",
        "score":1,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1103872,
          "displayName":"Marko Topolnik",
          "reputation":88730
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"&quot;Impossible&quot; is more appropriate, save for forking the entire OpenJDK project and fixing up HotSpot to treat this."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[20596224-cu30816895]-[-1321458708]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"&quot;Impossible&quot; is more appropriate, save for forking the entire OpenJDK project and fixing up HotSpot to treat this."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"HotSpot",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "project":1,
                      "imposs":1,
                      "fix":1,
                      "entir":1,
                      "open":1,
                      "fork":1,
                      "spot":1,
                      "quot":2,
                      "treat":1,
                      "hot":1,
                      "save":1,
                      "jdk":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"HotSpot",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "tags":[
      "java",
      "memory-management"
    ],
    "creationDate":"2013-12-15",
    "lastActivityDate":"2013-12-15",
    "lastEditDate":"2013-12-15",
    "score":5,
    "viewCount":82,
    "owner":{
      "type":"StackOverflowUser",
      "id":3104677,
      "displayName":"Mike J.",
      "reputation":26
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I am trying to implement a proof-of-concept memory-aware scheduling functionality by extending an existing Java program. The program uses buffers under the form of byte []. For my purpose byte [] are problematic because </p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[20596224]-[-506688848]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I am trying to implement a proof-of-concept memory-aware scheduling functionality by extending an existing Java program. The program uses buffers under the form of byte []. For my purpose byte [] are problematic because </p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "program":2,
                  "exist":1,
                  "buffer":1,
                  "extend":1,
                  "awar":1,
                  "function":1,
                  "proof":1,
                  "implement":1,
                  "concept":1,
                  "schedul":1,
                  "form":1,
                  "purpos":1,
                  "problemat":1,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<ol> \n <li>they are garbage collected </li> \n <li>they are allocated upfront instead of lazily (the JVM seems to touch all pages it has allocated when creating the buffer) </li> \n <li>they make the JVM allocate more and more memory which is not given back the OS.</li> \n</ol>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[20596224]-[-1693994368]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<ol> \n <li>they are garbage collected </li> \n <li>they are allocated upfront instead of lazily (the JVM seems to touch all pages it has allocated when creating the buffer) </li> \n <li>they make the JVM allocate more and more memory which is not given back the OS.</li> \n</ol>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "jvm":2,
                  "alloc":3,
                  "touch":1,
                  "page":1,
                  "lazili":1,
                  "buffer":1,
                  "upfront":1,
                  "back":1,
                  "make":1,
                  "collect":1,
                  "creat":1,
                  "garbag":1,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>To achieve my goal I would like buffers to be lazily allocated memory (pages allocated only when written to) and free-able on demand. This is similar to how it would happen in C++. In addition, as much as possible, I would like to minimize the changes to the existing code-base.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[20596224]-[-1671359314]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>To achieve my goal I would like buffers to be lazily allocated memory (pages allocated only when written to) and free-able on demand. This is similar to how it would happen in C++. In addition, as much as possible, I would like to minimize the changes to the existing code-base.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "minim":1,
                  "alloc":2,
                  "exist":1,
                  "addit":1,
                  "similar":1,
                  "happen":1,
                  "page":1,
                  "lazili":1,
                  "goal":1,
                  "buffer":1,
                  "base":1,
                  "code":1,
                  "achiev":1,
                  "written":1,
                  "demand":1,
                  "free":1,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I looked at nio.ByteBuffer and at the Unsafe classes. Neither fits my case because</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[20596224]-[-1435730407]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I looked at nio.ByteBuffer and at the Unsafe classes. Neither fits my case because</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"nio",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"ByteBuffer",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "fit":1,
                  "look":1,
                  "nio":1,
                  "buffer":1,
                  "class":1,
                  "unsaf":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"nio",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"ByteBuffer",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<ol> \n <li>java.nio.ByteBuffers don't seem to be lazily allocated. When I allocate an empty 1GB buffer the RSS of the program immediately goes to 1GB.</li> \n <li>Unsafe.allocateMemory is lazily allocated but I do not know how to reference it as byte [].</li> \n</ol>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[20596224]-[-2116939148]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<ol> \n <li>java.nio.ByteBuffers don't seem to be lazily allocated. When I allocate an empty 1GB buffer the RSS of the program immediately goes to 1GB.</li> \n <li>Unsafe.allocateMemory is lazily allocated but I do not know how to reference it as byte [].</li> \n</ol>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"java",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"nio",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"ByteBuffers",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                },
                {
                  "type":"QualifiedIdentifierNode",
                  "identifiers":[
                    {
                      "type":"IdentifierNode",
                      "name":"Unsafe",
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"IdentifierNode",
                      "name":"allocateMemory",
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "program":1,
                  "alloc":4,
                  "lazili":2,
                  "nio":1,
                  "buffer":2,
                  "empti":1,
                  "refer":1,
                  "unsaf":1,
                  "immedi":1,
                  "rss":1,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"java",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"nio",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"ByteBuffers",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Is there any way to solve this? Any way to view memory allocated with Unsafe.allocateMemory() as a byte []? Or change an existing byte [] to point to memory allocated with Unsafe?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[20596224]-[38554417]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Is there any way to solve this? Any way to view memory allocated with Unsafe.allocateMemory() as a byte []? Or change an existing byte [] to point to memory allocated with Unsafe?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"QualifiedIdentifierNode",
                  "identifiers":[
                    {
                      "type":"IdentifierNode",
                      "name":"Unsafe",
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"IdentifierNode",
                      "name":"allocateMemory",
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "solv":1,
                  "chang":1,
                  "point":1,
                  "alloc":3,
                  "exist":1,
                  "unsaf":2,
                  "view":1,
                  "memori":3
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Thank you</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[20596224]-[1624091392]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Thank you</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":20597131,
      "questionId":20596224,
      "comments":[
        
      ],
      "creationDate":"2013-12-15",
      "lastActivityDate":"2013-12-15",
      "score":0,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":57695,
        "displayName":"Peter Lawrey",
        "reputation":257803
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Java is designed to have seperate regions of memory.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[20597131]-[-146054709]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Java is designed to have seperate regions of memory.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "region":1,
                    "design":1,
                    "memori":1,
                    "seper":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<ul> \n <li>on heap like byte[] which is designed to be re-allocable and is zero'ed out and not lazy. The reason this is so is that the memory is managed.</li> \n <li>off heap which has the advantage it can be lazy but it can't pretend to be managed data types like byte[].</li> \n</ul>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[20597131]-[-1051964606]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<ul> \n <li>on heap like byte[] which is designed to be re-allocable and is zero'ed out and not lazy. The reason this is so is that the memory is managed.</li> \n <li>off heap which has the advantage it can be lazy but it can't pretend to be managed data types like byte[].</li> \n</ul>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "design":1,
                    "alloc":1,
                    "data":1,
                    "lazi":2,
                    "reason":1,
                    "advantag":1,
                    "heap":2,
                    "type":1,
                    "manag":2,
                    "pretend":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}