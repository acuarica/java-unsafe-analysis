{"type":"StackOverflowArtifact","question":{"type":"StackOverflowQuestion","id":4572329,"title":"Given a number of rectangles that can be rotated, find an enclosing rectangle of minimum area","comments":[],"tags":["java","algorithm","packing"],"creationDate":"2010-12-31","lastActivityDate":"2011-01-01","lastEditDate":"2011-01-01","score":4,"viewCount":806,"owner":{"type":"StackOverflowUser","id":384108,"displayName":"efficiencyIsBliss","reputation":910},"source":[{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>So, I'm trying to implement an algorithm that takes in a number of rectangles as input and tries to pack them into a rectangle of minimum area. The rectangles can all be rotated by 90 degrees. </p>"},"units":[{"type":"TextUnit","id":"[4572329]-[-220612771]","astNode":{"type":"TextFragmentNode","text":"<p>So, I'm trying to implement an algorithm that takes in a number of rectangles as input and tries to pack them into a rectangle of minimum area. The rectangles can all be rotated by 90 degrees. </p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"number":1,"area":1,"rectangl":3,"pack":1,"degre":1,"algorithm":1,"take":1,"implement":1,"minimum":1,"rotat":1,"input":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>I realize that this is similar to the bin packing problem, but I am unable to find a good algorithm that accounts for the rotation. I found a paper that discusses this at length <a href=\"http://www.google.com/url?sa=t&amp;source=web&amp;cd=1&amp;ved=0CB0QFjAA&amp;url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.140.200%26rep%3Drep1%26type%3Dpdf&amp;rct=j&amp;q=rectangular%20packing&amp;ei=ykYeTfSVFcGC8gbg6JzRCA&amp;usg=AFQjCNH5WRi7UA0kekBGF_K6rzWd_s-uKw&amp;sig2=D6RaOdycDUFT_OUMGyta-A&amp;cad=rja\" rel=\"nofollow\">here</a> and while I understand the article itself, I was hoping to find something simpler. </p>"},"units":[{"type":"TextUnit","id":"[4572329]-[-550872653]","astNode":{"type":"TextFragmentNode","text":"<p>I realize that this is similar to the bin packing problem, but I am unable to find a good algorithm that accounts for the rotation. I found a paper that discusses this at length <a href=\"http://www.google.com/url?sa=t&amp;source=web&amp;cd=1&amp;ved=0CB0QFjAA&amp;url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.140.200%26rep%3Drep1%26type%3Dpdf&amp;rct=j&amp;q=rectangular%20packing&amp;ei=ykYeTfSVFcGC8gbg6JzRCA&amp;usg=AFQjCNH5WRi7UA0kekBGF_K6rzWd_s-uKw&amp;sig2=D6RaOdycDUFT_OUMGyta-A&amp;cad=rja\" rel=\"nofollow\">here</a> and while I understand the article itself, I was hoping to find something simpler. </p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"psu":1,"find":2,"odyc":1,"cad":1,"fviewdoc":1,"googl":1,"rectangular":1,"url":2,"similar":1,"ist":1,"good":1,"problem":1,"dpdf":1,"cnh":1,"understand":1,"rel":1,"pack":2,"duft":1,"usg":1,"qfj":1,"articl":1,"sig":1,"amp":10,"web":1,"bgf":1,"found":1,"discuss":1,"rct":1,"ved":1,"nofollow":1,"algorithm":1,"kek":1,"gbg":1,"hope":1,"wri":1,"drep":1,"paper":1,"oumgyta":1,"fciteseerx":1,"fdoi":1,"length":1,"bin":1,"account":1,"rca":1,"svfc":1,"type":1,"href":1,"fdownload":1,"rep":1,"rotat":1,"unabl":1,"http":2,"rja":1,"sourc":1,"simpler":1,"realiz":1,"www":1,"afqj":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Positive"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>Any suggestions? </p>"},"units":[{"type":"TextUnit","id":"[4572329]-[1301229907]","astNode":{"type":"TextFragmentNode","text":"<p>Any suggestions? </p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"suggest":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Neutral"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>-Edit-</p>"},"units":[{"type":"TextUnit","id":"[4572329]-[1243093825]","astNode":{"type":"TextFragmentNode","text":"<p>-Edit-</p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"edit":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Neutral"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>I think I misstated the problem earlier. We are given a number of rectangles, such that each can be rotated by 90 degrees. We need to find a rectangle that fits all the given rectangles such that no two rectangles overlap, while minimizing the area of the enclosing rectangle.</p>"},"units":[{"type":"TextUnit","id":"[4572329]-[819813240]","astNode":{"type":"TextFragmentNode","text":"<p>I think I misstated the problem earlier. We are given a number of rectangles, such that each can be rotated by 90 degrees. We need to find a rectangle that fits all the given rectangles such that no two rectangles overlap, while minimizing the area of the enclosing rectangle.</p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"number":1,"find":1,"area":1,"minim":1,"problem":1,"fit":1,"rectangl":5,"misstat":1,"earlier":1,"degre":1,"overlap":1,"enclos":1,"rotat":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>The problem I face here is that we are asked to find the minimum, as opposed to being given an enclosing rectangle and checking if the given rectangles fit or something of that sort. </p>"},"units":[{"type":"TextUnit","id":"[4572329]-[57843920]","astNode":{"type":"TextFragmentNode","text":"<p>The problem I face here is that we are asked to find the minimum, as opposed to being given an enclosing rectangle and checking if the given rectangles fit or something of that sort. </p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"find":1,"problem":1,"fit":1,"rectangl":2,"face":1,"check":1,"oppos":1,"enclos":1,"ask":1,"minimum":1,"sort":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]}]},"answers":[{"type":"StackOverflowAnswer","id":4572506,"questionId":4572329,"comments":[],"creationDate":"2010-12-31","lastActivityDate":"2011-01-01","lastEditDate":"2011-01-01","score":1,"isAccepted":false,"owner":{"type":"StackOverflowUser","id":333127,"displayName":"cbranch","reputation":2656},"source":[{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>I've had good results using this algorithm:</p>"},"units":[{"type":"TextUnit","id":"[4572506]-[-1326401725]","astNode":{"type":"TextFragmentNode","text":"<p>I've had good results using this algorithm:</p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"algorithm":1,"result":1,"good":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p><a href=\"http://www.intechopen.com/articles/show/title/a_greedy_algorithm_with_forward-looking_strategy\" rel=\"nofollow\">http://www.intechopen.com/articles/show/title/a_greedy_algorithm_with_forward-looking_strategy</a></p>"},"units":[{"type":"TextUnit","id":"[4572506]-[-297066818]","astNode":{"type":"TextFragmentNode","text":"<p><a href=\"http://www.intechopen.com/articles/show/title/a_greedy_algorithm_with_forward-looking_strategy\" rel=\"nofollow\">http://www.intechopen.com/articles/show/title/a_greedy_algorithm_with_forward-looking_strategy</a></p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[{"type":"QualifiedIdentifierNode","identifiers":[{"type":"IdentifierNode","name":"a_greedy_algorithm_with_forward","comments":[]}],"comments":[]},{"type":"QualifiedIdentifierNode","identifiers":[{"type":"IdentifierNode","name":"looking_strategy","comments":[]}],"comments":[]}]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"show":2,"rel":1,"forward":2,"greedi":2,"titl":2,"strategi":2,"articl":2,"nofollow":1,"algorithm":2,"intechopen":2,"href":1,"http":2,"www":2}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[{"type":"IdentifierNode","name":"a_greedy_algorithm_with_forward","comments":[]},{"type":"IdentifierNode","name":"looking_strategy","comments":[]}]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p><b>Edit:</b></p>"},"units":[{"type":"TextUnit","id":"[4572506]-[333592530]","astNode":{"type":"TextFragmentNode","text":"<p><b>Edit:</b></p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"edit":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>The algorithm described in the link I supplied will give you a \"Yes\" or \"No\" answer as to whether a given set of rectangles can be packed into a specific enclosing rectangle.  To find the minimum enclosing rectangle, you can run the algorithm repeatedly.  Basically, calculate a lower bound and upper bound for the enclosing rectangle, then do a binary search to find the minimum solution that falls within those bounds.  I'm assuming that the enclosing rectangle is a fixed size in one dimension (i.e., width is constant, looking for minimum length or vice versa).  If both the width and length of the enclosing rectangle are allowed to vary, then it's more difficult and this may not work.</p>"},"units":[{"type":"TextUnit","id":"[4572506]-[-1948185233]","astNode":{"type":"TextFragmentNode","text":"<p>The algorithm described in the link I supplied will give you a \"Yes\" or \"No\" answer as to whether a given set of rectangles can be packed into a specific enclosing rectangle.  To find the minimum enclosing rectangle, you can run the algorithm repeatedly.  Basically, calculate a lower bound and upper bound for the enclosing rectangle, then do a binary search to find the minimum solution that falls within those bounds.  I'm assuming that the enclosing rectangle is a fixed size in one dimension (i.e., width is constant, looking for minimum length or vice versa).  If both the width and length of the enclosing rectangle are allowed to vary, then it's more difficult and this may not work.</p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"constant":1,"find":2,"assum":1,"size":1,"rectangl":6,"run":1,"set":1,"binari":1,"fix":1,"pack":1,"lower":1,"calcul":1,"vice":1,"upper":1,"work":1,"fall":1,"bound":3,"difficult":1,"algorithm":2,"allow":1,"versa":1,"vari":1,"dimens":1,"enclos":5,"link":1,"specif":1,"give":1,"answer":1,"length":2,"repeat":1,"minimum":3,"basic":1,"suppli":1,"width":2,"solut":1,"search":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>A simple (but naive) approach to calculating a lower bound and upper bound would be as follows:</p>"},"units":[{"type":"TextUnit","id":"[4572506]-[-2138119326]","astNode":{"type":"TextFragmentNode","text":"<p>A simple (but naive) approach to calculating a lower bound and upper bound would be as follows:</p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"naiv":1,"simpl":1,"lower":1,"calcul":1,"upper":1,"bound":2,"approach":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>Lower Bound - The best case is that all rectangles can be packed perfectly without any wasted space.  So, sum the area of all input rectangles and calculate the enclosing rectangle length required for that area.</p>"},"units":[{"type":"TextUnit","id":"[4572506]-[-120942429]","astNode":{"type":"TextFragmentNode","text":"<p>Lower Bound - The best case is that all rectangles can be packed perfectly without any wasted space.  So, sum the area of all input rectangles and calculate the enclosing rectangle length required for that area.</p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"area":2,"wast":1,"requir":1,"rectangl":3,"pack":1,"perfect":1,"lower":1,"calcul":1,"bound":1,"space":1,"enclos":1,"length":1,"input":1,"sum":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Neutral"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>Upper Bounds - The worst case is that each rectangle must be packed on a separate \"row\", so for each input rectangle, calculate <code>min(width, height)</code> and sum those (i.e., pretend input rectangles are stacked upon one another using the minimum width or height of each input such that the other dimension of the input does not exceed the width of the enclosing rectangle).</p>"},"units":[{"type":"TextUnit","id":"[4572506]-[-319651919]","astNode":{"type":"TextFragmentNode","text":"<p>Upper Bounds - The worst case is that each rectangle must be packed on a separate \"row\", so for each input rectangle, calculate <code>min(width, height)</code> and sum those (i.e., pretend input rectangles are stacked upon one another using the minimum width or height of each input such that the other dimension of the input does not exceed the width of the enclosing rectangle).</p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[{"type":"MethodInvocationNode","identifier":{"type":"IdentifierNode","name":"min","comments":[]},"args":{"type":"ExpressionListNode","arguments":[{"type":"QualifiedIdentifierNode","identifiers":[{"type":"IdentifierNode","name":"width","comments":[]}],"comments":[]},{"type":"QualifiedIdentifierNode","identifiers":[{"type":"IdentifierNode","name":"height","comments":[]}],"comments":[]}],"comments":[]},"comments":[]}]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"worst":1,"exceed":1,"rectangl":4,"separ":1,"pack":1,"height":2,"min":1,"calcul":1,"row":1,"upper":1,"code":2,"bound":1,"dimens":1,"enclos":1,"stack":1,"minimum":1,"width":3,"pretend":1,"input":4,"sum":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[{"type":"MethodInvocationNode","identifier":{"type":"IdentifierNode","name":"min","comments":[]},"args":{"type":"ExpressionListNode","arguments":[{"type":"QualifiedIdentifierNode","identifiers":[{"type":"IdentifierNode","name":"width","comments":[]}],"comments":[]},{"type":"QualifiedIdentifierNode","identifiers":[{"type":"IdentifierNode","name":"height","comments":[]}],"comments":[]}],"comments":[]},"comments":[]}]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[{"type":"IdentifierNode","name":"min","comments":[]},{"type":"IdentifierNode","name":"width","comments":[]},{"type":"IdentifierNode","name":"height","comments":[]}]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]},{"type":"SourceInfo","node":{"type":"XmlTextNode","contents":"<p>If you work a little harder, you can improve the lower and upper bounds significantly to cut down on the search space, but this should give you starting point.</p>"},"units":[{"type":"TextUnit","id":"[4572506]-[1448450005]","astNode":{"type":"TextFragmentNode","text":"<p>If you work a little harder, you can improve the lower and upper bounds significantly to cut down on the search space, but this should give you starting point.</p>"},"codeFragments":{"type":"CodeFragmentSequence","fragments":[]},"metaInformation":[{"type":"NaturalLanguageMetaInformation","tfMap":{"point":1,"cut":1,"lower":1,"upper":1,"work":1,"improv":1,"bound":1,"space":1,"signific":1,"give":1,"start":1,"harder":1,"search":1}},{"type":"CodeTypesMetaInformation","qualifiedTypes":[],"simpleTypes":[],"basicTypes":[]},{"type":"CodeInvocationMetaInformation","invocations":[]},{"type":"CodeVariablesMetaInformation","variables":[]},{"identifiers":[]},{"declarators":[]},{"averageLevel":"Negative"},{"fleshReadingEaseScore":121.2,"fleshKincaidGradeLevel":-3.4,"automatedReadingIndex":-16.1,"gunningFogIndex":0.4,"smogIndex":3.0,"colemanLiauIndex":-39.8}]}]}]}]}