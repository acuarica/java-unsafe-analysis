{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":19744508,
    "title":"Volatile Vs Atomic",
    "comments":[
      {
        "type":"StackOverflowComment",
        "id":29338380,
        "postId":19744508,
        "creationDate":"2013-11-02",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1217811,
          "displayName":"Vaibhav",
          "reputation":186
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"What is the difference between AtomicInteger and volatile int ?"
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[19744508-cu29338380]-[1411605298]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"What is the difference between AtomicInteger and volatile int ?"
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicInteger",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "atom":1,
                      "differ":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"AtomicInteger",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "tags":[
      "java",
      "volatile"
    ],
    "creationDate":"2013-11-02",
    "lastActivityDate":"2013-11-02",
    "lastEditDate":"2013-11-02",
    "closedDate":"2013-11-02",
    "score":12,
    "viewCount":8747,
    "owner":{
      "type":"StackOverflowUser",
      "id":1217811,
      "displayName":"Vaibhav",
      "reputation":186
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I read somewhere below line.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[19744508]-[-29862122]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I read somewhere below line.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "line":1,
                  "read":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<blockquote> \n <p>Java volatile keyword doesn't means atomic, its common misconception that after declaring volatile, ++ operation will be atomic, to make the operation atomic you still need to ensure exclusive access using synchronized method or block in Java.</p> \n</blockquote>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[19744508]-[1336785655]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<blockquote> \n <p>Java volatile keyword doesn't means atomic, its common misconception that after declaring volatile, ++ operation will be atomic, to make the operation atomic you still need to ensure exclusive access using synchronized method or block in Java.</p> \n</blockquote>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "method":1,
                  "exclus":1,
                  "misconcept":1,
                  "mean":1,
                  "keyword":1,
                  "blockquot":2,
                  "declar":1,
                  "oper":2,
                  "block":1,
                  "common":1,
                  "make":1,
                  "atom":3,
                  "access":1,
                  "ensur":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>So what will happen if two threads attack a volatile primitive variable at same time? </p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[19744508]-[389675038]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>So what will happen if two threads attack a volatile primitive variable at same time? </p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "happen":1,
                  "thread":1,
                  "attack":1,
                  "time":1,
                  "variabl":1,
                  "primit":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Does this mean that whosoever takes lock on it, that will be setting its value first. And in if meantime, some other thread comes up and read old value while first thread was changing its value, then doesn't new thread will read its old value?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[19744508]-[329408806]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Does this mean that whosoever takes lock on it, that will be setting its value first. And in if meantime, some other thread comes up and read old value while first thread was changing its value, then doesn't new thread will read its old value?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "read":2,
                  "chang":1,
                  "meantim":1,
                  "set":1,
                  "lock":1,
                  "thread":3,
                  "take":1,
                  "whosoev":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>What is the difference between Atomic and volatile keyword?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[19744508]-[1705131461]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>What is the difference between Atomic and volatile keyword?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "atom":1,
                  "keyword":1,
                  "differ":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":19745234,
      "questionId":19744508,
      "comments":[
        
      ],
      "creationDate":"2013-11-02",
      "lastActivityDate":"2013-11-02",
      "lastEditDate":"2013-11-02",
      "score":0,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":540286,
        "displayName":"Ortwin Angermeier",
        "reputation":2680
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The <code>volatile</code> keyword is used:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[-1795473141]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The <code>volatile</code> keyword is used:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "keyword":1,
                    "code":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<ul> \n <li>to make non atomic 64-bit operations atomic: <code>long</code> and <code>double</code>. (all other, primitive accesses are already guaranteed to be atomic!)</li> \n <li>to make variable updates guaranteed to be seen by other threads + visibility effects: after writing to a volatile variable, all the variables that where visible before writing that variable become visible to another thread after reading the same volatile variable (happen-before ordering).</li> \n</ul>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[-1651642083]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<ul> \n <li>to make non atomic 64-bit operations atomic: <code>long</code> and <code>double</code>. (all other, primitive accesses are already guaranteed to be atomic!)</li> \n <li>to make variable updates guaranteed to be seen by other threads + visibility effects: after writing to a volatile variable, all the variables that where visible before writing that variable become visible to another thread after reading the same volatile variable (happen-before ordering).</li> \n</ul>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "bit":1,
                    "happen":1,
                    "effect":1,
                    "updat":1,
                    "visibl":3,
                    "code":4,
                    "oper":1,
                    "guarante":2,
                    "thread":2,
                    "order":1,
                    "make":2,
                    "atom":3,
                    "variabl":5,
                    "primit":1,
                    "write":2,
                    "access":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The <code>java.util.concurrent.atomic.*</code> classes are, according to the <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html\"rel=\"nofollow\">java docs</a>:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[-1727674300]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The <code>java.util.concurrent.atomic.*</code> classes are, according to the <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html\"rel=\"nofollow\">java docs</a>:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "concurr":2,
                    "util":2,
                    "summari":1,
                    "rel":1,
                    "oracl":1,
                    "doc":3,
                    "code":2,
                    "nofollow":1,
                    "javas":1,
                    "class":1,
                    "atom":2,
                    "api":1,
                    "html":1,
                    "href":1,
                    "http":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>A small toolkit of classes that support lock-free thread-safe programming on single variables. In essence, the classes in this package extend the notion of volatile values, fields, and array elements to those that also provide an atomic conditional update operation of the form: </p> \n <p><code>boolean compareAndSet(expectedValue, updateValue);</code></p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[-1285733810]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>A small toolkit of classes that support lock-free thread-safe programming on single variables. In essence, the classes in this package extend the notion of volatile values, fields, and array elements to those that also provide an atomic conditional update operation of the form: </p> \n <p><code>boolean compareAndSet(expectedValue, updateValue);</code></p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"MethodInvocationNode",
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"compareAndSet",
                      "comments":[
                        
                      ]
                    },
                    "args":{
                      "type":"ExpressionListNode",
                      "arguments":[
                        {
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"expectedValue",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"updateValue",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "program":1,
                    "support":1,
                    "provid":1,
                    "singl":1,
                    "notion":1,
                    "field":1,
                    "condit":1,
                    "set":1,
                    "updat":2,
                    "lock":1,
                    "safe":1,
                    "extend":1,
                    "blockquot":2,
                    "element":1,
                    "code":2,
                    "oper":1,
                    "small":1,
                    "essenc":1,
                    "array":1,
                    "thread":1,
                    "compar":1,
                    "expect":1,
                    "valu":1,
                    "class":2,
                    "atom":1,
                    "form":1,
                    "variabl":1,
                    "toolkit":1,
                    "free":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    {
                      "type":"MethodInvocationNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"compareAndSet",
                        "comments":[
                          
                        ]
                      },
                      "args":{
                        "type":"ExpressionListNode",
                        "arguments":[
                          {
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"expectedValue",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"updateValue",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The atomic classes are built around the atomic <code>compareAndSet(...)</code> function that maps to an atmoic CPU instruction. The atomic classes introduce the <em>happen-before</em> ordering as the <code>volatile</code> variables do. (with one exception: <code>weakCompareAndSet(...)</code>).</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[1226427838]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The atomic classes are built around the atomic <code>compareAndSet(...)</code> function that maps to an atmoic CPU instruction. The atomic classes introduce the <em>happen-before</em> ordering as the <code>volatile</code> variables do. (with one exception: <code>weakCompareAndSet(...)</code>).</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"compareAndSet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"weakCompareAndSet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "built":1,
                    "map":1,
                    "happen":1,
                    "weak":1,
                    "set":2,
                    "introduc":1,
                    "atmoic":1,
                    "code":6,
                    "compar":2,
                    "order":1,
                    "function":1,
                    "cpu":1,
                    "class":2,
                    "atom":3,
                    "variabl":1,
                    "instruct":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>From the java docs:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[-246374595]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>From the java docs:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "doc":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>When a thread sees an update to an atomic variable caused by a weakCompareAndSet, it does not necessarily see updates to any other variables that occurred before the weakCompareAndSet.</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[-637126871]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>When a thread sees an update to an atomic variable caused by a weakCompareAndSet, it does not necessarily see updates to any other variables that occurred before the weakCompareAndSet.</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"weakCompareAndSet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"weakCompareAndSet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "occur":1,
                    "weak":2,
                    "set":2,
                    "updat":2,
                    "blockquot":2,
                    "thread":1,
                    "compar":2,
                    "caus":1,
                    "necessarili":1,
                    "atom":1,
                    "variabl":2,
                    "see":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>To your question:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[1531125571]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>To your question:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "question":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>Does this mean that whosoever takes lock on it, that will be setting its value first. And in if meantime, some other thread comes up and read old value while first thread was changing its value, then doesn't new thread will read its old value?</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[193163849]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>Does this mean that whosoever takes lock on it, that will be setting its value first. And in if meantime, some other thread comes up and read old value while first thread was changing its value, then doesn't new thread will read its old value?</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":2,
                    "chang":1,
                    "meantim":1,
                    "set":1,
                    "lock":1,
                    "blockquot":2,
                    "thread":3,
                    "take":1,
                    "whosoev":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>You don't lock anything, what you are describing is a typical race condition that will happen eventually if threads access shared data without proper synchronization. As already mentioned declaring a variable <code>volatile</code> in this case will only ensure that other threads will see the change of the variable (the value will not be cached in a register of some cache that is only seen by one thread).</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[-1507003929]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>You don't lock anything, what you are describing is a typical race condition that will happen eventually if threads access shared data without proper synchronization. As already mentioned declaring a variable <code>volatile</code> in this case will only ensure that other threads will see the change of the variable (the value will not be cached in a register of some cache that is only seen by one thread).</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "chang":1,
                    "cach":2,
                    "proper":1,
                    "happen":1,
                    "condit":1,
                    "data":1,
                    "regist":1,
                    "lock":1,
                    "eventu":1,
                    "declar":1,
                    "code":2,
                    "share":1,
                    "thread":3,
                    "mention":1,
                    "typic":1,
                    "race":1,
                    "variabl":2,
                    "describ":1,
                    "access":1,
                    "ensur":1,
                    "synchron":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>What is the difference between <code>AtomicInteger</code> and <code>volatile int</code>?</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[-972066414]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>What is the difference between <code>AtomicInteger</code> and <code>volatile int</code>?</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "blockquot":2,
                    "atom":1,
                    "code":4,
                    "differ":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicInteger",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><code>AtomicInteger</code> provides atomic operations on an <code>int</code> with proper synchronization (eg. <code>incrementAndGet()</code>, <code>getAndAdd(...)</code>, ...), <code>volatile int</code> will just ensure the visibility of the <code>int</code> to other threads.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745234]-[535246996]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><code>AtomicInteger</code> provides atomic operations on an <code>int</code> with proper synchronization (eg. <code>incrementAndGet()</code>, <code>getAndAdd(...)</code>, ...), <code>volatile int</code> will just ensure the visibility of the <code>int</code> to other threads.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"incrementAndGet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"getAndAdd",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "proper":1,
                    "visibl":1,
                    "code":12,
                    "oper":1,
                    "thread":1,
                    "atom":2,
                    "add":1,
                    "increment":1,
                    "ensur":1,
                    "synchron":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicInteger",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":19745028,
      "questionId":19744508,
      "comments":[
        
      ],
      "creationDate":"2013-11-02",
      "lastActivityDate":"2013-11-02",
      "lastEditDate":"2013-11-02",
      "score":1,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":2015912,
        "displayName":"scottb",
        "reputation":2038
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>As Trying as indicated, <code>volatile</code> deals only with visibility.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745028]-[499962117]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>As Trying as indicated, <code>volatile</code> deals only with visibility.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "visibl":1,
                    "deal":1,
                    "code":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Consider this snippet in a concurrent environment:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745028]-[534774591]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Consider this snippet in a concurrent environment:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "concurr":1,
                    "snippet":1,
                    "environ":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"boolean isStopped = false; : : while (!isStopped) { // do some kind of work } "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[19745028]-[-1515632592]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"boolean "
                  },
                  {
                    "type":"ExpressionStatement",
                    "expression":{
                      "type":"BinaryExpressionNode",
                      "operator":{
                        "type":"OperatorNode",
                        "symbol":"=",
                        "comments":[
                          
                        ]
                      },
                      "left":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"isStopped",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "right":{
                        "type":"LiteralNode",
                        "node":{
                          "type":"BooleanLiteralNode",
                          "valueRep":"false"
                        },
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ]
                  },
                  {
                    "type":"TextFragmentNode",
                    "text":": : "
                  },
                  {
                    "type":"WhileStatementNode",
                    "expression":{
                      "type":"PrefixOperatorExpressionNode",
                      "operator":{
                        "type":"OperatorNode",
                        "symbol":"!",
                        "comments":[
                          
                        ]
                      },
                      "argument":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"isStopped",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    "statement":{
                      "type":"BlockNode",
                      "statements":[
                        
                      ],
                      "labels":[
                        
                      ],
                      "comments":[
                        {
                          "text":"// do some kind of work } \n"
                        }
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "rawText":"boolean isStopped = false; : : while (!isStopped) { // do some kind of work } \n...\n}",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "stop":2,
                    "fals":1,
                    "kind":1,
                    "work":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The idea here is that some thread could change the value of <code>isStopped</code> from false to true in order to indicate to the subsequent loop that it is time to stop looping.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745028]-[792204400]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The idea here is that some thread could change the value of <code>isStopped</code> from false to true in order to indicate to the subsequent loop that it is time to stop looping.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"isStopped",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "chang":1,
                    "loop":2,
                    "subsequ":1,
                    "idea":1,
                    "stop":2,
                    "code":2,
                    "thread":1,
                    "order":1,
                    "true":1,
                    "fals":1,
                    "time":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Intuitively, there is no problem. Logically if another thread makes <code>isStopped</code> equal to true, then the loop must terminate. The reality is that the loop will likely never terminate even if another thread makes <code>isStopped</code> equal to true.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745028]-[-1010735533]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Intuitively, there is no problem. Logically if another thread makes <code>isStopped</code> equal to true, then the loop must terminate. The reality is that the loop will likely never terminate even if another thread makes <code>isStopped</code> equal to true.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"isStopped",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"isStopped",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "loop":2,
                    "problem":1,
                    "realiti":1,
                    "stop":2,
                    "logic":1,
                    "code":4,
                    "thread":2,
                    "equal":2,
                    "true":2,
                    "make":2,
                    "termin":2,
                    "intuit":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The reason for this is not intuitive, but consider that modern processors have multiple cores and that each core has multiple registers and multiple levels of cache memory that <strong>are not accessible to other processors</strong>. In other words, values that are cached in one processor's local memory are <strong>not visisble</strong> to threads executing on a different processor. Herein lies one of the central problems with concurrency: visibility.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745028]-[1266729289]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The reason for this is not intuitive, but consider that modern processors have multiple cores and that each core has multiple registers and multiple levels of cache memory that <strong>are not accessible to other processors</strong>. In other words, values that are cached in one processor's local memory are <strong>not visisble</strong> to threads executing on a different processor. Herein lies one of the central problems with concurrency: visibility.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "cach":2,
                    "concurr":1,
                    "problem":1,
                    "local":1,
                    "regist":1,
                    "visibl":1,
                    "strong":4,
                    "reason":1,
                    "central":1,
                    "modern":1,
                    "thread":1,
                    "visisbl":1,
                    "processor":4,
                    "valu":1,
                    "core":2,
                    "multipl":3,
                    "word":1,
                    "lie":1,
                    "execut":1,
                    "intuit":1,
                    "access":1,
                    "level":1,
                    "memori":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The Java Memory Model makes no guarantees whatsoever about when changes that are made to a variable in on thread may become visible to other threads. In order to guarantee that updates are visisble as soon as they are made, you must synchronize.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745028]-[1077570435]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The Java Memory Model makes no guarantees whatsoever about when changes that are made to a variable in on thread may become visible to other threads. In order to guarantee that updates are visisble as soon as they are made, you must synchronize.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "model":1,
                    "updat":1,
                    "visibl":1,
                    "guarante":2,
                    "thread":2,
                    "visisbl":1,
                    "order":1,
                    "make":1,
                    "whatsoev":1,
                    "variabl":1,
                    "made":2,
                    "synchron":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The <code>volatile</code> keyword is a weak form of synchronization. While it does nothing for mutual exclusion or atomicity, it does provide a guarantee that changes made to a variable in one thread will become visible to other threads as soon as it is made. Because individual reads and writes to variables that are not 8-bytes are atomic in Java, declaring variables <code>volatile</code> provides an easy mechanism for providing visibility in situations where there are no other atomicity or mutual exclusion requirements.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745028]-[960279198]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The <code>volatile</code> keyword is a weak form of synchronization. While it does nothing for mutual exclusion or atomicity, it does provide a guarantee that changes made to a variable in one thread will become visible to other threads as soon as it is made. Because individual reads and writes to variables that are not 8-bytes are atomic in Java, declaring variables <code>volatile</code> provides an easy mechanism for providing visibility in situations where there are no other atomicity or mutual exclusion requirements.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "provid":2,
                    "exclus":2,
                    "easi":1,
                    "requir":1,
                    "weak":1,
                    "individu":1,
                    "visibl":2,
                    "keyword":1,
                    "declar":1,
                    "mutual":2,
                    "code":4,
                    "guarante":1,
                    "situat":1,
                    "thread":2,
                    "mechan":1,
                    "atom":3,
                    "form":1,
                    "variabl":3,
                    "made":2,
                    "byte":1,
                    "write":1,
                    "synchron":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":19744523,
      "questionId":19744508,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":29338489,
          "postId":19744523,
          "creationDate":"2013-11-02",
          "score":1,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2470818,
            "displayName":"Vallentin",
            "reputation":3197
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Something to add, the `int` stored in `AtomicInteger` is `private volatile int value;`"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[19744523-cu29338489]-[-690700627]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Something to add, the `int` stored in `AtomicInteger` is `private volatile int value;`"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"AtomicInteger",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "atom":1,
                        "store":1,
                        "add":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"AtomicInteger",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":29338630,
          "postId":19744523,
          "creationDate":"2013-11-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":869736,
            "displayName":"Louis Wasserman",
            "reputation":77769
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@Vallentin: Yes, but `AtomicInteger` uses some special utilities -- specifically including `Unsafe.compareAndSwapInt` -- to do more powerful concurrent operations safely."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[19744523-cu29338630]-[2038870294]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@Vallentin: Yes, but `AtomicInteger` uses some special utilities -- specifically including `Unsafe.compareAndSwapInt` -- to do more powerful concurrent operations safely."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"Vallentin",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"AtomicInteger",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"Unsafe",
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"IdentifierNode",
                            "name":"compareAndSwapInt",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "concurr":1,
                        "util":1,
                        "vallentin":1,
                        "safe":1,
                        "includ":1,
                        "oper":1,
                        "compar":1,
                        "specif":1,
                        "swap":1,
                        "atom":1,
                        "unsaf":1,
                        "power":1,
                        "special":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"AtomicInteger",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":29338991,
          "postId":19744523,
          "creationDate":"2013-11-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2470818,
            "displayName":"Vallentin",
            "reputation":3197
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"yes yes, but my point was that `volatile` was used in `AtomicInteger`."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[19744523-cu29338991]-[-553886707]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"yes yes, but my point was that `volatile` was used in `AtomicInteger`."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"AtomicInteger",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "atom":1,
                        "point":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"AtomicInteger",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":29339371,
          "postId":19744523,
          "creationDate":"2013-11-02",
          "score":1,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2798291,
            "displayName":"TwoThe",
            "reputation":5022
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"This is only half the truth, you are missing the very important order-of-execution problem. See my explanation below."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[19744523-cu29339371]-[-1488236086]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"This is only half the truth, you are missing the very important order-of-execution problem. See my explanation below."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "problem":1,
                        "half":1,
                        "miss":1,
                        "explan":1,
                        "import":1,
                        "order":1,
                        "truth":1,
                        "execut":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":29339457,
          "postId":19744523,
          "creationDate":"2013-11-02",
          "score":3,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2015912,
            "displayName":"scottb",
            "reputation":2038
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@LouisWasserman: &quot;The effect of `volatile` keyword is ... operation on that variable is atomic.&quot; I must disagree with the truth of this assertion. Individual reads and writes to variables in Java that are not 8-bytes are always atomic. The `volatile` keyword does not make accesses to variables that may not have otherwise been atomic into accesses that are. It merely forces the processing environment to immediately flush to main memory changes that are made to variables so that those changes are visible to all threads."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[19744523-cu29339457]-[1113964204]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@LouisWasserman: &quot;The effect of `volatile` keyword is ... operation on that variable is atomic.&quot; I must disagree with the truth of this assertion. Individual reads and writes to variables in Java that are not 8-bytes are always atomic. The `volatile` keyword does not make accesses to variables that may not have otherwise been atomic into accesses that are. It merely forces the processing environment to immediately flush to main memory changes that are made to variables so that those changes are visible to all threads."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"LouisWasserman",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "assert":1,
                        "read":1,
                        "process":1,
                        "effect":1,
                        "individu":1,
                        "loui":1,
                        "visibl":1,
                        "main":1,
                        "keyword":2,
                        "oper":1,
                        "thread":1,
                        "wasserman":1,
                        "make":1,
                        "flush":1,
                        "quot":2,
                        "atom":3,
                        "immedi":1,
                        "forc":1,
                        "variabl":4,
                        "truth":1,
                        "environ":1,
                        "made":1,
                        "disagre":1,
                        "byte":1,
                        "write":1,
                        "access":2,
                        "memori":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":29339857,
          "postId":19744523,
          "creationDate":"2013-11-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":540286,
            "displayName":"Ortwin Angermeier",
            "reputation":2680
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@LouisWasserman primitive read/writes are always atomic, only `long` and `double` &quot;need&quot; `volatile` to be atomic."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[19744523-cu29339857]-[1744630784]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@LouisWasserman primitive read/writes are always atomic, only `long` and `double` &quot;need&quot; `volatile` to be atomic."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"LouisWasserman",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "read":1,
                        "loui":1,
                        "wasserman":1,
                        "quot":2,
                        "atom":2,
                        "primit":1,
                        "write":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":29342111,
          "postId":19744523,
          "creationDate":"2013-11-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2015912,
            "displayName":"scottb",
            "reputation":2038
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@ortang: Just an affirmation. I checked the JLS (s17.7). You are correct that a `volatile` declaration will make reads and writes to longs and doubles (which otherwise would -not- be atomic) into atomic accesses in addition to providing for inter-thread visibility."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[19744523-cu29342111]-[-109524582]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@ortang: Just an affirmation. I checked the JLS (s17.7). You are correct that a `volatile` declaration will make reads and writes to longs and doubles (which otherwise would -not- be atomic) into atomic accesses in addition to providing for inter-thread visibility."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "read":1,
                        "jls":1,
                        "provid":1,
                        "addit":1,
                        "correct":1,
                        "inter":1,
                        "visibl":1,
                        "declar":1,
                        "affirm":1,
                        "long":1,
                        "thread":1,
                        "check":1,
                        "ortang":1,
                        "make":1,
                        "atom":2,
                        "doubl":1,
                        "write":1,
                        "access":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":39933578,
          "postId":19744523,
          "creationDate":"2014-08-29",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":462923,
            "displayName":"Ajeet",
            "reputation":1860
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"LouisWasserman Considering this is the rare instance where top voted answer is wrong/misleading, can you reword your answer after better readin volatile in Java. Agree with @OrtwinAngermeier"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[19744523-cu39933578]-[-16939132]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"LouisWasserman Considering this is the rare instance where top voted answer is wrong/misleading, can you reword your answer after better readin volatile in Java. Agree with @OrtwinAngermeier"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"LouisWasserman",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"OrtwinAngermeier",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "reword":1,
                        "wrong":1,
                        "loui":1,
                        "ortwin":1,
                        "wasserman":1,
                        "rare":1,
                        "agre":1,
                        "answer":2,
                        "mislead":1,
                        "readin":1,
                        "vote":1,
                        "top":1,
                        "angermei":1,
                        "instanc":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"LouisWasserman",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2013-11-02",
      "lastActivityDate":"2013-11-02",
      "score":13,
      "isAccepted":true,
      "owner":{
        "type":"StackOverflowUser",
        "id":869736,
        "displayName":"Louis Wasserman",
        "reputation":77769
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The effect of the <code>volatile</code> keyword is approximately that each individual read or write operation on that variable is atomic.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19744523]-[-774130411]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The effect of the <code>volatile</code> keyword is approximately that each individual read or write operation on that variable is atomic.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "effect":1,
                    "individu":1,
                    "keyword":1,
                    "code":2,
                    "oper":1,
                    "atom":1,
                    "variabl":1,
                    "write":1,
                    "approxim":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Notably, however, an operation that requires more than one read/write -- such as <code>i++</code>, which is equivalent to <code>i = i + 1</code>, which does one read and one write -- is <em>not</em> atomic, since another thread may write to <code>i</code> between the read and the write.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19744523]-[114904273]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Notably, however, an operation that requires more than one read/write -- such as <code>i++</code>, which is equivalent to <code>i = i + 1</code>, which does one read and one write -- is <em>not</em> atomic, since another thread may write to <code>i</code> between the read and the write.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":3,
                    "equival":1,
                    "requir":1,
                    "code":6,
                    "oper":1,
                    "thread":1,
                    "atom":1,
                    "notabl":1,
                    "write":4
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The <code>Atomic</code> classes, like <code>AtomicInteger</code> and <code>AtomicReference</code>, provide a wider variety of operations atomically, specifically including increment for <code>AtomicInteger</code>.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19744523]-[547613525]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The <code>Atomic</code> classes, like <code>AtomicInteger</code> and <code>AtomicReference</code>, provide a wider variety of operations atomically, specifically including increment for <code>AtomicInteger</code>.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicReference",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "provid":1,
                    "varieti":1,
                    "includ":1,
                    "code":8,
                    "oper":1,
                    "wider":1,
                    "specif":1,
                    "refer":1,
                    "class":1,
                    "atom":5,
                    "increment":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicInteger",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicReference",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":19744659,
      "questionId":19744508,
      "comments":[
        
      ],
      "creationDate":"2013-11-02",
      "lastActivityDate":"2013-11-02",
      "lastEditDate":"2013-11-02",
      "score":7,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":2109070,
        "displayName":"Trying",
        "reputation":4683
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>There are two important concepts in multithreading environment. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19744659]-[323424495]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>There are two important concepts in multithreading environment. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "import":1,
                    "multithread":1,
                    "concept":1,
                    "environ":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<ol> \n <li>atomicity</li> \n <li>visibility</li> \n</ol>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19744659]-[1511480514]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<ol> \n <li>atomicity</li> \n <li>visibility</li> \n</ol>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "atom":1,
                    "visibl":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><code>Volatile</code> eradicates visibility problem but it does not deal with atomicity. <code>Volatile</code> will prevent compiler to reorder the instruction which involves write and subsequent read of a volatile variable. e.g. <code>k++</code> Here <code>k++</code> is not a single machine instruction rather it is three machine instructions.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19744659]-[762743638]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><code>Volatile</code> eradicates visibility problem but it does not deal with atomicity. <code>Volatile</code> will prevent compiler to reorder the instruction which involves write and subsequent read of a volatile variable. e.g. <code>k++</code> Here <code>k++</code> is not a single machine instruction rather it is three machine instructions.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "singl":1,
                    "involv":1,
                    "erad":1,
                    "subsequ":1,
                    "reorder":1,
                    "problem":1,
                    "prevent":1,
                    "visibl":1,
                    "code":8,
                    "machin":2,
                    "atom":1,
                    "compil":1,
                    "variabl":1,
                    "deal":1,
                    "write":1,
                    "instruct":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<ol> \n <li>copy the value to register</li> \n <li>increment it</li> \n <li>place it back</li> \n</ol>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19744659]-[-9638834]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<ol> \n <li>copy the value to register</li> \n <li>increment it</li> \n <li>place it back</li> \n</ol>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "regist":1,
                    "back":1,
                    "place":1,
                    "increment":1,
                    "copi":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>So even though you declare variable to <code>volatile</code> it will not make this operation atomic that means another thread can see a intermediate result which is a stale or unwanted value for the other thread.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19744659]-[2128409972]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>So even though you declare variable to <code>volatile</code> it will not make this operation atomic that means another thread can see a intermediate result which is a stale or unwanted value for the other thread.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "result":1,
                    "mean":1,
                    "unwant":1,
                    "declar":1,
                    "code":2,
                    "oper":1,
                    "thread":2,
                    "make":1,
                    "atom":1,
                    "variabl":1,
                    "stale":1,
                    "intermedi":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>But <code>AtomicInteger</code>, <code>AtomicReference</code> are based on the <strong>Compare and swap instruction</strong>. CAS has three operands a memory location <code>V</code> on which to operate, the expected old value <code>A</code>, and the new value <code>B</code>. <code>CAS</code> atomically updates <code>V</code> to the new value <code>B</code>, but only if the value in <code>V</code> matches the expected old value <code>A</code>; otherwise it does nothing. In either case, it returns the value currently in <code>V</code>. This is used by JVM in <code>AtomicInteger</code>, <code>AtomicReference</code> and they call the function as <code>compareAndSet()</code> if this functionality is not supported by underlying processor then JVM implements it by <strong>spin lock</strong>.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19744659]-[-209570965]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>But <code>AtomicInteger</code>, <code>AtomicReference</code> are based on the <strong>Compare and swap instruction</strong>. CAS has three operands a memory location <code>V</code> on which to operate, the expected old value <code>A</code>, and the new value <code>B</code>. <code>CAS</code> atomically updates <code>V</code> to the new value <code>B</code>, but only if the value in <code>V</code> matches the expected old value <code>A</code>; otherwise it does nothing. In either case, it returns the value currently in <code>V</code>. This is used by JVM in <code>AtomicInteger</code>, <code>AtomicReference</code> and they call the function as <code>compareAndSet()</code> if this functionality is not supported by underlying processor then JVM implements it by <strong>spin lock</strong>.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicReference",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicReference",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"compareAndSet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jvm":2,
                    "operand":1,
                    "support":1,
                    "return":1,
                    "set":1,
                    "updat":1,
                    "spin":1,
                    "lock":1,
                    "cas":2,
                    "strong":4,
                    "match":1,
                    "base":1,
                    "code":28,
                    "oper":1,
                    "processor":1,
                    "compar":2,
                    "function":2,
                    "expect":2,
                    "refer":2,
                    "swap":1,
                    "under":1,
                    "atom":5,
                    "call":1,
                    "locat":1,
                    "instruct":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicInteger",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicReference",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":19745172,
      "questionId":19744508,
      "comments":[
        
      ],
      "creationDate":"2013-11-02",
      "lastActivityDate":"2013-11-02",
      "score":2,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":57695,
        "displayName":"Peter Lawrey",
        "reputation":257803
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>So what will happen if two threads attack a volatile primitive variable at same time?</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745172]-[-2004114677]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>So what will happen if two threads attack a volatile primitive variable at same time?</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "happen":1,
                    "blockquot":2,
                    "thread":1,
                    "attack":1,
                    "time":1,
                    "variabl":1,
                    "primit":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Usually each one can increment the value. However sometime, both will update the value at the same time and instead of incrementing by 2 total, both thread increment by 1 and only 1 is added.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745172]-[2060021380]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Usually each one can increment the value. However sometime, both will update the value at the same time and instead of incrementing by 2 total, both thread increment by 1 and only 1 is added.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "updat":1,
                    "total":1,
                    "thread":1,
                    "ad":1,
                    "time":1,
                    "increment":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>Does this mean that whosoever takes lock on it, that will be setting its value first. </p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745172]-[-197154649]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>Does this mean that whosoever takes lock on it, that will be setting its value first. </p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "set":1,
                    "lock":1,
                    "blockquot":2,
                    "take":1,
                    "whosoev":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>There is no lock. That is what <code>synchronized</code> is for.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745172]-[163032606]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>There is no lock. That is what <code>synchronized</code> is for.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "lock":1,
                    "code":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>And in if meantime, some other thread comes up and read old value while first thread was changing its value, then doesn't new thread will read its old value?</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745172]-[-1811928410]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>And in if meantime, some other thread comes up and read old value while first thread was changing its value, then doesn't new thread will read its old value?</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":2,
                    "chang":1,
                    "meantim":1,
                    "blockquot":2,
                    "thread":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Yes,</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745172]-[1899076944]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Yes,</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>What is the difference between Atomic and volatile keyword?</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745172]-[-1805209910]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>What is the difference between Atomic and volatile keyword?</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "blockquot":2,
                    "atom":1,
                    "keyword":1,
                    "differ":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>AtomicXxxx wraps a volatile so they are basically same, the difference is that it provides higher level operations such as CompareAndSwap which is used to implement increment.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745172]-[1429359276]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>AtomicXxxx wraps a volatile so they are basically same, the difference is that it provides higher level operations such as CompareAndSwap which is used to implement increment.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicXxxx",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"CompareAndSwap",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "higher":1,
                    "differ":1,
                    "oper":1,
                    "wrap":1,
                    "compar":1,
                    "xxxx":1,
                    "implement":1,
                    "swap":1,
                    "atom":1,
                    "basic":1,
                    "increment":1,
                    "level":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicXxxx",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"CompareAndSwap",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>AtomicXxxx also supports lazySet. This is like a volatile set, but doesn't stall the pipeline waiting for the write to complete. It can mean that if you read a value you just write you might see the old value, but you shouldn't be doing that anyway. The difference is that setting a volatile takes about 5 ns, bit lazySet takes about 0.5 ns.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745172]-[325500315]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>AtomicXxxx also supports lazySet. This is like a volatile set, but doesn't stall the pipeline waiting for the write to complete. It can mean that if you read a value you just write you might see the old value, but you shouldn't be doing that anyway. The difference is that setting a volatile takes about 5 ns, bit lazySet takes about 0.5 ns.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicXxxx",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"lazySet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"lazySet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "support":1,
                    "wait":1,
                    "bit":1,
                    "differ":1,
                    "set":4,
                    "lazi":2,
                    "pipelin":1,
                    "stall":1,
                    "take":2,
                    "xxxx":1,
                    "atom":1,
                    "complet":1,
                    "shouldn":1,
                    "write":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicXxxx",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":19745207,
      "questionId":19744508,
      "comments":[
        
      ],
      "creationDate":"2013-11-02",
      "lastActivityDate":"2013-11-02",
      "score":10,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":2798291,
        "displayName":"TwoThe",
        "reputation":5022
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Volatile and Atomic are two different concepts. Volatile ensures, that a certain, expected (memory) state is true across different threads, while Atomics ensure that operation on variables are performed atomically.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[-1995852706]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Volatile and Atomic are two different concepts. Volatile ensures, that a certain, expected (memory) state is true across different threads, while Atomics ensure that operation on variables are performed atomically.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "state":1,
                    "oper":1,
                    "thread":1,
                    "expect":1,
                    "perform":1,
                    "true":1,
                    "concept":1,
                    "atom":3,
                    "variabl":1,
                    "ensur":2,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Take the following example of two threads in Java:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[1940740911]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Take the following example of two threads in Java:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "thread":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Thread A:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[-993840122]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Thread A:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "thread":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"value = 1; done = true; "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[19745207]-[2031118992]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ExpressionStatement",
                    "expression":{
                      "type":"BinaryExpressionNode",
                      "operator":{
                        "type":"OperatorNode",
                        "symbol":"=",
                        "comments":[
                          
                        ]
                      },
                      "left":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"value",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "right":{
                        "type":"LiteralNode",
                        "node":{
                          "type":"IntegerLiteralNode",
                          "valueRep":"1"
                        },
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ]
                  },
                  {
                    "type":"ExpressionStatement",
                    "expression":{
                      "type":"BinaryExpressionNode",
                      "operator":{
                        "type":"OperatorNode",
                        "symbol":"=",
                        "comments":[
                          
                        ]
                      },
                      "left":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"done",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "right":{
                        "type":"LiteralNode",
                        "node":{
                          "type":"BooleanLiteralNode",
                          "valueRep":"true"
                        },
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ]
                  }
                ]
              },
              "rawText":"value = 1; done = true; ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "true":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Thread B:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[-965210971]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Thread B:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "thread":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"if (done) System.out.println(value); "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[19745207]-[-1151318505]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"IfStatementNode",
                    "expression":{
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"done",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "statement":{
                      "type":"ExpressionStatement",
                      "expression":{
                        "type":"MethodInvocationNode",
                        "qualifiedIdentifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"System",
                              "comments":[
                                
                              ]
                            },
                            {
                              "type":"IdentifierNode",
                              "name":"out",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"println",
                          "comments":[
                            
                          ]
                        },
                        "args":{
                          "type":"ExpressionListNode",
                          "arguments":[
                            {
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"value",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      "labels":[
                        
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "rawText":"if (done) System.out.println(value); ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "println":1,
                    "system":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    {
                      "type":"MethodInvocationNode",
                      "qualifiedIdentifier":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"System",
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"IdentifierNode",
                            "name":"out",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"println",
                        "comments":[
                          
                        ]
                      },
                      "args":{
                        "type":"ExpressionListNode",
                        "arguments":[
                          {
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"value",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Starting with <code>value = 0</code> and <code>done = false</code> the rule of threading tells us, that it is undefined whether or not Thread B will print value. <strong>Furthermore <em>value</em> is undefined at that point as well!</strong> To explain this you need to know a bit about Java memory management (which can be complex), in short: Threads may create local copies of variables, and the JVM can reorder code to optimize it, therefore there is no guarantee that the above code is run in exactly that order. Setting done to true and <strong>then</strong> setting value to 1 would be a possible outcome of the JIT.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[-644495550]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Starting with <code>value = 0</code> and <code>done = false</code> the rule of threading tells us, that it is undefined whether or not Thread B will print value. <strong>Furthermore <em>value</em> is undefined at that point as well!</strong> To explain this you need to know a bit about Java memory management (which can be complex), in short: Threads may create local copies of variables, and the JVM can reorder code to optimize it, therefore there is no guarantee that the above code is run in exactly that order. Setting done to true and <strong>then</strong> setting value to 1 would be a possible outcome of the JIT.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jit":1,
                    "jvm":1,
                    "point":1,
                    "bit":1,
                    "explain":1,
                    "reorder":1,
                    "print":1,
                    "run":1,
                    "set":2,
                    "local":1,
                    "rule":1,
                    "strong":4,
                    "code":6,
                    "guarante":1,
                    "optim":1,
                    "thread":3,
                    "order":1,
                    "undefin":2,
                    "true":1,
                    "fals":1,
                    "variabl":1,
                    "manag":1,
                    "start":1,
                    "creat":1,
                    "tell":1,
                    "copi":1,
                    "outcom":1,
                    "complex":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><code>volatile</code> only ensures, that at the moment of access of such a variable, the new value will be immediately visible to all other threads <strong>and</strong> the order of execution ensures, that the code is at the state you would expect it to be. So in case of the code above, defining <code>done</code> as <em>volatile</em> will ensure that whenever Thread B checks the variable, it is either false, or true, and if it is true, then <code>value</code> has been set to 1 as well.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[2120794705]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><code>volatile</code> only ensures, that at the moment of access of such a variable, the new value will be immediately visible to all other threads <strong>and</strong> the order of execution ensures, that the code is at the state you would expect it to be. So in case of the code above, defining <code>done</code> as <em>volatile</em> will ensure that whenever Thread B checks the variable, it is either false, or true, and if it is true, then <code>value</code> has been set to 1 as well.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "state":1,
                    "set":1,
                    "visibl":1,
                    "strong":2,
                    "code":8,
                    "thread":2,
                    "check":1,
                    "order":1,
                    "expect":1,
                    "moment":1,
                    "true":2,
                    "fals":1,
                    "immedi":1,
                    "defin":1,
                    "variabl":2,
                    "execut":1,
                    "access":1,
                    "ensur":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>As a side-effect of <em>volatile</em>, the value of such a variable is set thread-wide atomically (at a very minor cost of execution speed). This is however only important on 32-bit systems that i.E. use long (64-bit) variables (or similar), in most other cases setting/reading a variable is atomic anyways. But there is an important difference between an atomic access and an atomic operation. Volatile only ensures that the access is atomically, while Atomics ensure that the <em>operation</em> is atomically.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[1347053612]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>As a side-effect of <em>volatile</em>, the value of such a variable is set thread-wide atomically (at a very minor cost of execution speed). This is however only important on 32-bit systems that i.E. use long (64-bit) variables (or similar), in most other cases setting/reading a variable is atomic anyways. But there is an important difference between an atomic access and an atomic operation. Volatile only ensures that the access is atomically, while Atomics ensure that the <em>operation</em> is atomically.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "side":1,
                    "read":1,
                    "bit":2,
                    "system":1,
                    "similar":1,
                    "differ":1,
                    "effect":1,
                    "set":2,
                    "oper":2,
                    "thread":1,
                    "import":2,
                    "cost":1,
                    "atom":7,
                    "case":1,
                    "wide":1,
                    "variabl":3,
                    "execut":1,
                    "speed":1,
                    "minor":1,
                    "access":2,
                    "ensur":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Take the following example:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[964251934]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Take the following example:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"i = i + 1; "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[19745207]-[-689560720]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ExpressionStatement",
                    "expression":{
                      "type":"BinaryExpressionNode",
                      "operator":{
                        "type":"OperatorNode",
                        "symbol":"=",
                        "comments":[
                          
                        ]
                      },
                      "left":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"i",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "right":{
                        "type":"BinaryExpressionNode",
                        "operator":{
                          "type":"OperatorNode",
                          "symbol":"+",
                          "comments":[
                            
                          ]
                        },
                        "left":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"i",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "right":{
                          "type":"LiteralNode",
                          "node":{
                            "type":"IntegerLiteralNode",
                            "valueRep":"1"
                          },
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ]
                  }
                ]
              },
              "rawText":"i = i + 1; ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>No matter how you define i, a different Thread reading the value just when the above line is executed might get i, or i + 1, because the <em>operation</em> is not atomically. If the other thread sets i to a different value, in worst case i could be set back to whatever it was before by thread A, because it was just in the middle of calculating i + 1 based on the old value, and then set i again to that old value + 1. Explanation:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[2129996377]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>No matter how you define i, a different Thread reading the value just when the above line is executed might get i, or i + 1, because the <em>operation</em> is not atomically. If the other thread sets i to a different value, in worst case i could be set back to whatever it was before by thread A, because it was just in the middle of calculating i + 1 based on the old value, and then set i again to that old value + 1. Explanation:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "middl":1,
                    "worst":1,
                    "line":1,
                    "set":3,
                    "calcul":1,
                    "base":1,
                    "oper":1,
                    "thread":3,
                    "explan":1,
                    "back":1,
                    "atom":1,
                    "matter":1,
                    "defin":1,
                    "execut":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"Assume i = 0 Thread A reads i, calculates i+1, which is 1 Thread B sets i to 1000 and returns Thread A now sets i to the result of the operation, which is i = 1 "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[19745207]-[2083044256]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"Assume i = 0 Thread A reads i, calculates i+1, which is 1 Thread B sets i to 1000 and returns Thread A now sets i to the result of the operation, which is i = 1 "
                  }
                ]
              },
              "rawText":"Assume i = 0 Thread A reads i, calculates i+1, which is 1 Thread B sets i to 1000 and returns Thread A now sets i to the result of the operation, which is i = 1 ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "assum":1,
                    "return":1,
                    "result":1,
                    "set":2,
                    "calcul":1,
                    "oper":1,
                    "thread":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Atomics like AtomicInteger ensure, that such operations happen atomically. So the above issue cannot happen, i would either be 1000 or 1001 once both threads are finished.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[19745207]-[-1724266123]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Atomics like AtomicInteger ensure, that such operations happen atomically. So the above issue cannot happen, i would either be 1000 or 1001 once both threads are finished.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "happen":2,
                    "issu":1,
                    "finish":1,
                    "oper":1,
                    "thread":1,
                    "atom":3,
                    "ensur":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicInteger",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}