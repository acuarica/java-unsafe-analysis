{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":11609584,
    "title":"Is there a way to find what memory addresses were accessed by a Java program and in what order?",
    "comments":[
      {
        "type":"StackOverflowComment",
        "id":15369951,
        "postId":11609584,
        "creationDate":"2012-07-23",
        "score":2,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":57695,
          "displayName":"Peter Lawrey",
          "reputation":257803
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"Why do you want to do this? How would you use this information? The reason I ask is that it appears to be likely what you are trying to do should be done another way."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[11609584-cu15369951]-[-1497583952]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"Why do you want to do this? How would you use this information? The reason I ask is that it appears to be likely what you are trying to do should be done another way."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "inform":1,
                      "appear":1,
                      "reason":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":15380703,
        "postId":11609584,
        "creationDate":"2012-07-23",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":752920,
          "displayName":"Ankit",
          "reputation":1556
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"If I get this memory trace for some benchmarks then, I can use it for a couple of purposes such as finding the generate usage pattern for the physical memory by Java programs, the cache usage and so on. Then I want to explore possibilities of improvement especially cache for concurrent programs. Such studies have been done for C/C++ as memory trace is easily available via PIN instrumentation. I want to do similar studies for Java bytecode."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[11609584-cu15380703]-[-1834535320]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"If I get this memory trace for some benchmarks then, I can use it for a couple of purposes such as finding the generate usage pattern for the physical memory by Java programs, the cache usage and so on. Then I want to explore possibilities of improvement especially cache for concurrent programs. Such studies have been done for C/C++ as memory trace is easily available via PIN instrumentation. I want to do similar studies for Java bytecode."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "program":2,
                      "find":1,
                      "cach":2,
                      "concurr":1,
                      "trace":2,
                      "pattern":1,
                      "similar":1,
                      "bytecod":1,
                      "explor":1,
                      "possibl":1,
                      "improv":1,
                      "easili":1,
                      "coupl":1,
                      "generat":1,
                      "usag":2,
                      "studi":2,
                      "pin":1,
                      "purpos":1,
                      "physic":1,
                      "instrument":1,
                      "benchmark":1,
                      "memori":3
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":15381376,
        "postId":11609584,
        "creationDate":"2012-07-23",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":57695,
          "displayName":"Peter Lawrey",
          "reputation":257803
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"The byte code is for a virtual machine. As such it doesn't have a cache or memory locations in byte code. This is used to generate native code, but this native code can be compiled multiple times over the life of the application. Also objects can be moved to multiple places over the life of the program, so its address isn't very meaningful."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[11609584-cu15381376]-[-1061629008]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"The byte code is for a virtual machine. As such it doesn't have a cache or memory locations in byte code. This is used to generate native code, but this native code can be compiled multiple times over the life of the application. Also objects can be moved to multiple places over the life of the program, so its address isn't very meaningful."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "program":1,
                      "move":1,
                      "cach":1,
                      "virtual":1,
                      "object":1,
                      "code":4,
                      "machin":1,
                      "meaning":1,
                      "applic":1,
                      "isn":1,
                      "life":2,
                      "address":1,
                      "generat":1,
                      "place":1,
                      "compil":1,
                      "time":1,
                      "multipl":2,
                      "locat":1,
                      "memori":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":15381426,
        "postId":11609584,
        "creationDate":"2012-07-23",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":57695,
          "displayName":"Peter Lawrey",
          "reputation":257803
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"The JVM is much more dynamic at runtime than C or C++ programs and you will find that the same optimisation techniques are much harder or even impossible."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[11609584-cu15381426]-[1121465482]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"The JVM is much more dynamic at runtime than C or C++ programs and you will find that the same optimisation techniques are much harder or even impossible."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "jvm":1,
                      "program":1,
                      "find":1,
                      "runtim":1,
                      "optimis":1,
                      "imposs":1,
                      "dynam":1,
                      "techniqu":1,
                      "harder":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":15381464,
        "postId":11609584,
        "creationDate":"2012-07-23",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":752920,
          "displayName":"Ankit",
          "reputation":1556
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"@PeterLawrey Yes! However, you can still make nice approximations to the cache usage from the bytecode. I have added the explanation to what I think! Please correct if I am making some bad assumptions."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[11609584-cu15381464]-[-2076104807]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"@PeterLawrey Yes! However, you can still make nice approximations to the cache usage from the bytecode. I have added the explanation to what I think! Please correct if I am making some bad assumptions."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    {
                      "type":"AnnotationNode",
                      "identifier":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"PeterLawrey",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "cach":1,
                      "bytecod":1,
                      "correct":1,
                      "peter":1,
                      "bad":1,
                      "nice":1,
                      "explan":1,
                      "assumpt":1,
                      "make":2,
                      "usag":1,
                      "ad":1,
                      "lawrey":1,
                      "approxim":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":15381523,
        "postId":11609584,
        "creationDate":"2012-07-23",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":57695,
          "displayName":"Peter Lawrey",
          "reputation":257803
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"Like I said, you can't get an address from byte code, and even if you could, it will keep changing. With escape analysis, objects can be eliminated so they never have an address in the first place."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[11609584-cu15381523]-[-2104630730]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"Like I said, you can't get an address from byte code, and even if you could, it will keep changing. With escape analysis, objects can be eliminated so they never have an address in the first place."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "chang":1,
                      "escap":1,
                      "object":1,
                      "code":1,
                      "elimin":1,
                      "address":2,
                      "place":1,
                      "analysi":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "tags":[
      "java",
      "instrumentation"
    ],
    "creationDate":"2012-07-23",
    "lastActivityDate":"2012-07-23",
    "lastEditDate":"2012-07-23",
    "score":3,
    "viewCount":358,
    "owner":{
      "type":"StackOverflowUser",
      "id":752920,
      "displayName":"Ankit",
      "reputation":1556
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I want to study the memory access patterns of a Java program. Is there a framework or a way by which I can achieve this.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[11609584]-[-1267169051]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I want to study the memory access patterns of a Java program. Is there a framework or a way by which I can achieve this.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "program":1,
                  "pattern":1,
                  "framework":1,
                  "achiev":1,
                  "studi":1,
                  "access":1,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Say there is a program P, which accesses the memory addresses m1, m2, m3 and so on in that order. I want to be able to see these accesses in that order and also if possible, what type of object was accessed?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[11609584]-[-1101295132]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Say there is a program P, which accesses the memory addresses m1, m2, m3 and so on in that order. I want to be able to see these accesses in that order and also if possible, what type of object was accessed?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "program":1,
                  "object":1,
                  "order":2,
                  "address":1,
                  "type":1,
                  "access":3,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p><strong>Update (Adding towards Durandal's suggestion):</strong></p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[11609584]-[-178252758]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p><strong>Update (Adding towards Durandal's suggestion):</strong></p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "suggest":1,
                  "durand":1,
                  "updat":1,
                  "strong":2,
                  "ad":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I can always find the memory access pattern by running Java programs with PIN instrumentation. This is all good except doing so, I will lose the mapping of memory address to objects. One important aspect of the study that I want to do is to be able to map the memory usage with corresponding types (Class). </p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[11609584]-[1355591592]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I can always find the memory access pattern by running Java programs with PIN instrumentation. This is all good except doing so, I will lose the mapping of memory address to objects. One important aspect of the study that I want to do is to be able to map the memory usage with corresponding types (Class). </p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "program":1,
                  "find":1,
                  "pattern":1,
                  "map":2,
                  "good":1,
                  "run":1,
                  "aspect":1,
                  "object":1,
                  "import":1,
                  "address":1,
                  "usag":1,
                  "studi":1,
                  "type":1,
                  "pin":1,
                  "lose":1,
                  "instrument":1,
                  "access":1,
                  "memori":3
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Although correctly mentioned that the memory usage pattern will depend on the JVM implementation, I would like to consider that as a later step of the study. Right now, I am looking for bytecode instrumentation only. (correct me if I am going the wrong direction!)</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[11609584]-[-47419285]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Although correctly mentioned that the memory usage pattern will depend on the JVM implementation, I would like to consider that as a later step of the study. Right now, I am looking for bytecode instrumentation only. (correct me if I am going the wrong direction!)</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "jvm":1,
                  "step":1,
                  "depend":1,
                  "pattern":1,
                  "wrong":1,
                  "bytecod":1,
                  "correct":2,
                  "direct":1,
                  "mention":1,
                  "implement":1,
                  "usag":1,
                  "studi":1,
                  "instrument":1,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p><strong>How do I think bytecode instrumentation will help me analyze the cache usage?</strong> Before any explanation! This is only one aspect of what I want to do. This is the case that I will do when a memory access pattern (as obtained from the PIN, or a modified VM or whatever) will be insufficient to give me information about usage of cache by different objects (or objects belonging to a specific class). Suppose I get the bytecode accesses as </p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[11609584]-[458738084]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p><strong>How do I think bytecode instrumentation will help me analyze the cache usage?</strong> Before any explanation! This is only one aspect of what I want to do. This is the case that I will do when a memory access pattern (as obtained from the PIN, or a modified VM or whatever) will be insufficient to give me information about usage of cache by different objects (or objects belonging to a specific class). Suppose I get the bytecode accesses as </p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "cach":2,
                  "pattern":1,
                  "analyz":1,
                  "bytecod":2,
                  "aspect":1,
                  "insuffici":1,
                  "strong":2,
                  "belong":1,
                  "object":2,
                  "explan":1,
                  "inform":1,
                  "specif":1,
                  "modifi":1,
                  "give":1,
                  "usag":2,
                  "pin":1,
                  "suppos":1,
                  "instrument":1,
                  "obtain":1,
                  "access":2,
                  "memori":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlNode",
          "name":{
            "type":"XmlNameNode",
            "value":"pre"
          },
          "attributes":[
            
          ],
          "elements":[
            {
              "type":"XmlNode",
              "name":{
                "type":"XmlNameNode",
                "value":"code"
              },
              "attributes":[
                
              ],
              "elements":[
                {
                  "type":"XmlTextNode",
                  "contents":"ObjectA ObjectB ObjectC ... "
                }
              ]
            }
          ]
        },
        "units":[
          {
            "type":"StructuredFragmentUnit",
            "id":"[11609584]-[68244009]",
            "astNode":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"TextFragmentNode",
                  "text":"ObjectA ObjectB ObjectC ... "
                }
              ]
            },
            "rawText":"ObjectA ObjectB ObjectC ... ",
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "object":3
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>It is easy to find the size of an object. I can also find if the memory access for an object was memory allocation or not by if this is the first access to the object. Then, assuming that the JVM when running would allocate continuous memory, I can make an assumption on the usage of the cache (by running a cache simulation). Now, this would not be a very good assumption but still give me an upper bound on cache usage (at least I believe so).</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[11609584]-[1933806946]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>It is easy to find the size of an object. I can also find if the memory access for an object was memory allocation or not by if this is the first access to the object. Then, assuming that the JVM when running would allocate continuous memory, I can make an assumption on the usage of the cache (by running a cache simulation). Now, this would not be a very good assumption but still give me an upper bound on cache usage (at least I believe so).</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "jvm":1,
                  "find":2,
                  "assum":1,
                  "cach":3,
                  "easi":1,
                  "alloc":2,
                  "size":1,
                  "continu":1,
                  "good":1,
                  "run":2,
                  "simul":1,
                  "upper":1,
                  "object":3,
                  "bound":1,
                  "assumpt":2,
                  "give":1,
                  "make":1,
                  "usag":2,
                  "access":2,
                  "memori":3
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":11611949,
      "questionId":11609584,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":15402159,
          "postId":11611949,
          "creationDate":"2012-07-24",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":352131,
            "displayName":"Durandal",
            "reputation":10490
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"I don't know of any frameworks for profiling, presumably each profiler uses its own implementation. But there are open source profilers (e.g. [link](http://jrat.sourceforge.net/)), this could give you a head start because they should already implement most of the meat."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[11611949-cu15402159]-[1915641386]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"I don't know of any frameworks for profiling, presumably each profiler uses its own implementation. But there are open source profilers (e.g. [link](http://jrat.sourceforge.net/)), this could give you a head start because they should already implement most of the meat."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "sourceforg":1,
                        "profil":3,
                        "jrat":1,
                        "head":1,
                        "meat":1,
                        "framework":1,
                        "open":1,
                        "net":1,
                        "link":1,
                        "implement":2,
                        "give":1,
                        "start":1,
                        "http":1,
                        "sourc":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":15391056,
          "postId":11611949,
          "creationDate":"2012-07-24",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":752920,
            "displayName":"Ankit",
            "reputation":1556
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"I think I will abandon the idea of mapping to physical memory and head off with maintaining the fields. Can you point me to a reasonable framework that I can use to reduce my work?"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[11611949-cu15391056]-[-1240822381]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"I think I will abandon the idea of mapping to physical memory and head off with maintaining the fields. Can you point me to a reasonable framework that I can use to reduce my work?"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "point":1,
                        "reduc":1,
                        "field":1,
                        "map":1,
                        "head":1,
                        "idea":1,
                        "framework":1,
                        "reason":1,
                        "work":1,
                        "abandon":1,
                        "physic":1,
                        "maintain":1,
                        "memori":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":15380970,
          "postId":11611949,
          "creationDate":"2012-07-23",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":752920,
            "displayName":"Ankit",
            "reputation":1556
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Thanks for pointing out the JVM implementation thing. However, my goals are a bit different (sorry for not being very clear in the question at first). I have updated the question to include my specific goals."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[11611949-cu15380970]-[-2123805906]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Thanks for pointing out the JVM implementation thing. However, my goals are a bit different (sorry for not being very clear in the question at first). I have updated the question to include my specific goals."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "jvm":1,
                        "question":2,
                        "point":1,
                        "bit":1,
                        "clear":1,
                        "updat":1,
                        "thing":1,
                        "goal":2,
                        "includ":1,
                        "specif":1,
                        "implement":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":15381475,
          "postId":11611949,
          "creationDate":"2012-07-23",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":352131,
            "displayName":"Durandal",
            "reputation":10490
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Well with byte code instrumentation there are some possibilities that might suit your requirements. I've roughly outline two in the updated answer."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[11611949-cu15381475]-[-903250016]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Well with byte code instrumentation there are some possibilities that might suit your requirements. I've roughly outline two in the updated answer."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "requir":1,
                        "updat":1,
                        "suit":1,
                        "possibl":1,
                        "outlin":1,
                        "code":1,
                        "rough":1,
                        "answer":1,
                        "instrument":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2012-07-23",
      "lastActivityDate":"2012-07-23",
      "lastEditDate":"2012-07-23",
      "score":2,
      "isAccepted":true,
      "owner":{
        "type":"StackOverflowUser",
        "id":352131,
        "displayName":"Durandal",
        "reputation":10490
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Well you can always do it the hard way: alter the VM. There are JVM implementations that are completely written in Java that can probably be altered to collect the data you desire.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11611949]-[2133353812]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Well you can always do it the hard way: alter the VM. There are JVM implementations that are completely written in Java that can probably be altered to collect the data you desire.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jvm":1,
                    "hard":1,
                    "alter":2,
                    "data":1,
                    "written":1,
                    "implement":1,
                    "desir":1,
                    "complet":1,
                    "collect":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>However, I am strongly convinced that the memory access patterns will <em>depend</em> a lot on the specific VM running your program (because they will orgranize data differently in memory). Different VM's = different access patterns. If the VM you measure on in has a JIT, it will also depend on if the JIT kicks in or not.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11611949]-[-853385702]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>However, I am strongly convinced that the memory access patterns will <em>depend</em> a lot on the specific VM running your program (because they will orgranize data differently in memory). Different VM's = different access patterns. If the VM you measure on in has a JIT, it will also depend on if the JIT kicks in or not.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jit":2,
                    "program":1,
                    "depend":2,
                    "pattern":2,
                    "differ":1,
                    "run":1,
                    "data":1,
                    "strong":1,
                    "measur":1,
                    "kick":1,
                    "specif":1,
                    "convinc":1,
                    "lot":1,
                    "orgran":1,
                    "access":2,
                    "memori":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The way to <em>really</em> collect all the memory accesses would be to run the VM in some kind of sandbox environment and count its accesses (this could be done in some emulator, or with the help of the MMU).</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11611949]-[-352282660]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The way to <em>really</em> collect all the memory accesses would be to run the VM in some kind of sandbox environment and count its accesses (this could be done in some emulator, or with the help of the MMU).</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "count":1,
                    "run":1,
                    "emul":1,
                    "mmu":1,
                    "sandbox":1,
                    "collect":1,
                    "kind":1,
                    "environ":1,
                    "access":2,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<hr />"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11611949]-[1817223689]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<hr />"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>EDIT (question updated - bytecode instrumentation only): With bytecode instrumentation you are basically very close to what an instrumenting profiler does. Your main problem now is that you can not easily establish a relationship between objects and memory addresses. I can think of two approaches to circumvent this:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11611949]-[-857761266]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>EDIT (question updated - bytecode instrumentation only): With bytecode instrumentation you are basically very close to what an instrumenting profiler does. Your main problem now is that you can not easily establish a relationship between objects and memory addresses. I can think of two approaches to circumvent this:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "question":1,
                    "profil":1,
                    "problem":1,
                    "bytecod":2,
                    "updat":1,
                    "establish":1,
                    "main":1,
                    "object":1,
                    "easili":1,
                    "edit":1,
                    "relationship":1,
                    "address":1,
                    "approach":1,
                    "circumv":1,
                    "basic":1,
                    "close":1,
                    "instrument":3,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<ul> \n <li><p>There is a (JRE private, but usable) class sun.misc.Unsafe that <em>can</em> get you the absolute memory address of objects, fields and arrays (it has lots of methods to do just that). If you instrument the bytecode to make calls to utility methods for counting they can use Unsafe to determine the address that will be used. However Unsafe is implementation specific and there may be problems with the garbage collector moving objects around the heap. This may or may not be what you want to measure. At least this could be implemented with reasonable amount of effort.</p></li> \n <li><p>You could abandon the concept of <em>memory addresses</em> completely and replace it with <em>object identity</em> and <em>field</em> (array identity and index respectively). Your profiling instrumentation would then need to keep track of objects and accessed fields. The only thing you really need to pay attention to is that you must retain objects references in a way that will not block out the garbage collector (e.g. using WeakReferences). This too shouldn't be too hard to implement. This approach would not identify <em>hot memory</em> locations, but rather <em>hot objects/fields</em>.</p></li> \n</ul>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11611949]-[-2027850802]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<ul> \n <li><p>There is a (JRE private, but usable) class sun.misc.Unsafe that <em>can</em> get you the absolute memory address of objects, fields and arrays (it has lots of methods to do just that). If you instrument the bytecode to make calls to utility methods for counting they can use Unsafe to determine the address that will be used. However Unsafe is implementation specific and there may be problems with the garbage collector moving objects around the heap. This may or may not be what you want to measure. At least this could be implemented with reasonable amount of effort.</p></li> \n <li><p>You could abandon the concept of <em>memory addresses</em> completely and replace it with <em>object identity</em> and <em>field</em> (array identity and index respectively). Your profiling instrumentation would then need to keep track of objects and accessed fields. The only thing you really need to pay attention to is that you must retain objects references in a way that will not block out the garbage collector (e.g. using WeakReferences). This too shouldn't be too hard to implement. This approach would not identify <em>hot memory</em> locations, but rather <em>hot objects/fields</em>.</p></li> \n</ul>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ClassDeclarationNode",
                    "modifiers":[
                      
                    ],
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"sun",
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"WeakReferences",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jre":1,
                    "method":2,
                    "collector":2,
                    "count":1,
                    "move":1,
                    "determin":1,
                    "effort":1,
                    "profil":1,
                    "hard":1,
                    "util":1,
                    "field":4,
                    "problem":1,
                    "bytecod":1,
                    "weak":1,
                    "track":1,
                    "sun":1,
                    "retain":1,
                    "thing":1,
                    "pay":1,
                    "reason":1,
                    "amount":1,
                    "measur":1,
                    "object":6,
                    "array":2,
                    "block":1,
                    "replac":1,
                    "ident":2,
                    "attent":1,
                    "abandon":1,
                    "usabl":1,
                    "specif":1,
                    "refer":2,
                    "implement":3,
                    "misc":1,
                    "absolut":1,
                    "lot":1,
                    "identifi":1,
                    "address":3,
                    "make":1,
                    "approach":1,
                    "concept":1,
                    "hot":2,
                    "unsaf":3,
                    "complet":1,
                    "heap":1,
                    "shouldn":1,
                    "call":1,
                    "instrument":2,
                    "garbag":2,
                    "locat":1,
                    "index":1,
                    "access":1,
                    "memori":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"WeakReferences",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Both aproaches will have some influence on the measurement, as the collected data would be stored in the same heap as the code being analyzed. If that is highly undesirable, you could use JNI to collect the data off-heap.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11611949]-[713343038]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Both aproaches will have some influence on the measurement, as the collected data would be stored in the same heap as the code being analyzed. If that is highly undesirable, you could use JNI to collect the data off-heap.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "analyz":1,
                    "influenc":1,
                    "data":2,
                    "store":1,
                    "measur":1,
                    "code":1,
                    "jni":1,
                    "undesir":1,
                    "aproach":1,
                    "collect":2,
                    "heap":2,
                    "high":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":11617004,
      "questionId":11609584,
      "comments":[
        
      ],
      "creationDate":"2012-07-23",
      "lastActivityDate":"2012-07-23",
      "score":0,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":302139,
        "displayName":"Edwin Buck",
        "reputation":36608
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Which portion of the Java program? The Java &quot;user space&quot; consisting of the classes loaded and previously accessible by &quot;public static void main(String[] args) {...&quot;, or the entire JVM, which includes behind-the-scenes memory management, garbage collection, debugging facilities, management facilities, etc.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11617004]-[-1673870380]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Which portion of the Java program? The Java &quot;user space&quot; consisting of the classes loaded and previously accessible by &quot;public static void main(String[] args) {...&quot;, or the entire JVM, which includes behind-the-scenes memory management, garbage collection, debugging facilities, management facilities, etc.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"MethodDeclaratorNode",
                    "modifiers":[
                      {
                        "type":"KeywordModifierNode",
                        "value":"public",
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"KeywordModifierNode",
                        "value":"static",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "returnType":{
                      "type":"PrimitiveTypeNode",
                      "name":"void",
                      "comments":[
                        
                      ]
                    },
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"main",
                      "comments":[
                        
                      ]
                    },
                    "parameters":{
                      "type":"FormalParametersNode",
                      "parameters":{
                        "type":"FormalParameterDeclsNode",
                        "modifiers":[
                          
                        ],
                        "parameterType":{
                          "type":"ArrayTypeNode",
                          "typeNode":{
                            "type":"ReferenceTypeNode",
                            "ids":[
                              {
                                "type":"ParameterizedTypeNode",
                                "identifier":{
                                  "type":"IdentifierNode",
                                  "name":"String",
                                  "comments":[
                                    
                                  ]
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "depth":[
                            {
                              "type":"ArrayDimensionNode",
                              "comments":[
                                
                              ]
                            }
                          ]
                        },
                        "nextDeclarator":{
                          "type":"AdditionalFormalParameterDeclNode",
                          "variableDeclarator":{
                            "type":"VariableDeclaratorNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"args",
                              "comments":[
                                
                              ]
                            },
                            "arrayDepth":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      },
                      "comments":[
                        
                      ]
                    },
                    "arrayReturnType":[
                      
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jvm":1,
                    "program":1,
                    "portion":1,
                    "previous":1,
                    "load":1,
                    "entir":1,
                    "main":1,
                    "debug":1,
                    "includ":1,
                    "consist":1,
                    "space":1,
                    "scene":1,
                    "facil":2,
                    "class":1,
                    "quot":4,
                    "collect":1,
                    "manag":2,
                    "user":1,
                    "arg":1,
                    "garbag":1,
                    "access":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"String",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    {
                      "type":"PrimitiveTypeNode",
                      "name":"void",
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    {
                      "type":"VariableDeclaratorNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"args",
                        "comments":[
                          
                        ]
                      },
                      "arrayDepth":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>If you were looking for real memory addresses, then you need to debug the JVM. This is very different than debugging a Java program, because a memory abstraction layer exists between the real memory and the &quot;user space&quot; program. To tune real memory access, you cannot rewrite the Java program, you need to rewrite the JVM.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11617004]-[2124997273]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>If you were looking for real memory addresses, then you need to debug the JVM. This is very different than debugging a Java program, because a memory abstraction layer exists between the real memory and the &quot;user space&quot; program. To tune real memory access, you cannot rewrite the Java program, you need to rewrite the JVM.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "tune":1,
                    "jvm":2,
                    "program":3,
                    "real":3,
                    "exist":1,
                    "abstract":1,
                    "debug":2,
                    "layer":1,
                    "space":1,
                    "address":1,
                    "quot":2,
                    "rewrit":2,
                    "user":1,
                    "access":1,
                    "memori":4
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Bytecode insertion is still part of the &quot;user space&quot; Java program, meaning that you will never be able to determine absolute memory addresses via bytecode insertion. In fact, the &quot;user space&quot; mapping of a JVM reference to a real memory address is not even expected to be constant over time for the same object.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[11617004]-[425726210]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Bytecode insertion is still part of the &quot;user space&quot; Java program, meaning that you will never be able to determine absolute memory addresses via bytecode insertion. In fact, the &quot;user space&quot; mapping of a JVM reference to a real memory address is not even expected to be constant over time for the same object.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "constant":1,
                    "jvm":1,
                    "program":1,
                    "determin":1,
                    "real":1,
                    "insert":2,
                    "map":1,
                    "bytecod":2,
                    "mean":1,
                    "object":1,
                    "fact":1,
                    "space":2,
                    "expect":1,
                    "refer":1,
                    "absolut":1,
                    "address":2,
                    "quot":4,
                    "time":1,
                    "part":1,
                    "user":2,
                    "memori":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}