{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":17414924,
    "title":"How to test AtomicBoolean atomicity?",
    "comments":[
      {
        "type":"StackOverflowComment",
        "id":25297590,
        "postId":17414924,
        "creationDate":"2013-07-02",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":741217,
          "displayName":"Rolf W.",
          "reputation":47
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"Thanks for you feedback. I assume you're referring to the AtomicInteger test, right? I'd like to be sure there are no false positives; Can you point out possible improvements for this approach and/or give examples of how something can go wrong?"
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[17414924-cu25297590]-[-1299008239]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"Thanks for you feedback. I assume you're referring to the AtomicInteger test, right? I'd like to be sure there are no false positives; Can you point out possible improvements for this approach and/or give examples of how something can go wrong?"
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicInteger",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "test":1,
                      "assum":1,
                      "point":1,
                      "wrong":1,
                      "exampl":1,
                      "improv":1,
                      "feedback":1,
                      "refer":1,
                      "posit":1,
                      "give":1,
                      "approach":1,
                      "fals":1,
                      "atom":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"AtomicInteger",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":25291306,
        "postId":17414924,
        "creationDate":"2013-07-01",
        "score":1,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1866587,
          "displayName":"selig",
          "reputation":2235
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"I'm sure you have - but make sure you think about everything when testing this kind of low-level concurrency i.e. the hardware you're running on, the operating system, the JVM - it can all effect things like this and mean that tests that always pass in one context fail in another."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[17414924-cu25291306]-[716017020]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"I'm sure you have - but make sure you think about everything when testing this kind of low-level concurrency i.e. the hardware you're running on, the operating system, the JVM - it can all effect things like this and mean that tests that always pass in one context fail in another."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "jvm":1,
                      "test":2,
                      "fail":1,
                      "concurr":1,
                      "system":1,
                      "context":1,
                      "run":1,
                      "effect":1,
                      "thing":1,
                      "oper":1,
                      "low":1,
                      "hardwar":1,
                      "pass":1,
                      "make":1,
                      "kind":1,
                      "level":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "tags":[
      "java",
      "multithreading",
      "unit-testing",
      "concurrency"
    ],
    "creationDate":"2013-07-01",
    "lastActivityDate":"2013-07-02",
    "lastEditDate":"2013-07-01",
    "score":5,
    "viewCount":462,
    "owner":{
      "type":"StackOverflowUser",
      "id":741217,
      "displayName":"Rolf W.",
      "reputation":47
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I'm writing unit tests for AtomicInteger and AtomicBoolean. They are going to be used as reference tests for testing emulations of these classes in objective-c, for use in translated projects.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[17414924]-[-48033009]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I'm writing unit tests for AtomicInteger and AtomicBoolean. They are going to be used as reference tests for testing emulations of these classes in objective-c, for use in translated projects.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"AtomicInteger",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "test":3,
                  "project":1,
                  "emul":1,
                  "object":1,
                  "translat":1,
                  "refer":1,
                  "class":1,
                  "atom":2,
                  "unit":1,
                  "write":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>The AtomicInteger test worked out well I think, basically by performing a predictable number of increment, decrement, add and subtract operations in a large number of for loops, each running in their own thread (and many threads per operation type). The actual operations start simultaneously using a CountDownLatch. </p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[17414924]-[-14243277]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>The AtomicInteger test worked out well I think, basically by performing a predictable number of increment, decrement, add and subtract operations in a large number of for loops, each running in their own thread (and many threads per operation type). The actual operations start simultaneously using a CountDownLatch. </p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"AtomicInteger",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                },
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"CountDownLatch",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "number":2,
                  "test":1,
                  "count":1,
                  "loop":1,
                  "subtract":1,
                  "simultan":1,
                  "run":1,
                  "work":1,
                  "oper":3,
                  "decrement":1,
                  "thread":2,
                  "larg":1,
                  "perform":1,
                  "latch":1,
                  "atom":1,
                  "predict":1,
                  "type":1,
                  "start":1,
                  "basic":1,
                  "actual":1,
                  "add":1,
                  "increment":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"CountDownLatch",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>When all threads are done I assert by comparing the atomic integer with the expected integer value based on the number of threads, iterations per thread and the expected increase/decrease per iteration. This test passes.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[17414924]-[-158170920]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>When all threads are done I assert by comparing the atomic integer with the expected integer value based on the number of threads, iterations per thread and the expected increase/decrease per iteration. This test passes.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "number":1,
                  "test":1,
                  "decreas":1,
                  "base":1,
                  "thread":3,
                  "compar":1,
                  "expect":2,
                  "iter":2,
                  "increas":1,
                  "pass":1,
                  "atom":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p><strong>But how to test AtomicBoolean?</strong> The basic operations are get and set so calling that many times in many threads and expecting the final result to be either true or false doesn't seem to make sense. The direction I'm thinking is to use two AtomicBooleans that should always have opposite values. Like this:</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[17414924]-[-1875310575]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p><strong>But how to test AtomicBoolean?</strong> The basic operations are get and set so calling that many times in many threads and expecting the final result to be either true or false doesn't seem to make sense. The direction I'm thinking is to use two AtomicBooleans that should always have opposite values. Like this:</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"AtomicBoolean",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                },
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"AtomicBooleans",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "sens":1,
                  "test":1,
                  "result":1,
                  "set":1,
                  "strong":2,
                  "direct":1,
                  "oper":1,
                  "thread":1,
                  "boolean":1,
                  "opposit":1,
                  "think":1,
                  "expect":1,
                  "valu":1,
                  "true":1,
                  "make":1,
                  "fals":1,
                  "atom":2,
                  "time":1,
                  "basic":1,
                  "call":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicBoolean",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicBooleans",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlNode",
          "name":{
            "type":"XmlNameNode",
            "value":"pre"
          },
          "attributes":[
            
          ],
          "elements":[
            {
              "type":"XmlNode",
              "name":{
                "type":"XmlNameNode",
                "value":"code"
              },
              "attributes":[
                
              ],
              "elements":[
                {
                  "type":"XmlTextNode",
                  "contents":"@Test public void testAtomicity() throws Exception { // ==== SETUP ==== final AtomicBoolean booleanA = new AtomicBoolean(true); final AtomicBoolean booleanB = new AtomicBoolean(false); final int threadCount = 50; final int iterationsPerThread = 5000; final CountDownLatch startSignalLatch = new CountDownLatch(1); final CountDownLatch threadsFinishedLatch = new CountDownLatch(threadCount); final AtomicBoolean assertFailed = new AtomicBoolean(false); // ==== EXECUTE: start all threads ==== for (int i = 0; i &lt; threadCount; i++) { // ==== Create the thread ===== AtomicOperationsThread thread; thread = new AtomicOperationsThread(&quot;Thread #&quot; + i, booleanA, booleanB, startSignalLatch, threadsFinishedLatch, iterationsPerThread, assertFailed); System.out.println(&quot;Creating Thread #&quot; + i); // ==== Start the thread (each thread will wait until the startSignalLatch is triggered) ===== thread.start(); } startSignalLatch.countDown(); // ==== VERIFY: that the AtomicInteger has the expected value after all threads have finished ==== final boolean allThreadsFinished; allThreadsFinished = threadsFinishedLatch.await(60, TimeUnit.SECONDS); assertTrue(&quot;Not all threads have finished before reaching the timeout&quot;, allThreadsFinished); assertFalse(assertFailed.get()); } private static class AtomicOperationsThread extends Thread { // ##### Instance variables ##### private final CountDownLatch startSignalLatch; private final CountDownLatch threadsFinishedLatch; private final int iterations; private final AtomicBoolean booleanA, booleanB; private final AtomicBoolean assertFailed; // ##### Constructor ##### private AtomicOperationsThread(final String name, final AtomicBoolean booleanA, final AtomicBoolean booleanB, final CountDownLatch startSignalLatch, final CountDownLatch threadsFinishedLatch, final int iterations, final AtomicBoolean assertFailed) { super(name); this.booleanA = booleanA; this.booleanB = booleanB; this.startSignalLatch = startSignalLatch; this.threadsFinishedLatch = threadsFinishedLatch; this.iterations = iterations; this.assertFailed = assertFailed; } // ##### Thread implementation ##### @Override public void run() { super.run(); // ==== Wait for the signal to start (so all threads are executed simultaneously) ===== try { System.out.println(this.getName() + &quot; has started. Awaiting startSignal.&quot;); startSignalLatch.await(); /* Awaiting start signal */ } catch (InterruptedException e) { throw new RuntimeException(&quot;The startSignalLatch got interrupted.&quot;, e); } // ==== Perform the atomic operations ===== for (int i = 0; i &lt; iterations; i++) { final boolean booleanAChanged; booleanAChanged = booleanA.compareAndSet(!booleanB.get(), booleanB.getAndSet(booleanA.get())); /* Set A to the current value of B if A is currently the opposite of B, then set B to the current value of A */ if (!booleanAChanged){ assertFailed.set(true); System.out.println(&quot;Assert failed in thread: &quot; + this.getName()); } } // ==== Mark this thread as finished ===== threadsFinishedLatch.countDown(); } } "
                }
              ]
            }
          ]
        },
        "units":[
          {
            "type":"StructuredFragmentUnit",
            "id":"[17414924]-[-734316269]",
            "astNode":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"MethodDeclaratorNode",
                  "modifiers":[
                    {
                      "type":"AnnotationNode",
                      "identifier":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"Test",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"KeywordModifierNode",
                      "value":"public",
                      "comments":[
                        
                      ]
                    }
                  ],
                  "returnType":{
                    "type":"PrimitiveTypeNode",
                    "name":"void",
                    "comments":[
                      
                    ]
                  },
                  "identifier":{
                    "type":"IdentifierNode",
                    "name":"testAtomicity",
                    "comments":[
                      
                    ]
                  },
                  "parameters":{
                    "type":"FormalParametersNode",
                    "comments":[
                      
                    ]
                  },
                  "arrayReturnType":[
                    
                  ],
                  "thrownExceptions":{
                    "type":"ThrownExceptionsNode",
                    "qualifiedIdentifierList":{
                      "type":"QualifiedIdentifierListNode",
                      "qualifiedNames":[
                        {
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"Exception",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  },
                  "body":{
                    "type":"BlockNode",
                    "statements":[
                      
                    ],
                    "labels":[
                      
                    ],
                    "comments":[
                      {
                        "text":"// ==== SETUP ==== final AtomicBoolean booleanA = new AtomicBoolean(true); final AtomicBoolean booleanB = new AtomicBoolean(false); final int threadCount = 50; final int iterationsPerThread = 5000; final CountDownLatch startSignalLatch = new CountDownLatch(1); final CountDownLatch threadsFinishedLatch = new CountDownLatch(threadCount); final AtomicBoolean assertFailed = new AtomicBoolean(false); // ==== EXECUTE: start all threads ==== for (int i = 0; i < threadCount; i++) { // ==== Create the thread ===== AtomicOperationsThread thread; thread = new AtomicOperationsThread(\"Thread #\" + i, booleanA, booleanB, startSignalLatch, threadsFinishedLatch, iterationsPerThread, assertFailed); System.out.println(\"Creating Thread #\" + i); // ==== Start the thread (each thread will wait until the startSignalLatch is triggered) ===== thread.start(); } startSignalLatch.countDown(); // ==== VERIFY: that the AtomicInteger has the expected value after all threads have finished ==== final boolean allThreadsFinished; allThreadsFinished = threadsFinishedLatch.await(60, TimeUnit.SECONDS); assertTrue(\"Not all threads have finished before reaching the timeout\", allThreadsFinished); assertFalse(assertFailed.get()); } private static class AtomicOperationsThread extends Thread { // ##### Instance variables ##### private final CountDownLatch startSignalLatch; private final CountDownLatch threadsFinishedLatch; private final int iterations; private final AtomicBoolean booleanA, booleanB; private final AtomicBoolean assertFailed; // ##### Constructor ##### private AtomicOperationsThread(final String name, final AtomicBoolean booleanA, final AtomicBoolean booleanB, final CountDownLatch startSignalLatch, final CountDownLatch threadsFinishedLatch, final int iterations, final AtomicBoolean assertFailed) { super(name); this.booleanA = booleanA; this.booleanB = booleanB; this.startSignalLatch = startSignalLatch; this.threadsFinishedLatch = threadsFinishedLatch; this.iterations = iterations; this.assertFailed = assertFailed; } // ##### Thread implementation ##### @Override public void run() { super.run(); // ==== Wait for the signal to start (so all threads are executed simultaneously) ===== try { System.out.println(this.getName() + \" has started. Awaiting startSignal.\"); startSignalLatch.await(); /* Awaiting start signal */ } catch (InterruptedException e) { throw new RuntimeException(\"The startSignalLatch got interrupted.\", e); } // ==== Perform the atomic operations ===== for (int i = 0; i < iterations; i++) { final boolean booleanAChanged; booleanAChanged = booleanA.compareAndSet(!booleanB.get(), booleanB.getAndSet(booleanA.get())); /* Set A to the current value of B if A is currently the opposite of B, then set B to the current value of A */ if (!booleanAChanged){ assertFailed.set(true); System.out.println(\"Assert failed in thread: \" + this.getName()); } } // ==== Mark this thread as finished ===== threadsFinishedLatch.countDown(); } } \n"
                      }
                    ]
                  },
                  "comments":[
                    
                  ]
                }
              ]
            },
            "rawText":"@Test public void testAtomicity() throws Exception { // ==== SETUP ==== final AtomicBoolean booleanA = new AtomicBoolean(true); final AtomicBoolean booleanB = new AtomicBoolean(false); final int threadCount = 50; final int iterationsPerThread = 5000; final CountDownLatch startSignalLatch = new CountDownLatch(1); final CountDownLatch threadsFinishedLatch = new CountDownLatch(threadCount); final AtomicBoolean assertFailed = new AtomicBoolean(false); // ==== EXECUTE: start all threads ==== for (int i = 0; i < threadCount; i++) { // ==== Create the thread ===== AtomicOperationsThread thread; thread = new AtomicOperationsThread(\"Thread #\" + i, booleanA, booleanB, startSignalLatch, threadsFinishedLatch, iterationsPerThread, assertFailed); System.out.println(\"Creating Thread #\" + i); // ==== Start the thread (each thread will wait until the startSignalLatch is triggered) ===== thread.start(); } startSignalLatch.countDown(); // ==== VERIFY: that the AtomicInteger has the expected value after all threads have finished ==== final boolean allThreadsFinished; allThreadsFinished = threadsFinishedLatch.await(60, TimeUnit.SECONDS); assertTrue(\"Not all threads have finished before reaching the timeout\", allThreadsFinished); assertFalse(assertFailed.get()); } private static class AtomicOperationsThread extends Thread { // ##### Instance variables ##### private final CountDownLatch startSignalLatch; private final CountDownLatch threadsFinishedLatch; private final int iterations; private final AtomicBoolean booleanA, booleanB; private final AtomicBoolean assertFailed; // ##### Constructor ##### private AtomicOperationsThread(final String name, final AtomicBoolean booleanA, final AtomicBoolean booleanB, final CountDownLatch startSignalLatch, final CountDownLatch threadsFinishedLatch, final int iterations, final AtomicBoolean assertFailed) { super(name); this.booleanA = booleanA; this.booleanB = booleanB; this.startSignalLatch = startSignalLatch; this.threadsFinishedLatch = threadsFinishedLatch; this.iterations = iterations; this.assertFailed = assertFailed; } // ##### Thread implementation ##### @Override public void run() { super.run(); // ==== Wait for the signal to start (so all threads are executed simultaneously) ===== try { System.out.println(this.getName() + \" has started. Awaiting startSignal.\"); startSignalLatch.await(); /* Awaiting start signal */ } catch (InterruptedException e) { throw new RuntimeException(\"The startSignalLatch got interrupted.\", e); } // ==== Perform the atomic operations ===== for (int i = 0; i < iterations; i++) { final boolean booleanAChanged; booleanAChanged = booleanA.compareAndSet(!booleanB.get(), booleanB.getAndSet(booleanA.get())); /* Set A to the current value of B if A is currently the opposite of B, then set B to the current value of A */ if (!booleanAChanged){ assertFailed.set(true); System.out.println(\"Assert failed in thread: \" + this.getName()); } } // ==== Mark this thread as finished ===== threadsFinishedLatch.countDown(); } } \n...\n}",
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "test":2,
                  "reach":1,
                  "fail":9,
                  "count":13,
                  "await":4,
                  "wait":2,
                  "runtim":1,
                  "system":3,
                  "simultan":1,
                  "run":2,
                  "set":5,
                  "verifi":1,
                  "overrid":1,
                  "constructor":1,
                  "finish":14,
                  "println":3,
                  "oper":5,
                  "second":1,
                  "thread":36,
                  "compar":1,
                  "opposit":1,
                  "expect":1,
                  "iter":7,
                  "perform":1,
                  "implement":1,
                  "true":3,
                  "latch":26,
                  "fals":3,
                  "atom":18,
                  "unit":1,
                  "time":1,
                  "variabl":1,
                  "mark":1,
                  "start":17,
                  "current":2,
                  "achang":3,
                  "creat":2,
                  "timeout":1,
                  "interrupt":2,
                  "setup":1,
                  "execut":2,
                  "instanc":1,
                  "trigger":1,
                  "signal":13
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  {
                    "type":"PrimitiveTypeNode",
                    "name":"void",
                    "comments":[
                      
                    ]
                  }
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>This works with one thread but fails with multiple. I guess this is because <code>booleanAChanged = booleanA.compareAndSet(!booleanB.get(), booleanB.getAndSet(booleanA.get()));</code> is not one atomic operation.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[17414924]-[-1177666992]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>This works with one thread but fails with multiple. I guess this is because <code>booleanAChanged = booleanA.compareAndSet(!booleanB.get(), booleanB.getAndSet(booleanA.get()));</code> is not one atomic operation.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"QualifiedIdentifierNode",
                  "identifiers":[
                    {
                      "type":"IdentifierNode",
                      "name":"booleanAChanged",
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                },
                {
                  "type":"MethodInvocationNode",
                  "qualifiedIdentifier":{
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"booleanA",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  "identifier":{
                    "type":"IdentifierNode",
                    "name":"compareAndSet",
                    "comments":[
                      
                    ]
                  },
                  "args":{
                    "type":"ExpressionListNode",
                    "arguments":[
                      {
                        "type":"PrefixOperatorExpressionNode",
                        "operator":{
                          "type":"OperatorNode",
                          "symbol":"!",
                          "comments":[
                            
                          ]
                        },
                        "argument":{
                          "type":"MethodInvocationNode",
                          "qualifiedIdentifier":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"booleanB",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"get",
                            "comments":[
                              
                            ]
                          },
                          "args":{
                            "type":"ExpressionListNode",
                            "arguments":[
                              
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"MethodInvocationNode",
                        "qualifiedIdentifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"booleanB",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"getAndSet",
                          "comments":[
                            
                          ]
                        },
                        "args":{
                          "type":"ExpressionListNode",
                          "arguments":[
                            {
                              "type":"MethodInvocationNode",
                              "qualifiedIdentifier":{
                                "type":"QualifiedIdentifierNode",
                                "identifiers":[
                                  {
                                    "type":"IdentifierNode",
                                    "name":"booleanA",
                                    "comments":[
                                      
                                    ]
                                  }
                                ],
                                "comments":[
                                  
                                ]
                              },
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"get",
                                "comments":[
                                  
                                ]
                              },
                              "args":{
                                "type":"ExpressionListNode",
                                "arguments":[
                                  
                                ],
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "fail":1,
                  "set":2,
                  "work":1,
                  "code":2,
                  "oper":1,
                  "thread":1,
                  "compar":1,
                  "atom":1,
                  "guess":1,
                  "achang":1,
                  "multipl":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  {
                    "type":"MethodInvocationNode",
                    "qualifiedIdentifier":{
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"booleanA",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"compareAndSet",
                      "comments":[
                        
                      ]
                    },
                    "args":{
                      "type":"ExpressionListNode",
                      "arguments":[
                        {
                          "type":"PrefixOperatorExpressionNode",
                          "operator":{
                            "type":"OperatorNode",
                            "symbol":"!",
                            "comments":[
                              
                            ]
                          },
                          "argument":{
                            "type":"MethodInvocationNode",
                            "qualifiedIdentifier":{
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"booleanB",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"get",
                              "comments":[
                                
                              ]
                            },
                            "args":{
                              "type":"ExpressionListNode",
                              "arguments":[
                                
                              ],
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"MethodInvocationNode",
                          "qualifiedIdentifier":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"booleanB",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"getAndSet",
                            "comments":[
                              
                            ]
                          },
                          "args":{
                            "type":"ExpressionListNode",
                            "arguments":[
                              {
                                "type":"MethodInvocationNode",
                                "qualifiedIdentifier":{
                                  "type":"QualifiedIdentifierNode",
                                  "identifiers":[
                                    {
                                      "type":"IdentifierNode",
                                      "name":"booleanA",
                                      "comments":[
                                        
                                      ]
                                    }
                                  ],
                                  "comments":[
                                    
                                  ]
                                },
                                "identifier":{
                                  "type":"IdentifierNode",
                                  "name":"get",
                                  "comments":[
                                    
                                  ]
                                },
                                "args":{
                                  "type":"ExpressionListNode",
                                  "arguments":[
                                    
                                  ],
                                  "comments":[
                                    
                                  ]
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"MethodInvocationNode",
                    "qualifiedIdentifier":{
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"booleanB",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"get",
                      "comments":[
                        
                      ]
                    },
                    "args":{
                      "type":"ExpressionListNode",
                      "arguments":[
                        
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"MethodInvocationNode",
                    "qualifiedIdentifier":{
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"booleanB",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"getAndSet",
                      "comments":[
                        
                      ]
                    },
                    "args":{
                      "type":"ExpressionListNode",
                      "arguments":[
                        {
                          "type":"MethodInvocationNode",
                          "qualifiedIdentifier":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"booleanA",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"get",
                            "comments":[
                              
                            ]
                          },
                          "args":{
                            "type":"ExpressionListNode",
                            "arguments":[
                              
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"MethodInvocationNode",
                    "qualifiedIdentifier":{
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"booleanA",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"get",
                      "comments":[
                        
                      ]
                    },
                    "args":{
                      "type":"ExpressionListNode",
                      "arguments":[
                        
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  }
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Any suggestions?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[17414924]-[-1342674545]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Any suggestions?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "suggest":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":17415401,
      "questionId":17414924,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":25307931,
          "postId":17415401,
          "creationDate":"2013-07-02",
          "score":2,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1798593,
            "displayName":"Patricia Shanahan",
            "reputation":13624
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@RolfW. I've incorporated your code in the answer, formatted and slightly modified. Although it might be worth experimenting, I would be surprised if it is useful to have a lot more threads than the hardware can run in parallel."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415401-cu25307931]-[92811463]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@RolfW. I've incorporated your code in the answer, formatted and slightly modified. Although it might be worth experimenting, I would be surprised if it is useful to have a lot more threads than the hardware can run in parallel."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"RolfW",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "format":1,
                        "rolf":1,
                        "run":1,
                        "slight":1,
                        "experi":1,
                        "surpris":1,
                        "code":1,
                        "thread":1,
                        "worth":1,
                        "hardwar":1,
                        "modifi":1,
                        "lot":1,
                        "answer":1,
                        "parallel":1,
                        "incorpor":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25300265,
          "postId":17415401,
          "creationDate":"2013-07-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":741217,
            "displayName":"Rolf W.",
            "reputation":47
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Interesting approach. It took me a while to grasp it, but it passes each time when it's like this (in each thread, with 500 threads): 1. `while (!SUT.compareAndSet(false, true));` 2. `int oldValue = AtomicBooleanTest.globalCounter;` 3. `Thread.sleep(1);` 4. `SUT.set(false);` When all threads are done, globalCounter should be 500. I assume this is what you had in mind, right?"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415401-cu25300265]-[-262581678]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Interesting approach. It took me a while to grasp it, but it passes each time when it's like this (in each thread, with 500 threads): 1. `while (!SUT.compareAndSet(false, true));` 2. `int oldValue = AtomicBooleanTest.globalCounter;` 3. `Thread.sleep(1);` 4. `SUT.set(false);` When all threads are done, globalCounter should be 500. I assume this is what you had in mind, right?"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"WhileStatementNode",
                        "expression":{
                          "type":"PrefixOperatorExpressionNode",
                          "operator":{
                            "type":"OperatorNode",
                            "symbol":"!",
                            "comments":[
                              
                            ]
                          },
                          "argument":{
                            "type":"MethodInvocationNode",
                            "qualifiedIdentifier":{
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"SUT",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"compareAndSet",
                              "comments":[
                                
                              ]
                            },
                            "args":{
                              "type":"ExpressionListNode",
                              "arguments":[
                                {
                                  "type":"LiteralNode",
                                  "node":{
                                    "type":"BooleanLiteralNode",
                                    "valueRep":"false"
                                  },
                                  "comments":[
                                    
                                  ]
                                },
                                {
                                  "type":"LiteralNode",
                                  "node":{
                                    "type":"BooleanLiteralNode",
                                    "valueRep":"true"
                                  },
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        "statement":{
                          "type":"EmptyStatementNode",
                          "comma":{
                            "type":"SeparatorNode",
                            "symbol":";",
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ]
                        },
                        "labels":[
                          
                        ],
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ExpressionStatement",
                        "expression":{
                          "type":"BinaryExpressionNode",
                          "operator":{
                            "type":"OperatorNode",
                            "symbol":"=",
                            "comments":[
                              
                            ]
                          },
                          "left":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"oldValue",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "right":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"AtomicBooleanTest",
                                "comments":[
                                  
                                ]
                              },
                              {
                                "type":"IdentifierNode",
                                "name":"globalCounter",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        "labels":[
                          
                        ]
                      },
                      {
                        "type":"MethodInvocationNode",
                        "qualifiedIdentifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"Thread",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"sleep",
                          "comments":[
                            
                          ]
                        },
                        "args":{
                          "type":"ExpressionListNode",
                          "arguments":[
                            {
                              "type":"LiteralNode",
                              "node":{
                                "type":"IntegerLiteralNode",
                                "valueRep":"1"
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"MethodInvocationNode",
                        "qualifiedIdentifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"SUT",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"set",
                          "comments":[
                            
                          ]
                        },
                        "args":{
                          "type":"ExpressionListNode",
                          "arguments":[
                            {
                              "type":"LiteralNode",
                              "node":{
                                "type":"BooleanLiteralNode",
                                "valueRep":"false"
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"globalCounter",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "test":1,
                        "assum":1,
                        "set":2,
                        "sleep":1,
                        "grasp":1,
                        "sut":2,
                        "global":2,
                        "thread":4,
                        "mind":1,
                        "interest":1,
                        "compar":1,
                        "true":1,
                        "pass":1,
                        "approach":1,
                        "fals":2,
                        "counter":2,
                        "atom":1,
                        "time":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        {
                          "type":"MethodInvocationNode",
                          "qualifiedIdentifier":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"SUT",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"compareAndSet",
                            "comments":[
                              
                            ]
                          },
                          "args":{
                            "type":"ExpressionListNode",
                            "arguments":[
                              {
                                "type":"LiteralNode",
                                "node":{
                                  "type":"BooleanLiteralNode",
                                  "valueRep":"false"
                                },
                                "comments":[
                                  
                                ]
                              },
                              {
                                "type":"LiteralNode",
                                "node":{
                                  "type":"BooleanLiteralNode",
                                  "valueRep":"true"
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"MethodInvocationNode",
                          "qualifiedIdentifier":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"Thread",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"sleep",
                            "comments":[
                              
                            ]
                          },
                          "args":{
                            "type":"ExpressionListNode",
                            "arguments":[
                              {
                                "type":"LiteralNode",
                                "node":{
                                  "type":"IntegerLiteralNode",
                                  "valueRep":"1"
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"MethodInvocationNode",
                          "qualifiedIdentifier":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"SUT",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"set",
                            "comments":[
                              
                            ]
                          },
                          "args":{
                            "type":"ExpressionListNode",
                            "arguments":[
                              {
                                "type":"LiteralNode",
                                "node":{
                                  "type":"BooleanLiteralNode",
                                  "valueRep":"false"
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25317061,
          "postId":17415401,
          "creationDate":"2013-07-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":741217,
            "displayName":"Rolf W.",
            "reputation":47
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"That makes sense, I think you're right. Since the test's logic is entirely CPU bound the computer would probably waste time managing threads that it could also use trying to get into a conflict. But I just realized that Thread.sleep() might be a factor too: I'd expect sleeping state to be idle time that could be utilized by adding more threads, is that right? That said, I did a quick test; When I run using exactly the number of available cores it utilizes nearly 100% - around the same when using 16 or 500 threads. That suggests sleep time is negligible. How does that work?"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415401-cu25317061]-[-509230792]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"That makes sense, I think you're right. Since the test's logic is entirely CPU bound the computer would probably waste time managing threads that it could also use trying to get into a conflict. But I just realized that Thread.sleep() might be a factor too: I'd expect sleeping state to be idle time that could be utilized by adding more threads, is that right? That said, I did a quick test; When I run using exactly the number of available cores it utilizes nearly 100% - around the same when using 16 or 500 threads. That suggests sleep time is negligible. How does that work?"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "sens":1,
                        "number":1,
                        "test":2,
                        "wast":1,
                        "util":2,
                        "state":1,
                        "conflict":1,
                        "suggest":1,
                        "run":1,
                        "sleep":3,
                        "work":1,
                        "logic":1,
                        "factor":1,
                        "idl":1,
                        "thread":4,
                        "bound":1,
                        "comput":1,
                        "expect":1,
                        "neglig":1,
                        "cpu":1,
                        "make":1,
                        "ad":1,
                        "quick":1,
                        "time":3,
                        "core":1,
                        "manag":1,
                        "realiz":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25317231,
          "postId":17415401,
          "creationDate":"2013-07-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1798593,
            "displayName":"Patricia Shanahan",
            "reputation":13624
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@RolfW. I don't know. What is the average time for an iteration?"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415401-cu25317231]-[-906159091]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@RolfW. I don't know. What is the average time for an iteration?"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"RolfW",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "averag":1,
                        "iter":1,
                        "time":1,
                        "rolf":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25362881,
          "postId":17415401,
          "creationDate":"2013-07-03",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":741217,
            "displayName":"Rolf W.",
            "reputation":47
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"With 2, 4, 6 and 7 threads it's consistently in the 1.1ms-1.2ms range, 4 threads being lowest at 1.1ms. 8 Threads is close to 2.0 (there are 8 cores). From there it goes up: 16 threads = 5.9, 32 threads = 7.4, etc. So a thread count just under the number of available cores seems ideal and apparently this sleep time couldn't be utilized after all. In all cases CPU use is ~40%-45% in user mode and about the same in system mode. The java process reads around 300%. Fans are revving up."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415401-cu25362881]-[1324962667]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"With 2, 4, 6 and 7 threads it's consistently in the 1.1ms-1.2ms range, 4 threads being lowest at 1.1ms. 8 Threads is close to 2.0 (there are 8 cores). From there it goes up: 16 threads = 5.9, 32 threads = 7.4, etc. So a thread count just under the number of available cores seems ideal and apparently this sleep time couldn't be utilized after all. In all cases CPU use is ~40%-45% in user mode and about the same in system mode. The java process reads around 300%. Fans are revving up."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "read":1,
                        "number":1,
                        "count":1,
                        "util":1,
                        "system":1,
                        "lowest":1,
                        "ideal":1,
                        "appar":1,
                        "revv":1,
                        "process":1,
                        "rang":1,
                        "sleep":1,
                        "fan":1,
                        "thread":6,
                        "consist":1,
                        "cpu":1,
                        "mode":2,
                        "time":1,
                        "case":1,
                        "core":2,
                        "close":1,
                        "user":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25362987,
          "postId":17415401,
          "creationDate":"2013-07-03",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":741217,
            "displayName":"Rolf W.",
            "reputation":47
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Interestingly, each time after some time (probably 60sec or so) the java process increases to nearly 800% and CPU changes to 99% in user mode. From that moment on the fans are nearly silent. I didn't test thoroughly, but it appears that it doesn't affect the time per iteration (just tried once). Just out of curiosity, what would cause this change? Is this where the vm compiles to native code?"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415401-cu25362987]-[-224437099]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Interestingly, each time after some time (probably 60sec or so) the java process increases to nearly 800% and CPU changes to 99% in user mode. From that moment on the fans are nearly silent. I didn't test thoroughly, but it appears that it doesn't affect the time per iteration (just tried once). Just out of curiosity, what would cause this change? Is this where the vm compiles to native code?"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "chang":1,
                        "test":1,
                        "silent":1,
                        "process":1,
                        "appear":1,
                        "affect":1,
                        "sec":1,
                        "fan":1,
                        "code":1,
                        "interest":1,
                        "iter":1,
                        "cpu":1,
                        "moment":1,
                        "increas":1,
                        "mode":1,
                        "compil":1,
                        "time":3,
                        "user":1,
                        "curios":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25363007,
          "postId":17415401,
          "creationDate":"2013-07-03",
          "score":1,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1798593,
            "displayName":"Patricia Shanahan",
            "reputation":13624
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Here's a suggestion for testing the test. Add a thread that occasionally and arbitrarily sets the AtomicBoolean to false. If the test is a good test, you will get some failures."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415401-cu25363007]-[-1074494730]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Here's a suggestion for testing the test. Add a thread that occasionally and arbitrarily sets the AtomicBoolean to false. If the test is a good test, you will get some failures."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"AtomicBoolean",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "test":4,
                        "failur":1,
                        "good":1,
                        "suggest":1,
                        "set":1,
                        "arbitrarili":1,
                        "thread":1,
                        "fals":1,
                        "atom":1,
                        "add":1,
                        "occasion":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"AtomicBoolean",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25529407,
          "postId":17415401,
          "creationDate":"2013-07-09",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":741217,
            "displayName":"Rolf W.",
            "reputation":47
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"A bit off-topic maybe, but do you have an idea what might be the reason for this change in CPU usage that happens after some time? Just curious."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415401-cu25529407]-[1985455526]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"A bit off-topic maybe, but do you have an idea what might be the reason for this change in CPU usage that happens after some time? Just curious."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "chang":1,
                        "bit":1,
                        "idea":1,
                        "reason":1,
                        "curious":1,
                        "cpu":1,
                        "usag":1,
                        "topic":1,
                        "time":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2013-07-01",
      "lastActivityDate":"2013-07-02",
      "lastEditDate":"2013-07-02",
      "score":3,
      "isAccepted":true,
      "owner":{
        "type":"StackOverflowUser",
        "id":1798593,
        "displayName":"Patricia Shanahan",
        "reputation":13624
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>I would concentrate on <code>compareAndSet</code>, which is the real difference between an <code>AtomicBoolean</code> and an ordinary <code>boolean</code>.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[17415401]-[-1769355948]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>I would concentrate on <code>compareAndSet</code>, which is the real difference between an <code>AtomicBoolean</code> and an ordinary <code>boolean</code>.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"compareAndSet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicBoolean",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "real":1,
                    "ordinari":1,
                    "differ":1,
                    "set":1,
                    "code":6,
                    "concentr":1,
                    "compar":1,
                    "atom":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicBoolean",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>For example, use <code>compareAndSet(false, true)</code> to control a critical region. Loop doing it until it returns false, then enter the critical region. In the critical region, do something that is very likely to fail if two or more threads run it at the same time. For example, increment a counter with a short sleep between reading the old value and writing the new value. At the end of the critical region, set the <code>AtomicBoolean</code> to false.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[17415401]-[947474057]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>For example, use <code>compareAndSet(false, true)</code> to control a critical region. Loop doing it until it returns false, then enter the critical region. In the critical region, do something that is very likely to fail if two or more threads run it at the same time. For example, increment a counter with a short sleep between reading the old value and writing the new value. At the end of the critical region, set the <code>AtomicBoolean</code> to false.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"compareAndSet",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicBoolean",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "fail":1,
                    "critic":4,
                    "loop":1,
                    "return":1,
                    "run":1,
                    "enter":1,
                    "set":2,
                    "sleep":1,
                    "code":4,
                    "thread":1,
                    "compar":1,
                    "true":1,
                    "region":4,
                    "end":1,
                    "fals":3,
                    "counter":1,
                    "control":1,
                    "atom":1,
                    "time":1,
                    "increment":1,
                    "write":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicBoolean",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Initialize the <code>AtomicBoolean</code> to false, and <code>globalCounter</code> to zero before starting the threads.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[17415401]-[1076014077]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Initialize the <code>AtomicBoolean</code> to false, and <code>globalCounter</code> to zero before starting the threads.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicBoolean",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"globalCounter",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "code":4,
                    "global":1,
                    "thread":1,
                    "fals":1,
                    "counter":1,
                    "initi":1,
                    "atom":1,
                    "start":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicBoolean",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"for(int i=0; i&lt;iterations; i++) { while (!AtomicBooleanTest.atomic.compareAndSet(false, true)); int oldValue = AtomicBooleanTest.globalCounter; Thread.sleep(1); AtomicBooleanTest.globalCounter = oldValue + 1; AtomicBooleanTest.atomic.set(false); } "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[17415401]-[-76824571]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ForLoopStatementNode",
                    "forControl":{
                      "type":"ForVarControlNode",
                      "variables":{
                        "type":"LocalVariableDeclarationStatementNode",
                        "modifiers":[
                          
                        ],
                        "declarators":{
                          "type":"VariableDeclaratorsNode",
                          "declarators":[
                            {
                              "type":"VariableDeclaratorNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"i",
                                "comments":[
                                  
                                ]
                              },
                              "arrayDepth":[
                                
                              ],
                              "assignment":{
                                "type":"VariableAssignmentNode",
                                "variableAssignment":{
                                  "type":"VariableExpressionInitNode",
                                  "expression":{
                                    "type":"LiteralNode",
                                    "node":{
                                      "type":"IntegerLiteralNode",
                                      "valueRep":"0"
                                    },
                                    "comments":[
                                      
                                    ]
                                  }
                                },
                                "comments":[
                                  
                                ]
                              },
                              "varType":{
                                "type":"PrimitiveTypeNode",
                                "name":"int",
                                "comments":[
                                  
                                ]
                              }
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "labels":[
                          
                        ],
                        "comments":[
                          
                        ]
                      },
                      "condition":{
                        "type":"BinaryExpressionNode",
                        "operator":{
                          "type":"OperatorNode",
                          "symbol":"<",
                          "comments":[
                            
                          ]
                        },
                        "left":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"i",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "right":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"iterations",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      "update":[
                        {
                          "type":"PostfixOperatorExpressionNode",
                          "argument":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"i",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "operator":{
                            "type":"OperatorNode",
                            "symbol":"++",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "statement":{
                      "type":"BlockNode",
                      "statements":[
                        {
                          "type":"WhileStatementNode",
                          "expression":{
                            "type":"PrefixOperatorExpressionNode",
                            "operator":{
                              "type":"OperatorNode",
                              "symbol":"!",
                              "comments":[
                                
                              ]
                            },
                            "argument":{
                              "type":"MethodInvocationNode",
                              "qualifiedIdentifier":{
                                "type":"QualifiedIdentifierNode",
                                "identifiers":[
                                  {
                                    "type":"IdentifierNode",
                                    "name":"AtomicBooleanTest",
                                    "comments":[
                                      
                                    ]
                                  },
                                  {
                                    "type":"IdentifierNode",
                                    "name":"atomic",
                                    "comments":[
                                      
                                    ]
                                  }
                                ],
                                "comments":[
                                  
                                ]
                              },
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"compareAndSet",
                                "comments":[
                                  
                                ]
                              },
                              "args":{
                                "type":"ExpressionListNode",
                                "arguments":[
                                  {
                                    "type":"LiteralNode",
                                    "node":{
                                      "type":"BooleanLiteralNode",
                                      "valueRep":"false"
                                    },
                                    "comments":[
                                      
                                    ]
                                  },
                                  {
                                    "type":"LiteralNode",
                                    "node":{
                                      "type":"BooleanLiteralNode",
                                      "valueRep":"true"
                                    },
                                    "comments":[
                                      
                                    ]
                                  }
                                ],
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "statement":{
                            "type":"EmptyStatementNode",
                            "comma":{
                              "type":"SeparatorNode",
                              "symbol":";",
                              "comments":[
                                
                              ]
                            },
                            "labels":[
                              
                            ]
                          },
                          "labels":[
                            
                          ],
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"LocalVariableDeclarationStatementNode",
                          "modifiers":[
                            
                          ],
                          "declarators":{
                            "type":"VariableDeclaratorsNode",
                            "declarators":[
                              {
                                "type":"VariableDeclaratorNode",
                                "identifier":{
                                  "type":"IdentifierNode",
                                  "name":"oldValue",
                                  "comments":[
                                    
                                  ]
                                },
                                "arrayDepth":[
                                  
                                ],
                                "assignment":{
                                  "type":"VariableAssignmentNode",
                                  "variableAssignment":{
                                    "type":"VariableExpressionInitNode",
                                    "expression":{
                                      "type":"QualifiedIdentifierNode",
                                      "identifiers":[
                                        {
                                          "type":"IdentifierNode",
                                          "name":"AtomicBooleanTest",
                                          "comments":[
                                            
                                          ]
                                        },
                                        {
                                          "type":"IdentifierNode",
                                          "name":"globalCounter",
                                          "comments":[
                                            
                                          ]
                                        }
                                      ],
                                      "comments":[
                                        
                                      ]
                                    }
                                  },
                                  "comments":[
                                    
                                  ]
                                },
                                "varType":{
                                  "type":"PrimitiveTypeNode",
                                  "name":"int",
                                  "comments":[
                                    
                                  ]
                                }
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ],
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"ExpressionStatement",
                          "expression":{
                            "type":"MethodInvocationNode",
                            "qualifiedIdentifier":{
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"Thread",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"sleep",
                              "comments":[
                                
                              ]
                            },
                            "args":{
                              "type":"ExpressionListNode",
                              "arguments":[
                                {
                                  "type":"LiteralNode",
                                  "node":{
                                    "type":"IntegerLiteralNode",
                                    "valueRep":"1"
                                  },
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ]
                        },
                        {
                          "type":"ExpressionStatement",
                          "expression":{
                            "type":"BinaryExpressionNode",
                            "operator":{
                              "type":"OperatorNode",
                              "symbol":"=",
                              "comments":[
                                
                              ]
                            },
                            "left":{
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"AtomicBooleanTest",
                                  "comments":[
                                    
                                  ]
                                },
                                {
                                  "type":"IdentifierNode",
                                  "name":"globalCounter",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "right":{
                              "type":"BinaryExpressionNode",
                              "operator":{
                                "type":"OperatorNode",
                                "symbol":"+",
                                "comments":[
                                  
                                ]
                              },
                              "left":{
                                "type":"QualifiedIdentifierNode",
                                "identifiers":[
                                  {
                                    "type":"IdentifierNode",
                                    "name":"oldValue",
                                    "comments":[
                                      
                                    ]
                                  }
                                ],
                                "comments":[
                                  
                                ]
                              },
                              "right":{
                                "type":"LiteralNode",
                                "node":{
                                  "type":"IntegerLiteralNode",
                                  "valueRep":"1"
                                },
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ]
                        },
                        {
                          "type":"ExpressionStatement",
                          "expression":{
                            "type":"MethodInvocationNode",
                            "qualifiedIdentifier":{
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"AtomicBooleanTest",
                                  "comments":[
                                    
                                  ]
                                },
                                {
                                  "type":"IdentifierNode",
                                  "name":"atomic",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"set",
                              "comments":[
                                
                              ]
                            },
                            "args":{
                              "type":"ExpressionListNode",
                              "arguments":[
                                {
                                  "type":"LiteralNode",
                                  "node":{
                                    "type":"BooleanLiteralNode",
                                    "valueRep":"false"
                                  },
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ]
                        }
                      ],
                      "labels":[
                        
                      ],
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "rawText":"for(int i=0; i<iterations; i++) { while (!AtomicBooleanTest.atomic.compareAndSet(false, true)); int oldValue = AtomicBooleanTest.globalCounter; Thread.sleep(1); AtomicBooleanTest.globalCounter = oldValue + 1; AtomicBooleanTest.atomic.set(false); } ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "test":4,
                    "set":2,
                    "sleep":1,
                    "global":2,
                    "thread":1,
                    "compar":1,
                    "iter":1,
                    "true":1,
                    "fals":2,
                    "counter":2,
                    "atom":6
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    {
                      "type":"PrimitiveTypeNode",
                      "name":"int",
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    {
                      "type":"MethodInvocationNode",
                      "qualifiedIdentifier":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"AtomicBooleanTest",
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"IdentifierNode",
                            "name":"atomic",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"compareAndSet",
                        "comments":[
                          
                        ]
                      },
                      "args":{
                        "type":"ExpressionListNode",
                        "arguments":[
                          {
                            "type":"LiteralNode",
                            "node":{
                              "type":"BooleanLiteralNode",
                              "valueRep":"false"
                            },
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"LiteralNode",
                            "node":{
                              "type":"BooleanLiteralNode",
                              "valueRep":"true"
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"MethodInvocationNode",
                      "qualifiedIdentifier":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"Thread",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"sleep",
                        "comments":[
                          
                        ]
                      },
                      "args":{
                        "type":"ExpressionListNode",
                        "arguments":[
                          {
                            "type":"LiteralNode",
                            "node":{
                              "type":"IntegerLiteralNode",
                              "valueRep":"1"
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"MethodInvocationNode",
                      "qualifiedIdentifier":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"AtomicBooleanTest",
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"IdentifierNode",
                            "name":"atomic",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"set",
                        "comments":[
                          
                        ]
                      },
                      "args":{
                        "type":"ExpressionListNode",
                        "arguments":[
                          {
                            "type":"LiteralNode",
                            "node":{
                              "type":"BooleanLiteralNode",
                              "valueRep":"false"
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    {
                      "type":"VariableDeclaratorNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"i",
                        "comments":[
                          
                        ]
                      },
                      "arrayDepth":[
                        
                      ],
                      "assignment":{
                        "type":"VariableAssignmentNode",
                        "variableAssignment":{
                          "type":"VariableExpressionInitNode",
                          "expression":{
                            "type":"LiteralNode",
                            "node":{
                              "type":"IntegerLiteralNode",
                              "valueRep":"0"
                            },
                            "comments":[
                              
                            ]
                          }
                        },
                        "comments":[
                          
                        ]
                      },
                      "varType":{
                        "type":"PrimitiveTypeNode",
                        "name":"int",
                        "comments":[
                          
                        ]
                      }
                    },
                    {
                      "type":"VariableDeclaratorNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"oldValue",
                        "comments":[
                          
                        ]
                      },
                      "arrayDepth":[
                        
                      ],
                      "assignment":{
                        "type":"VariableAssignmentNode",
                        "variableAssignment":{
                          "type":"VariableExpressionInitNode",
                          "expression":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"AtomicBooleanTest",
                                "comments":[
                                  
                                ]
                              },
                              {
                                "type":"IdentifierNode",
                                "name":"globalCounter",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          }
                        },
                        "comments":[
                          
                        ]
                      },
                      "varType":{
                        "type":"PrimitiveTypeNode",
                        "name":"int",
                        "comments":[
                          
                        ]
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>At the end, the <code>globalCounter</code> value should be <code>t*iterations</code> where <code>t</code> is the number of threads.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[17415401]-[-884037967]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>At the end, the <code>globalCounter</code> value should be <code>t*iterations</code> where <code>t</code> is the number of threads.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"globalCounter",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "number":1,
                    "code":6,
                    "global":1,
                    "thread":1,
                    "iter":1,
                    "end":1,
                    "counter":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The number of threads should be similar to the number the hardware can run simultaneously - and this is far more likely to fail on a multiprocessor than on a single processor. The highest risk of failure is immediately after the AtomicBoolean becomes false. All available processors should be simultaneously trying to get exclusive access to it, see it to be false, and atomically change it to true.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[17415401]-[-268643612]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The number of threads should be similar to the number the hardware can run simultaneously - and this is far more likely to fail on a multiprocessor than on a single processor. The highest risk of failure is immediately after the AtomicBoolean becomes false. All available processors should be simultaneously trying to get exclusive access to it, see it to be false, and atomically change it to true.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicBoolean",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "number":2,
                    "chang":1,
                    "singl":1,
                    "fail":1,
                    "exclus":1,
                    "similar":1,
                    "failur":1,
                    "simultan":2,
                    "run":1,
                    "risk":1,
                    "thread":1,
                    "highest":1,
                    "processor":2,
                    "hardwar":1,
                    "true":1,
                    "fals":2,
                    "atom":2,
                    "multiprocessor":1,
                    "immedi":1,
                    "access":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicBoolean",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":17415445,
      "questionId":17414924,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":25302139,
          "postId":17415445,
          "creationDate":"2013-07-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":139985,
            "displayName":"Stephen C",
            "reputation":291715
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@RolfW. - Unfortunately, no."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415445-cu25302139]-[-1270911332]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@RolfW. - Unfortunately, no."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"RolfW",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "rolf":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25307609,
          "postId":17415445,
          "creationDate":"2013-07-02",
          "score":2,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":139985,
            "displayName":"Stephen C",
            "reputation":291715
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@RolfW. - My solution was wrong. But that's not the point. The point is that *no amount of black box testing ALONE* should be sufficient to make you confident that an atomic primitive has been implemented correctly. The (hypothetical) bug may only show up in other tests ... or with a different compiler or OS version ... or on other hardware. Concurrency bugs are like that."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415445-cu25307609]-[-1656266778]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@RolfW. - My solution was wrong. But that's not the point. The point is that *no amount of black box testing ALONE* should be sufficient to make you confident that an atomic primitive has been implemented correctly. The (hypothetical) bug may only show up in other tests ... or with a different compiler or OS version ... or on other hardware. Concurrency bugs are like that."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"RolfW",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "test":2,
                        "point":2,
                        "show":1,
                        "concurr":1,
                        "hypothet":1,
                        "wrong":1,
                        "rolf":1,
                        "correct":1,
                        "amount":1,
                        "version":1,
                        "black":1,
                        "confid":1,
                        "suffici":1,
                        "bug":2,
                        "hardwar":1,
                        "implement":1,
                        "make":1,
                        "atom":1,
                        "box":1,
                        "compil":1,
                        "primit":1,
                        "solut":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25307706,
          "postId":17415445,
          "creationDate":"2013-07-02",
          "score":2,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":139985,
            "displayName":"Stephen C",
            "reputation":291715
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"You need to *combine* your testing with careful analysis of the source code ... preferably by a number of people including some who are skilled at low-level concurrency coding, and the language."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415445-cu25307706]-[-906892845]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"You need to *combine* your testing with careful analysis of the source code ... preferably by a number of people including some who are skilled at low-level concurrency coding, and the language."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "number":1,
                        "test":1,
                        "languag":1,
                        "concurr":1,
                        "care":1,
                        "includ":1,
                        "code":2,
                        "low":1,
                        "combin":1,
                        "skill":1,
                        "analysi":1,
                        "peopl":1,
                        "sourc":1,
                        "prefer":1,
                        "level":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25297415,
          "postId":17415445,
          "creationDate":"2013-07-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":741217,
            "displayName":"Rolf W.",
            "reputation":47
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Thanks yshavit. That test passes each time, even when running the test in a loop 1.000 times using 1.500 threads. Here's the code I used: `final boolean valueUpdated;` `valueUpdated = SUT.compareAndSet(true, false);` `if (valueUpdated) valueUpdatedCount.incrementAndGet();` Can I be confident that this isn't a false positive?"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415445-cu25297415]-[-1328700237]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Thanks yshavit. That test passes each time, even when running the test in a loop 1.000 times using 1.500 threads. Here's the code I used: `final boolean valueUpdated;` `valueUpdated = SUT.compareAndSet(true, false);` `if (valueUpdated) valueUpdatedCount.incrementAndGet();` Can I be confident that this isn't a false positive?"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"valueUpdated",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ExpressionStatement",
                        "expression":{
                          "type":"BinaryExpressionNode",
                          "operator":{
                            "type":"OperatorNode",
                            "symbol":"=",
                            "comments":[
                              
                            ]
                          },
                          "left":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"valueUpdated",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "right":{
                            "type":"MethodInvocationNode",
                            "qualifiedIdentifier":{
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"SUT",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"compareAndSet",
                              "comments":[
                                
                              ]
                            },
                            "args":{
                              "type":"ExpressionListNode",
                              "arguments":[
                                {
                                  "type":"LiteralNode",
                                  "node":{
                                    "type":"BooleanLiteralNode",
                                    "valueRep":"true"
                                  },
                                  "comments":[
                                    
                                  ]
                                },
                                {
                                  "type":"LiteralNode",
                                  "node":{
                                    "type":"BooleanLiteralNode",
                                    "valueRep":"false"
                                  },
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        "labels":[
                          
                        ]
                      },
                      {
                        "type":"IfStatementNode",
                        "expression":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"valueUpdated",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "statement":{
                          "type":"ExpressionStatement",
                          "expression":{
                            "type":"MethodInvocationNode",
                            "qualifiedIdentifier":{
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"valueUpdatedCount",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"incrementAndGet",
                              "comments":[
                                
                              ]
                            },
                            "args":{
                              "type":"ExpressionListNode",
                              "arguments":[
                                
                              ],
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ]
                        },
                        "labels":[
                          
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "test":2,
                        "count":1,
                        "loop":1,
                        "run":1,
                        "set":1,
                        "updat":4,
                        "sut":1,
                        "code":1,
                        "thread":1,
                        "confid":1,
                        "compar":1,
                        "posit":1,
                        "isn":1,
                        "yshavit":1,
                        "true":1,
                        "pass":1,
                        "fals":2,
                        "time":2,
                        "increment":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        {
                          "type":"MethodInvocationNode",
                          "qualifiedIdentifier":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"SUT",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"compareAndSet",
                            "comments":[
                              
                            ]
                          },
                          "args":{
                            "type":"ExpressionListNode",
                            "arguments":[
                              {
                                "type":"LiteralNode",
                                "node":{
                                  "type":"BooleanLiteralNode",
                                  "valueRep":"true"
                                },
                                "comments":[
                                  
                                ]
                              },
                              {
                                "type":"LiteralNode",
                                "node":{
                                  "type":"BooleanLiteralNode",
                                  "valueRep":"false"
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"MethodInvocationNode",
                          "qualifiedIdentifier":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"valueUpdatedCount",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"incrementAndGet",
                            "comments":[
                              
                            ]
                          },
                          "args":{
                            "type":"ExpressionListNode",
                            "arguments":[
                              
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25303880,
          "postId":17415445,
          "creationDate":"2013-07-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":741217,
            "displayName":"Rolf W.",
            "reputation":47
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@Stephen Currently I've implemented both yshavit's solution and the one proposed by Patricia Shanahan with many threads and iterations. AtomicBoolean will be used in ordinary mobile and web apps, nothing scientific or too mathematical. Having tested it like this, would you say there is a significant enough likelihood of bugs in apps like that? If unlikely then I'll settle on this. Otherwise, could you explain a bit more about your solution?"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415445-cu25303880]-[-1773367449]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@Stephen Currently I've implemented both yshavit's solution and the one proposed by Patricia Shanahan with many threads and iterations. AtomicBoolean will be used in ordinary mobile and web apps, nothing scientific or too mathematical. Having tested it like this, would you say there is a significant enough likelihood of bugs in apps like that? If unlikely then I'll settle on this. Otherwise, could you explain a bit more about your solution?"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"Stephen",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"AtomicBoolean",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "likelihood":1,
                        "shanahan":1,
                        "test":1,
                        "bit":1,
                        "explain":1,
                        "ordinari":1,
                        "propos":1,
                        "scientif":1,
                        "settl":1,
                        "web":1,
                        "thread":1,
                        "bug":1,
                        "signific":1,
                        "iter":1,
                        "yshavit":1,
                        "implement":1,
                        "app":2,
                        "stephen":1,
                        "atom":1,
                        "mathemat":1,
                        "mobil":1,
                        "solut":2,
                        "patricia":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"AtomicBoolean",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":25312575,
          "postId":17415445,
          "creationDate":"2013-07-02",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1076640,
            "displayName":"yshavit",
            "reputation":16769
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"As others have said, concurrency bugs are ones you can't realistically test to full confidence -- you need to prove it analytically. That said, take a look at [AtomicBoolean's implementation](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/util/concurrent/atomic/AtomicBoolean.java) and you'll see it's not very helpful. It comes down to a call to `unsafe.compareAndSwapInt`, which is native. Basically, this is a case where you have to trust the good folks at Oracle to have done their job right."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[17415445-cu25312575]-[-2037742557]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"As others have said, concurrency bugs are ones you can't realistically test to full confidence -- you need to prove it analytically. That said, take a look at [AtomicBoolean's implementation](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/util/concurrent/atomic/AtomicBoolean.java) and you'll see it's not very helpful. It comes down to a call to `unsafe.compareAndSwapInt`, which is native. Basically, this is a case where you have to trust the good folks at Oracle to have done their job right."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"AtomicBoolean",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"unsafe",
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"IdentifierNode",
                            "name":"compareAndSwapInt",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "openjdk":1,
                        "test":1,
                        "prove":1,
                        "concurr":2,
                        "util":1,
                        "root":1,
                        "good":1,
                        "trust":1,
                        "folk":1,
                        "full":1,
                        "job":1,
                        "oracl":1,
                        "repositori":1,
                        "grepcod":2,
                        "analyt":1,
                        "help":1,
                        "confid":1,
                        "bug":1,
                        "realist":1,
                        "compar":1,
                        "implement":1,
                        "swap":1,
                        "file":1,
                        "atom":3,
                        "unsaf":1,
                        "basic":1,
                        "http":1,
                        "call":1,
                        "jdk":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        {
                          "type":"ReferenceTypeNode",
                          "ids":[
                            {
                              "type":"ParameterizedTypeNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"AtomicBoolean",
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2013-07-01",
      "lastActivityDate":"2013-07-01",
      "score":3,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":1076640,
        "displayName":"yshavit",
        "reputation":16769
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>I think it's going to be harder to test this than an <code>AtomicInteger</code>, as you point out. The space of possible values is much smaller, and thus the space of possible things-that-can-go-wrong is much smaller. Since tests like this basically come down to luck (with lots of looping to increase your chances), it's going to be harder to hit that smaller target.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[17415445]-[-1987568403]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>I think it's going to be harder to test this than an <code>AtomicInteger</code>, as you point out. The space of possible values is much smaller, and thus the space of possible things-that-can-go-wrong is much smaller. Since tests like this basically come down to luck (with lots of looping to increase your chances), it's going to be harder to hit that smaller target.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicInteger",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "test":2,
                    "point":1,
                    "loop":1,
                    "wrong":1,
                    "luck":1,
                    "hit":1,
                    "thing":1,
                    "code":2,
                    "space":2,
                    "valu":1,
                    "increas":1,
                    "lot":1,
                    "target":1,
                    "smaller":3,
                    "atom":1,
                    "basic":1,
                    "harder":2,
                    "chanc":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicInteger",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>My recommendation would be to launch a lot of threads that have access to a single <code>AtomicBoolean</code>. Have each one of them do a CAS, and <em>only</em> if they succeed, atomically increment an <code>AtomicInteger</code>. When all the threads have finished, you should see just a single increment to that <code>AtomicInteger</code>. Then just rinse, lather, repeat.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[17415445]-[1231492105]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>My recommendation would be to launch a lot of threads that have access to a single <code>AtomicBoolean</code>. Have each one of them do a CAS, and <em>only</em> if they succeed, atomically increment an <code>AtomicInteger</code>. When all the threads have finished, you should see just a single increment to that <code>AtomicInteger</code>. Then just rinse, lather, repeat.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "launch":1,
                    "succeed":1,
                    "recommend":1,
                    "singl":2,
                    "cas":1,
                    "finish":1,
                    "code":6,
                    "rins":1,
                    "thread":2,
                    "lot":1,
                    "atom":4,
                    "repeat":1,
                    "lather":1,
                    "increment":2,
                    "access":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":17415094,
      "questionId":17414924,
      "comments":[
        
      ],
      "creationDate":"2013-07-01",
      "lastActivityDate":"2013-07-01",
      "score":1,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":57695,
        "displayName":"Peter Lawrey",
        "reputation":257803
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>It is four atomic operations. Given you just want one boolean to be the inverse of the other, just have one boolean and keep toggling that. You can calculate the other from this value.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[17415094]-[-1345822087]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>It is four atomic operations. Given you just want one boolean to be the inverse of the other, just have one boolean and keep toggling that. You can calculate the other from this value.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "invers":1,
                    "calcul":1,
                    "oper":1,
                    "atom":1,
                    "toggl":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}