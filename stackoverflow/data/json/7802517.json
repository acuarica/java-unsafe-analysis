{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":7802517,
    "title":"Structural Different trees java",
    "comments":[
      {
        "type":"StackOverflowComment",
        "id":9506712,
        "postId":7802517,
        "creationDate":"2011-10-18",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":630136,
          "displayName":"G_H",
          "reputation":6364
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"Is it homework? No probs asking for help, but if it is it's considered proper to tag it as such."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[7802517-cu9506712]-[-1734063551]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"Is it homework? No probs asking for help, but if it is it's considered proper to tag it as such."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "proper":1,
                      "tag":1,
                      "prob":1,
                      "consid":1,
                      "homework":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":9507185,
        "postId":7802517,
        "creationDate":"2011-10-18",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":1000381,
          "displayName":"programmingnewb",
          "reputation":31
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"It was originally but the due date for it has been and i want to know how to how to do it as it might be helpful for revision"
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[7802517-cu9507185]-[1561154549]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"It was originally but the due date for it has been and i want to know how to how to do it as it might be helpful for revision"
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "due":1,
                      "revis":1,
                      "help":1,
                      "date":1,
                      "origin":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "tags":[
      "java"
    ],
    "creationDate":"2011-10-18",
    "lastActivityDate":"2011-10-18",
    "lastEditDate":"2011-10-18",
    "score":0,
    "viewCount":436,
    "owner":{
      "type":"StackOverflowUser",
      "id":1000381,
      "displayName":"programmingnewb",
      "reputation":31
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I have been working on this for a couple of weeks now and have not got any where at all. I am trying to make a application that takes as input 2 integers <em>n</em> and <em>k</em>. The application should generate and outputs the number of all trees with i nodes that are structurally different. At the end it should output the k-th tree with n nodes.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[7802517]-[-204687000]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I have been working on this for a couple of weeks now and have not got any where at all. I am trying to make a application that takes as input 2 integers <em>n</em> and <em>k</em>. The application should generate and outputs the number of all trees with i nodes that are structurally different. At the end it should output the k-th tree with n nodes.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "number":1,
                  "work":1,
                  "structur":1,
                  "week":1,
                  "integ":1,
                  "coupl":1,
                  "take":1,
                  "applic":2,
                  "generat":1,
                  "make":1,
                  "end":1,
                  "tree":2,
                  "node":2,
                  "output":2,
                  "input":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I have an example:</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[7802517]-[-1385263635]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I have an example:</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Entered the following in the termial:</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[7802517]-[1392044908]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Entered the following in the termial:</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "enter":1,
                  "termial":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p><strong><code>java differentTrees 5 31</code></strong></p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[7802517]-[909119568]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p><strong><code>java differentTrees 5 31</code></strong></p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"QualifiedIdentifierNode",
                  "identifiers":[
                    {
                      "type":"IdentifierNode",
                      "name":"differentTrees",
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "strong":2,
                  "code":2,
                  "tree":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>and the result is:</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[7802517]-[-1142409264]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>and the result is:</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "result":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlNode",
          "name":{
            "type":"XmlNameNode",
            "value":"pre"
          },
          "attributes":[
            
          ],
          "elements":[
            {
              "type":"XmlNode",
              "name":{
                "type":"XmlNameNode",
                "value":"code"
              },
              "attributes":[
                
              ],
              "elements":[
                {
                  "type":"XmlTextNode",
                  "contents":"The number of structural different trees with 0 nodes is 0 The number of structural different trees with 1 nodes is 1 The number of structural different trees with 2 nodes is 2 The number of structural different trees with 3 nodes is 5 The number of structural different trees with 4 nodes is 14 The number of structural different trees with 5 nodes is 42 &lt;BinaryTreeNode 5 &lt;BinaryTreeNode 1 --&gt; &lt;BinaryTreeNode 3 &lt;BinaryTreeNode 2 &lt;BinaryTreeNode 1 --&gt;-&gt;-&gt;&gt; "
                }
              ]
            }
          ]
        },
        "units":[
          {
            "type":"StructuredFragmentUnit",
            "id":"[7802517]-[-1738999589]",
            "astNode":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"TextFragmentNode",
                  "text":"The number of structural different trees with 0 nodes is 0 The number of structural different trees with 1 nodes is 1 The number of structural different trees with 2 nodes is 2 The number of structural different trees with 3 nodes is 5 The number of structural different trees with 4 nodes is 14 The number of structural different trees with 5 nodes is 42 <"
                },
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"BinaryTreeNode",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                },
                {
                  "type":"TextFragmentNode",
                  "text":"5 <"
                },
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"BinaryTreeNode",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                },
                {
                  "type":"TextFragmentNode",
                  "text":"1 --> <"
                },
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"BinaryTreeNode",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                },
                {
                  "type":"TextFragmentNode",
                  "text":"3 <"
                },
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"BinaryTreeNode",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                },
                {
                  "type":"TextFragmentNode",
                  "text":"2 <"
                },
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"BinaryTreeNode",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                },
                {
                  "type":"TextFragmentNode",
                  "text":"1 -->->->> "
                }
              ]
            },
            "rawText":"The number of structural different trees with 0 nodes is 0 The number of structural different trees with 1 nodes is 1 The number of structural different trees with 2 nodes is 2 The number of structural different trees with 3 nodes is 5 The number of structural different trees with 4 nodes is 14 The number of structural different trees with 5 nodes is 42 <BinaryTreeNode 5 <BinaryTreeNode 1 --> <BinaryTreeNode 3 <BinaryTreeNode 2 <BinaryTreeNode 1 -->->->> ",
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "number":6,
                  "binari":5,
                  "structur":6,
                  "tree":11,
                  "node":11
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"BinaryTreeNode",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I have to use the code from the BinaryTreeNode Class:</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[7802517]-[356864186]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I have to use the code from the BinaryTreeNode Class:</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"ReferenceTypeNode",
                  "ids":[
                    {
                      "type":"ParameterizedTypeNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"BinaryTreeNode",
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "node":1,
                  "binari":1,
                  "code":1,
                  "tree":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"BinaryTreeNode",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlNode",
          "name":{
            "type":"XmlNameNode",
            "value":"pre"
          },
          "attributes":[
            
          ],
          "elements":[
            {
              "type":"XmlNode",
              "name":{
                "type":"XmlNameNode",
                "value":"code"
              },
              "attributes":[
                
              ],
              "elements":[
                {
                  "type":"XmlTextNode",
                  "contents":"import java.lang.Math; public class BinaryTreeNode { protected Object val; // value associated with node protected BinaryTreeNode parent; // parent of node protected BinaryTreeNode left; // left child of node protected BinaryTreeNode right; // right child of node public BinaryTreeNode(Object value) // post: returns a tree referencing value with two null subtrees { val = value; parent = left = right = null; } public BinaryTreeNode(Object value, BinaryTreeNode left, BinaryTreeNode right) // post: returns a node referencing value &amp; subtrees { this(value); setLeft(left); setRight(right); } public BinaryTreeNode left() // post: returns reference to left subtree, or null { return left; } public BinaryTreeNode right() // post: returns reference to right subtree, or null { return right; } public BinaryTreeNode parent() // post: returns reference to parent node, or null { return parent; } public void setLeft(BinaryTreeNode newLeft) // post: sets left subtree to newLeft // re-parents newLeft if not null { if (left != null &amp;&amp; (left.parent() == this)) left.setParent(null); left = newLeft; if (left != null) left.setParent(this); } public void setRight(BinaryTreeNode newRight) // post: sets left subtree to newRight // re-parents newRight if not null { if (right != null &amp;&amp; (right.parent() == this)) right.setParent(null); right = newRight; if (right != null) right.setParent(this); } protected void setParent(BinaryTreeNode newParent) // post: re-parents this node to parent reference, or null { parent = newParent; } public static int size(BinaryTreeNode n) // post: returns the size of the subtree rooted at n { if (n == null) return 0; return size(n.left()) + size(n.right()) + 1; } public static BinaryTreeNode root(BinaryTreeNode n) // post: returns the root of the tree node n { if ((n == null) || (n.parent() == null)) return n; else return root(n.parent()); } public static int height(BinaryTreeNode n) // post: returns the height of a node n in its tree { if (n == null) return -1; return 1 + Math.max(height(n.left()),height(n.right())); } public static int depth(BinaryTreeNode n) // post: returns the depth of a node in the tree { if (n == null) return -1; return 1 + depth(n.parent()); } public static boolean isFull(BinaryTreeNode n) // post: returns true iff the tree rooted at n is full. { if (n == null) return true; if (height(n.left()) != height(n.right())) return false; return isFull(n.left()) &amp;&amp; isFull(n.right()); } public static boolean isComplete(BinaryTreeNode n) // post: returns true iff the tree rooted at n is complete { int leftHeight, rightHeight; boolean leftIsFull, rightIsFull; boolean leftIsComplete, rightIsComplete; if (n == null) return true; leftHeight = height(n.left()); rightHeight = height(n.right()); leftIsFull = isFull(n.left()); rightIsFull = isFull(n.right()); leftIsComplete = isComplete(n.left()); rightIsComplete = isComplete(n.right()); // case 1: left is full, right is complete, heights same if (leftIsFull &amp;&amp; rightIsComplete &amp;&amp; (leftHeight == rightHeight)) return true; // case 2: left is complete, right is full, heights differ if (leftIsComplete &amp;&amp; rightIsFull &amp;&amp; (leftHeight == (rightHeight + 1))) return true; return false; } public static boolean isBalanced(BinaryTreeNode n) // post: returns true iff the tree rooted at n is balanced { if (n == null) return true; return (Math.abs(height(n.left())-height(n.right())) &lt;= 1) &amp;&amp; isBalanced(n.left()) &amp;&amp; isBalanced(n.right()); } public boolean isLeftChild() // post: returns true if this is a left child of parent. { if (parent() == null) return false; return this == parent().left(); } public boolean isRightChild() // post: returns true if this is a right child of parent. { if (parent() == null) return false; return this == parent().right(); } public Object value() // post: returns value associated with this node. { return val; } public void setValue(Object value) // post: sets the value associated with this node { val = value; } public String toString() // post: returns string representation { StringBuffer s = new StringBuffer(); s.append(&quot;&lt;BinaryTreeNode &quot;+value()); if (left != null) s.append(&quot; &quot;+left()); else s.append(&quot; -&quot;); if (right != null) s.append(&quot; &quot;+right()); else s.append(&quot; -&quot;); s.append('&gt;'); return s.toString(); } } "
                }
              ]
            }
          ]
        },
        "units":[
          {
            "type":"StructuredFragmentUnit",
            "id":"[7802517]-[117905860]",
            "astNode":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"CompilationUnitNode",
                  "imports":[
                    {
                      "type":"ImportDeclarationNode",
                      "identifier":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"java",
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"IdentifierNode",
                            "name":"lang",
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"IdentifierNode",
                            "name":"Math",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "isStatic":false,
                      "isOnDemand":false,
                      "comments":[
                        
                      ]
                    }
                  ],
                  "typeDeclarations":[
                    {
                      "type":"ClassDeclarationNode",
                      "modifiers":[
                        {
                          "type":"KeywordModifierNode",
                          "value":"public",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"BinaryTreeNode",
                        "comments":[
                          
                        ]
                      },
                      "body":{
                        "type":"ClassBodyNode",
                        "declarations":[
                          {
                            "type":"FieldDeclaratorNode",
                            "modifiers":[
                              {
                                "type":"KeywordModifierNode",
                                "value":"protected",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "variables":{
                              "type":"VariableDeclaratorsNode",
                              "declarators":[
                                {
                                  "type":"VariableDeclaratorNode",
                                  "identifier":{
                                    "type":"IdentifierNode",
                                    "name":"val",
                                    "comments":[
                                      
                                    ]
                                  },
                                  "arrayDepth":[
                                    
                                  ],
                                  "varType":{
                                    "type":"ReferenceTypeNode",
                                    "ids":[
                                      {
                                        "type":"ParameterizedTypeNode",
                                        "identifier":{
                                          "type":"IdentifierNode",
                                          "name":"Object",
                                          "comments":[
                                            
                                          ]
                                        },
                                        "comments":[
                                          
                                        ]
                                      }
                                    ],
                                    "comments":[
                                      
                                    ]
                                  }
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              {
                                "text":"// value associated with node protected BinaryTreeNode parent; // parent of node protected BinaryTreeNode left; // left child of node protected BinaryTreeNode right; // right child of node public BinaryTreeNode(Object value) // post: returns a tree referencing value with two null subtrees { val = value; parent = left = right = null; } public BinaryTreeNode(Object value, BinaryTreeNode left, BinaryTreeNode right) // post: returns a node referencing value & subtrees { this(value); setLeft(left); setRight(right); } public BinaryTreeNode left() // post: returns reference to left subtree, or null { return left; } public BinaryTreeNode right() // post: returns reference to right subtree, or null { return right; } public BinaryTreeNode parent() // post: returns reference to parent node, or null { return parent; } public void setLeft(BinaryTreeNode newLeft) // post: sets left subtree to newLeft // re-parents newLeft if not null { if (left != null && (left.parent() == this)) left.setParent(null); left = newLeft; if (left != null) left.setParent(this); } public void setRight(BinaryTreeNode newRight) // post: sets left subtree to newRight // re-parents newRight if not null { if (right != null && (right.parent() == this)) right.setParent(null); right = newRight; if (right != null) right.setParent(this); } protected void setParent(BinaryTreeNode newParent) // post: re-parents this node to parent reference, or null { parent = newParent; } public static int size(BinaryTreeNode n) // post: returns the size of the subtree rooted at n { if (n == null) return 0; return size(n.left()) + size(n.right()) + 1; } public static BinaryTreeNode root(BinaryTreeNode n) // post: returns the root of the tree node n { if ((n == null) || (n.parent() == null)) return n; else return root(n.parent()); } public static int height(BinaryTreeNode n) // post: returns the height of a node n in its tree { if (n == null) return -1; return 1 + Math.max(height(n.left()),height(n.right())); } public static int depth(BinaryTreeNode n) // post: returns the depth of a node in the tree { if (n == null) return -1; return 1 + depth(n.parent()); } public static boolean isFull(BinaryTreeNode n) // post: returns true iff the tree rooted at n is full. { if (n == null) return true; if (height(n.left()) != height(n.right())) return false; return isFull(n.left()) && isFull(n.right()); } public static boolean isComplete(BinaryTreeNode n) // post: returns true iff the tree rooted at n is complete { int leftHeight, rightHeight; boolean leftIsFull, rightIsFull; boolean leftIsComplete, rightIsComplete; if (n == null) return true; leftHeight = height(n.left()); rightHeight = height(n.right()); leftIsFull = isFull(n.left()); rightIsFull = isFull(n.right()); leftIsComplete = isComplete(n.left()); rightIsComplete = isComplete(n.right()); // case 1: left is full, right is complete, heights same if (leftIsFull && rightIsComplete && (leftHeight == rightHeight)) return true; // case 2: left is complete, right is full, heights differ if (leftIsComplete && rightIsFull && (leftHeight == (rightHeight + 1))) return true; return false; } public static boolean isBalanced(BinaryTreeNode n) // post: returns true iff the tree rooted at n is balanced { if (n == null) return true; return (Math.abs(height(n.left())-height(n.right())) <= 1) && isBalanced(n.left()) && isBalanced(n.right()); } public boolean isLeftChild() // post: returns true if this is a left child of parent. { if (parent() == null) return false; return this == parent().left(); } public boolean isRightChild() // post: returns true if this is a right child of parent. { if (parent() == null) return false; return this == parent().right(); } public Object value() // post: returns value associated with this node. { return val; } public void setValue(Object value) // post: sets the value associated with this node { val = value; } public String toString() // post: returns string representation { StringBuffer s = new StringBuffer(); s.append(\"<BinaryTreeNode \"+value()); if (left != null) s.append(\" \"+left()); else s.append(\" -\"); if (right != null) s.append(\" \"+right()); else s.append(\" -\"); s.append('>'); return s.toString(); } } \n"
                              }
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "labels":[
                        
                      ],
                      "comments":[
                        
                      ]
                    }
                  ]
                }
              ]
            },
            "rawText":"import java.lang.Math; public class BinaryTreeNode { protected Object val; // value associated with node protected BinaryTreeNode parent; // parent of node protected BinaryTreeNode left; // left child of node protected BinaryTreeNode right; // right child of node public BinaryTreeNode(Object value) // post: returns a tree referencing value with two null subtrees { val = value; parent = left = right = null; } public BinaryTreeNode(Object value, BinaryTreeNode left, BinaryTreeNode right) // post: returns a node referencing value & subtrees { this(value); setLeft(left); setRight(right); } public BinaryTreeNode left() // post: returns reference to left subtree, or null { return left; } public BinaryTreeNode right() // post: returns reference to right subtree, or null { return right; } public BinaryTreeNode parent() // post: returns reference to parent node, or null { return parent; } public void setLeft(BinaryTreeNode newLeft) // post: sets left subtree to newLeft // re-parents newLeft if not null { if (left != null && (left.parent() == this)) left.setParent(null); left = newLeft; if (left != null) left.setParent(this); } public void setRight(BinaryTreeNode newRight) // post: sets left subtree to newRight // re-parents newRight if not null { if (right != null && (right.parent() == this)) right.setParent(null); right = newRight; if (right != null) right.setParent(this); } protected void setParent(BinaryTreeNode newParent) // post: re-parents this node to parent reference, or null { parent = newParent; } public static int size(BinaryTreeNode n) // post: returns the size of the subtree rooted at n { if (n == null) return 0; return size(n.left()) + size(n.right()) + 1; } public static BinaryTreeNode root(BinaryTreeNode n) // post: returns the root of the tree node n { if ((n == null) || (n.parent() == null)) return n; else return root(n.parent()); } public static int height(BinaryTreeNode n) // post: returns the height of a node n in its tree { if (n == null) return -1; return 1 + Math.max(height(n.left()),height(n.right())); } public static int depth(BinaryTreeNode n) // post: returns the depth of a node in the tree { if (n == null) return -1; return 1 + depth(n.parent()); } public static boolean isFull(BinaryTreeNode n) // post: returns true iff the tree rooted at n is full. { if (n == null) return true; if (height(n.left()) != height(n.right())) return false; return isFull(n.left()) && isFull(n.right()); } public static boolean isComplete(BinaryTreeNode n) // post: returns true iff the tree rooted at n is complete { int leftHeight, rightHeight; boolean leftIsFull, rightIsFull; boolean leftIsComplete, rightIsComplete; if (n == null) return true; leftHeight = height(n.left()); rightHeight = height(n.right()); leftIsFull = isFull(n.left()); rightIsFull = isFull(n.right()); leftIsComplete = isComplete(n.left()); rightIsComplete = isComplete(n.right()); // case 1: left is full, right is complete, heights same if (leftIsFull && rightIsComplete && (leftHeight == rightHeight)) return true; // case 2: left is complete, right is full, heights differ if (leftIsComplete && rightIsFull && (leftHeight == (rightHeight + 1))) return true; return false; } public static boolean isBalanced(BinaryTreeNode n) // post: returns true iff the tree rooted at n is balanced { if (n == null) return true; return (Math.abs(height(n.left())-height(n.right())) <= 1) && isBalanced(n.left()) && isBalanced(n.right()); } public boolean isLeftChild() // post: returns true if this is a left child of parent. { if (parent() == null) return false; return this == parent().left(); } public boolean isRightChild() // post: returns true if this is a right child of parent. { if (parent() == null) return false; return this == parent().right(); } public Object value() // post: returns value associated with this node. { return val; } public void setValue(Object value) // post: sets the value associated with this node { val = value; } public String toString() // post: returns string representation { StringBuffer s = new StringBuffer(); s.append(\"<BinaryTreeNode \"+value()); if (left != null) s.append(\" \"+left()); else s.append(\" -\"); if (right != null) s.append(\" \"+right()); else s.append(\" -\"); s.append('>'); return s.toString(); } } \n...\n}",
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "balanc":4,
                  "parent":29,
                  "post":20,
                  "represent":1,
                  "size":4,
                  "root":7,
                  "return":16,
                  "differ":1,
                  "set":13,
                  "full":14,
                  "binari":23,
                  "left":48,
                  "height":20,
                  "ab":1,
                  "buffer":2,
                  "object":5,
                  "child":6,
                  "math":3,
                  "max":1,
                  "refer":4,
                  "true":10,
                  "fals":4,
                  "tree":30,
                  "depth":3,
                  "node":35,
                  "subtre":7,
                  "complet":12,
                  "lang":1,
                  "iff":3,
                  "referenc":2,
                  "val":4,
                  "append":6
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"java",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"lang",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"Math",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "simpleTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"Object",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  {
                    "type":"VariableDeclaratorNode",
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"val",
                      "comments":[
                        
                      ]
                    },
                    "arrayDepth":[
                      
                    ],
                    "varType":{
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"Object",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I found out that the numbers are increasing like catalan numbers but can't figure out how to get the output</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[7802517]-[-986748403]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I found out that the numbers are increasing like catalan numbers but can't figure out how to get the output</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "number":2,
                  "catalan":1,
                  "found":1,
                  "increas":1,
                  "figur":1,
                  "output":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Thanks for the help in advance.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[7802517]-[-1335872260]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Thanks for the help in advance.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "advanc":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":7803989,
      "questionId":7802517,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":11130671,
          "postId":7803989,
          "creationDate":"2012-01-17",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":1146259,
            "displayName":"Alex",
            "reputation":1155
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"+1 Excellent explanation of the process of solving the problem without giving away the code!"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[7803989-cu11130671]-[-1213423922]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"+1 Excellent explanation of the process of solving the problem without giving away the code!"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "solv":1,
                        "problem":1,
                        "process":1,
                        "code":1,
                        "excel":1,
                        "explan":1,
                        "give":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":12725056,
          "postId":7803989,
          "creationDate":"2012-04-01",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":729282,
            "displayName":"Paaske",
            "reputation":2060
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"+1 for probably the most pedagogic and comprehensive answer I've seen on SO! Well written and right to the point! Kudos for not revealing any code too :-)"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[7803989-cu12725056]-[-827682969]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"+1 for probably the most pedagogic and comprehensive answer I've seen on SO! Well written and right to the point! Kudos for not revealing any code too :-)"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "kudo":1,
                        "point":1,
                        "reveal":1,
                        "pedagog":1,
                        "code":1,
                        "comprehens":1,
                        "written":1,
                        "answer":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2011-10-18",
      "lastActivityDate":"2011-10-18",
      "score":4,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":630136,
        "displayName":"G_H",
        "reputation":6364
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>First of all, there's a couple of pieces of additional info that would be needed. Namely:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-1034584482]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>First of all, there's a couple of pieces of additional info that would be needed. Namely:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "addit":1,
                    "info":1,
                    "need":1,
                    "coupl":1,
                    "piec":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<ul> \n <li>What's the allowed tree form? Judging from the given class, it's a binary tree where each node is allowed to have 0, 1 or 2 child nodes, so I'll go with this assumption.</li> \n <li>What constitutes a &quot;structurally different tree&quot;? Are two trees that are each other's mirror image structurally different? I'll assume that two trees are structurally different if they are not entirely identical.</li> \n</ul>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[1178534306]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<ul> \n <li>What's the allowed tree form? Judging from the given class, it's a binary tree where each node is allowed to have 0, 1 or 2 child nodes, so I'll go with this assumption.</li> \n <li>What constitutes a &quot;structurally different tree&quot;? Are two trees that are each other's mirror image structurally different? I'll assume that two trees are structurally different if they are not entirely identical.</li> \n</ul>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "judg":1,
                    "assum":1,
                    "constitut":1,
                    "binari":1,
                    "structur":3,
                    "child":1,
                    "ident":1,
                    "assumpt":1,
                    "allow":2,
                    "quot":2,
                    "tree":5,
                    "node":2,
                    "form":1,
                    "mirror":1,
                    "imag":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>With this in mind, the best approach would be to construct each tree of <code>i</code> nodes in size using some depth-first or breadth-first algorithm. Take, for instance, all forms of a tree that has 4 nodes. If you're going depth-first, this means you'll first investigate all forms where the root node only has a left child. Then you'll continue in that fashion until you've reached three nodes. I'm going to show this in plain ASCII since I'm too lazy to fire up a graphics program. Image each slash connects two invisible nodes:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-728607365]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>With this in mind, the best approach would be to construct each tree of <code>i</code> nodes in size using some depth-first or breadth-first algorithm. Take, for instance, all forms of a tree that has 4 nodes. If you're going depth-first, this means you'll first investigate all forms where the root node only has a left child. Then you'll continue in that fashion until you've reached three nodes. I'm going to show this in plain ASCII since I'm too lazy to fire up a graphics program. Image each slash connects two invisible nodes:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "fashion":1,
                    "program":1,
                    "reach":1,
                    "show":1,
                    "size":1,
                    "fire":1,
                    "graphic":1,
                    "connect":1,
                    "root":1,
                    "slash":1,
                    "left":1,
                    "mean":1,
                    "lazi":1,
                    "investig":1,
                    "ascii":1,
                    "code":2,
                    "child":1,
                    "invis":1,
                    "mind":1,
                    "algorithm":1,
                    "plain":1,
                    "approach":1,
                    "tree":2,
                    "depth":2,
                    "node":5,
                    "breadth":1,
                    "form":2,
                    "construct":1,
                    "imag":1,
                    "instanc":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"1: / / / "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[7803989]-[-655269238]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"1: / / / "
                  }
                ]
              },
              "rawText":"1: / / / ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>So we have left-left-left. The next variation is obtained by changing that last decision, leading to left-left-right:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-629767545]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>So we have left-left-left. The next variation is obtained by changing that last decision, leading to left-left-right:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "chang":1,
                    "lead":1,
                    "variat":1,
                    "left":5,
                    "decis":1,
                    "obtain":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"2: / / \\ "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[7803989]-[1832244990]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"2: / / \\ "
                  }
                ]
              },
              "rawText":"2: / / \\ ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The next variation would be to have both a left and right child node at the end, but since that would give us a tree of size 5, we can't do that. We've exhausted our options for now, so we'll go back one step, to the penultimate node. We originally chose left for that, so now we're going with right and continue the algorithm from there:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[1313591358]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The next variation would be to have both a left and right child node at the end, but since that would give us a tree of size 5, we can't do that. We've exhausted our options for now, so we'll go back one step, to the penultimate node. We originally chose left for that, so now we're going with right and continue the algorithm from there:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "variat":1,
                    "step":1,
                    "penultim":1,
                    "size":1,
                    "chose":1,
                    "left":2,
                    "option":1,
                    "exhaust":1,
                    "child":1,
                    "algorithm":1,
                    "origin":1,
                    "back":1,
                    "give":1,
                    "end":1,
                    "tree":1,
                    "node":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"3: / 4: / \\ \\ / \\ "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[7803989]-[483443486]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"3: / 4: / \\ \\ / \\ "
                  }
                ]
              },
              "rawText":"3: / 4: / \\ \\ / \\ ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>See what we did? We've made a different choice for the second node, then investigated all the remaining variations from there. Just like in 1 and 2.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-1128790898]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>See what we did? We've made a different choice for the second node, then investigated all the remaining variations from there. Just like in 1 and 2.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "variat":1,
                    "investig":1,
                    "remain":1,
                    "choic":1,
                    "node":1,
                    "made":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Alright, the options are once more exhausted, so we must go one step back. We've investigated left and right for the second node. This time there's another option remaining: two child nodes on the second level:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-136171435]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Alright, the options are once more exhausted, so we must go one step back. We've investigated left and right for the second node. This time there's another option remaining: two child nodes on the second level:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "step":1,
                    "left":1,
                    "option":2,
                    "investig":1,
                    "exhaust":1,
                    "child":1,
                    "remain":1,
                    "back":1,
                    "alright":1,
                    "node":2,
                    "time":1,
                    "level":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"5: / /\\ "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[7803989]-[-1224187129]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"5: / /\\ "
                  }
                ]
              },
              "rawText":"5: / /\\ ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Before you continue reading, try to follow this logic and draw out the next steps as you believe they will unfold. Remember the logic: make a left node and construct all subtrees, make a right node and construct all subtrees, make both (if this doesn't exceed the limit) and construct all subtrees. Once all options are exhausted, go back a step and vary from there.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-1556785708]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Before you continue reading, try to follow this logic and draw out the next steps as you believe they will unfold. Remember the logic: make a left node and construct all subtrees, make a right node and construct all subtrees, make both (if this doesn't exceed the limit) and construct all subtrees. Once all options are exhausted, go back a step and vary from there.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "step":2,
                    "exceed":1,
                    "left":1,
                    "option":1,
                    "unfold":1,
                    "exhaust":1,
                    "logic":2,
                    "rememb":1,
                    "draw":1,
                    "vari":1,
                    "back":1,
                    "make":3,
                    "node":2,
                    "subtre":3,
                    "limit":1,
                    "construct":3,
                    "follow":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Here's the remainder:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-311507489]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Here's the remainder:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "remaind":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"6: \\ 7: \\ 8: \\ 9: \\ 10: \\ 11: /\\ 12: /\\ 13: /\\ 14: /\\ / / \\ \\ /\\ / \\ / \\ / \\ / \\ "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[7803989]-[-1619676748]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"6: \\ 7: \\ 8: \\ 9: \\ 10: \\ 11: /\\ 12: /\\ 13: /\\ 14: /\\ / / \\ \\ /\\ / \\ / \\ / \\ / \\ "
                  }
                ]
              },
              "rawText":"6: \\ 7: \\ 8: \\ 9: \\ 10: \\ 11: /\\ 12: /\\ 13: /\\ 14: /\\ / / \\ \\ /\\ / \\ / \\ / \\ / \\ ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>14 forms. Thank goodness, it checks out.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[1162438413]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>14 forms. Thank goodness, it checks out.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "form":1,
                    "check":1,
                    "good":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Keep in mind that this is the depth-first algorithm. We go deeper until we've reached our node limit, then go back one step and make the other choice, and so on until those options are exhausted. Then we go back one step more. If you'd use breadth-first, you'd always go back as far as possible and choose the other option. I'll show you the first three steps of breadth-first:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-3888857]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Keep in mind that this is the depth-first algorithm. We go deeper until we've reached our node limit, then go back one step and make the other choice, and so on until those options are exhausted. Then we go back one step more. If you'd use breadth-first, you'd always go back as far as possible and choose the other option. I'll show you the first three steps of breadth-first:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "reach":1,
                    "step":3,
                    "show":1,
                    "option":2,
                    "exhaust":1,
                    "deeper":1,
                    "mind":1,
                    "algorithm":1,
                    "back":3,
                    "choic":1,
                    "make":1,
                    "choos":1,
                    "depth":1,
                    "node":1,
                    "breadth":2,
                    "limit":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"1: / 2: \\ 3: /\\ / / / / / "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[7803989]-[-1304577405]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"1: / 2: \\ 3: /\\ / / / / / "
                  }
                ]
              },
              "rawText":"1: / 2: \\ 3: /\\ / / / / / ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Just consider the breadth-first sample as informational. Also note that my depth-first order &quot;left, right, both&quot; is somewhat arbitrary. You might as well go with &quot;right, left, both&quot;.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-33705685]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Just consider the breadth-first sample as informational. Also note that my depth-first order &quot;left, right, both&quot; is somewhat arbitrary. You might as well go with &quot;right, left, both&quot;.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "arbitrari":1,
                    "sampl":1,
                    "left":2,
                    "inform":1,
                    "note":1,
                    "order":1,
                    "quot":4,
                    "depth":1,
                    "breadth":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>So, how do you go about actually turning this into code? Well, observe how after you've made a decision (left, right, both), the remainder of the tree forms extend from there. You could say that you're facing the same problem again, but now for a tree that is smaller.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[2018694556]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>So, how do you go about actually turning this into code? Well, observe how after you've made a decision (left, right, both), the remainder of the tree forms extend from there. You could say that you're facing the same problem again, but now for a tree that is smaller.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "observ":1,
                    "problem":1,
                    "remaind":1,
                    "left":1,
                    "extend":1,
                    "decis":1,
                    "code":1,
                    "face":1,
                    "turn":1,
                    "tree":2,
                    "smaller":1,
                    "form":1,
                    "made":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Go back to the depth-first step 1. Think about how it was constructed. We've got a root node. That's one out of the way, so 3 nodes remain to be allocated. From there, we must make a choice. Our initial choice was to make only a left child. This means we can for the moment ignore the right subtree. Starting from that child, we've now got the problem of constructing all trees with 3 nodes, of which the root node is that child. Once again, we choose the option of adding only a left child. And that brings us to the problem of constructing all trees of size 2.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[329949438]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Go back to the depth-first step 1. Think about how it was constructed. We've got a root node. That's one out of the way, so 3 nodes remain to be allocated. From there, we must make a choice. Our initial choice was to make only a left child. This means we can for the moment ignore the right subtree. Starting from that child, we've now got the problem of constructing all trees with 3 nodes, of which the root node is that child. Once again, we choose the option of adding only a left child. And that brings us to the problem of constructing all trees of size 2.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "ignor":1,
                    "step":1,
                    "alloc":1,
                    "size":1,
                    "root":2,
                    "problem":2,
                    "left":2,
                    "option":1,
                    "mean":1,
                    "child":4,
                    "remain":1,
                    "back":1,
                    "moment":1,
                    "choic":2,
                    "bring":1,
                    "make":2,
                    "ad":1,
                    "tree":2,
                    "initi":1,
                    "choos":1,
                    "depth":1,
                    "node":4,
                    "subtre":1,
                    "start":1,
                    "construct":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>This is known as a recursive problem. In order to find the solution for <code>i</code>, we must know the solution for <code>i-1</code>. In order to stop the recursion, there has to be some basis that doesn't rely on earlier results. In our case, it's <code>i=1</code> which is a trivial solution: just one node.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[1729456592]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>This is known as a recursive problem. In order to find the solution for <code>i</code>, we must know the solution for <code>i-1</code>. In order to stop the recursion, there has to be some basis that doesn't rely on earlier results. In our case, it's <code>i=1</code> which is a trivial solution: just one node.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "find":1,
                    "basi":1,
                    "problem":1,
                    "result":1,
                    "earlier":1,
                    "stop":1,
                    "code":6,
                    "recurs":2,
                    "order":2,
                    "node":1,
                    "reli":1,
                    "trivial":1,
                    "solut":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>So this means you can write a piece of code that finds you all tree forms of size <code>i</code> by using itself with parameter <code>i-1</code>. To avoid an infinite loop, stop the recursion at <code>i=1</code>. In order to check the size of your current tree to avoid breaking the node limit, you can make use of that <code>size()</code> method you've got there. Note how this itself is a recursive method: it makes use of itself to calculate the result. The other methods might be useful as well, but I don't think you'll need all of them.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[-198858721]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>So this means you can write a piece of code that finds you all tree forms of size <code>i</code> by using itself with parameter <code>i-1</code>. To avoid an infinite loop, stop the recursion at <code>i=1</code>. In order to check the size of your current tree to avoid breaking the node limit, you can make use of that <code>size()</code> method you've got there. Note how this itself is a recursive method: it makes use of itself to calculate the result. The other methods might be useful as well, but I don't think you'll need all of them.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "find":1,
                    "method":3,
                    "loop":1,
                    "break":1,
                    "size":3,
                    "result":1,
                    "mean":1,
                    "calcul":1,
                    "stop":1,
                    "avoid":2,
                    "code":9,
                    "paramet":1,
                    "recurs":2,
                    "check":1,
                    "note":1,
                    "order":1,
                    "piec":1,
                    "make":2,
                    "infinit":1,
                    "tree":2,
                    "node":1,
                    "form":1,
                    "current":1,
                    "limit":1,
                    "write":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Whether you choose depth-first or breadth-first is up to you. Try to think of how both would be expressed as algorithms and the requirements for the programming flow. Is depth-first simpler to implement than breadth-first?</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[1304527154]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Whether you choose depth-first or breadth-first is up to you. Try to think of how both would be expressed as algorithms and the requirements for the programming flow. Is depth-first simpler to implement than breadth-first?</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "program":1,
                    "requir":1,
                    "algorithm":1,
                    "flow":1,
                    "implement":1,
                    "express":1,
                    "choos":1,
                    "depth":2,
                    "breadth":2,
                    "simpler":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>I hope my ASCII nonsense was somewhat understandable and that I'm not coming across as too condescending. I don't know how far you got with the problem or what studies you're following. Trees are a common data structure and walking trees depth- or breadth-first (for example in a search algorithm) is a common algorithm, so expect to see more of it if IT is your primary occupation. Seeing how the assigment is over but you still want to figure out the solution, I'm sure you'll learn well.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[865077182]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>I hope my ASCII nonsense was somewhat understandable and that I'm not coming across as too condescending. I don't know how far you got with the problem or what studies you're following. Trees are a common data structure and walking trees depth- or breadth-first (for example in a search algorithm) is a common algorithm, so expect to see more of it if IT is your primary occupation. Seeing how the assigment is over but you still want to figure out the solution, I'm sure you'll learn well.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "learn":1,
                    "nonsens":1,
                    "problem":1,
                    "assig":1,
                    "data":1,
                    "understand":1,
                    "primari":1,
                    "walk":1,
                    "come":1,
                    "structur":1,
                    "ascii":1,
                    "common":2,
                    "algorithm":2,
                    "hope":1,
                    "expect":1,
                    "figur":1,
                    "tree":2,
                    "studi":1,
                    "depth":1,
                    "breadth":1,
                    "occup":1,
                    "solut":1,
                    "condescend":1,
                    "search":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Let us know whether you've find out how to do it in code. If you still got problems, I'll try to remember to post a (possibly partial) solution some time later.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[7803989]-[137513061]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Let us know whether you've find out how to do it in code. If you still got problems, I'll try to remember to post a (possibly partial) solution some time later.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "find":1,
                    "post":1,
                    "partial":1,
                    "problem":1,
                    "possibl":1,
                    "code":1,
                    "rememb":1,
                    "time":1,
                    "solut":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}