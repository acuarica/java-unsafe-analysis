{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":16114572,
    "title":"Is it a sensible optimization to check whether a variable holds a specific value before writing that value?",
    "comments":[
      {
        "type":"StackOverflowComment",
        "id":23014499,
        "postId":16114572,
        "creationDate":"2013-04-19",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":821497,
          "displayName":"ciamej",
          "reputation":2366
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"Specifically, the use case I have in mind is a heavily multi-threaded code. Avoiding writes as much as possible takes the strain off the cache coherency mechanism."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[16114572-cu23014499]-[-123029479]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"Specifically, the use case I have in mind is a heavily multi-threaded code. Avoiding writes as much as possible takes the strain off the cache coherency mechanism."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "strain":1,
                      "cach":1,
                      "avoid":1,
                      "code":1,
                      "thread":1,
                      "mind":1,
                      "take":1,
                      "specif":1,
                      "mechan":1,
                      "heavili":1,
                      "multi":1,
                      "coher":1,
                      "write":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":23014599,
        "postId":16114572,
        "creationDate":"2013-04-19",
        "score":1,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":41655,
          "displayName":"millimoose",
          "reputation":23793
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"If `var` is shared between threads, I'd say the performance loss from synchronisation is going to dwarf the cache miss. (If you're sharing a variable without synchronisation, well...)"
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[16114572-cu23014599]-[-622159395]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"If `var` is shared between threads, I'd say the performance loss from synchronisation is going to dwarf the cache miss. (If you're sharing a variable without synchronisation, well...)"
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "dwarf":1,
                      "cach":1,
                      "synchronis":2,
                      "miss":1,
                      "share":2,
                      "thread":1,
                      "perform":1,
                      "loss":1,
                      "variabl":1,
                      "var":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":23014758,
        "postId":16114572,
        "creationDate":"2013-04-19",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":87234,
          "displayName":"GManNickG",
          "reputation":172004
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"As with every single optimization question out there, why not just get some data on it?"
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[16114572-cu23014758]-[-752131170]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"As with every single optimization question out there, why not just get some data on it?"
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "optim":1,
                      "data":1,
                      "question":1,
                      "singl":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":23014372,
        "postId":16114572,
        "creationDate":"2013-04-19",
        "score":1,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":839829,
          "displayName":"mfrankli",
          "reputation":2000
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"this probably depends almost entirely on the specific use case, no?"
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[16114572-cu23014372]-[2143575647]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"this probably depends almost entirely on the specific use case, no?"
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "depend":1,
                      "specif":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":23014440,
        "postId":16114572,
        "creationDate":"2013-04-19",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":2019364,
          "displayName":"Orin",
          "reputation":421
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"I was thinking this exact question not 5 minutes ago, just with a boolean value"
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[16114572-cu23014440]-[-67606135]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"I was thinking this exact question not 5 minutes ago, just with a boolean value"
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "minut":1,
                      "question":1,
                      "exact":1,
                      "think":1,
                      "ago":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "tags":[
      "java",
      "c++",
      "performance",
      "caching",
      "optimization"
    ],
    "creationDate":"2013-04-19",
    "lastActivityDate":"2013-04-20",
    "lastEditDate":"2013-04-19",
    "score":21,
    "viewCount":638,
    "owner":{
      "type":"StackOverflowUser",
      "id":821497,
      "displayName":"ciamej",
      "reputation":2366
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlNode",
          "name":{
            "type":"XmlNameNode",
            "value":"pre"
          },
          "attributes":[
            
          ],
          "elements":[
            {
              "type":"XmlNode",
              "name":{
                "type":"XmlNameNode",
                "value":"code"
              },
              "attributes":[
                
              ],
              "elements":[
                {
                  "type":"XmlTextNode",
                  "contents":"if (var != X) var = X; "
                }
              ]
            }
          ]
        },
        "units":[
          {
            "type":"StructuredFragmentUnit",
            "id":"[16114572]-[-326828328]",
            "astNode":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"IfStatementNode",
                  "expression":{
                    "type":"BinaryExpressionNode",
                    "operator":{
                      "type":"OperatorNode",
                      "symbol":"!=",
                      "comments":[
                        
                      ]
                    },
                    "left":{
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"var",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "right":{
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"X",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  },
                  "statement":{
                    "type":"ExpressionStatement",
                    "expression":{
                      "type":"BinaryExpressionNode",
                      "operator":{
                        "type":"OperatorNode",
                        "symbol":"=",
                        "comments":[
                          
                        ]
                      },
                      "left":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"var",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "right":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"X",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ]
                  },
                  "labels":[
                    
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "rawText":"if (var != X) var = X; ",
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "var":2
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Is it sensible or not? Will the compiler always optimize-out the if statement? Are there any use cases that would benefit from the if statement?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[16114572]-[-1292842604]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Is it sensible or not? Will the compiler always optimize-out the if statement? Are there any use cases that would benefit from the if statement?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "statement":2,
                  "optim":1,
                  "compil":1,
                  "case":1,
                  "benefit":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>What if <code>var</code> is a volatile variable?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[16114572]-[-1888614222]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>What if <code>var</code> is a volatile variable?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "var":1,
                  "variabl":1,
                  "code":2
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I'm interested in both C++ and Java answers as the volatile variables have different semantics in both of the languages. Also the Java's JIT-compiling can make a difference.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[16114572]-[1644523515]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I'm interested in both C++ and Java answers as the volatile variables have different semantics in both of the languages. Also the Java's JIT-compiling can make a difference.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "jit":1,
                  "languag":1,
                  "differ":1,
                  "interest":1,
                  "semant":1,
                  "make":1,
                  "answer":1,
                  "compil":1,
                  "variabl":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>The if statement introduces branching and additional read that wouldn't happen if we always overwrote var with X, so it's bad. On the other hand, if <code>var == X</code> then using this optimization we perform only a read and we do not perform a write, which could have some effects on cache. Clearly, there are some trade-offs here. I'd like to know how it looks like in practice. Has anyone done any testing on this?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[16114572]-[1772144408]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>The if statement introduces branching and additional read that wouldn't happen if we always overwrote var with X, so it's bad. On the other hand, if <code>var == X</code> then using this optimization we perform only a read and we do not perform a write, which could have some effects on cache. Clearly, there are some trade-offs here. I'd like to know how it looks like in practice. Has anyone done any testing on this?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "read":2,
                  "test":1,
                  "off":1,
                  "cach":1,
                  "addit":1,
                  "happen":1,
                  "hand":1,
                  "effect":1,
                  "introduc":1,
                  "branch":1,
                  "bad":1,
                  "trade":1,
                  "statement":1,
                  "code":2,
                  "optim":1,
                  "perform":2,
                  "wouldn":1,
                  "practic":1,
                  "overwrot":1,
                  "write":1,
                  "var":2
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>EDIT:</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[16114572]-[1376224295]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>EDIT:</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "edit":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I'm mostly interested about how it looks like in a multi-processor environment. In a trivial situation there doesn't seem to be much sense in checking the variable first. But when cache coherency has to be kept between processors/cores the extra check might be actually beneficial. I just wonder how big impact can it have? Also shouldn't the processor do such an optimization itself? If <code>var == X</code> assigning it once more value <code>X</code> should not 'dirt-up' the cache. But can we rely on this?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[16114572]-[-977356334]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I'm mostly interested about how it looks like in a multi-processor environment. In a trivial situation there doesn't seem to be much sense in checking the variable first. But when cache coherency has to be kept between processors/cores the extra check might be actually beneficial. I just wonder how big impact can it have? Also shouldn't the processor do such an optimization itself? If <code>var == X</code> assigning it once more value <code>X</code> should not 'dirt-up' the cache. But can we rely on this?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "sens":1,
                  "cach":2,
                  "dirt":1,
                  "big":1,
                  "impact":1,
                  "benefici":1,
                  "assign":1,
                  "code":4,
                  "situat":1,
                  "optim":1,
                  "check":2,
                  "interest":1,
                  "processor":3,
                  "extra":1,
                  "reli":1,
                  "core":1,
                  "variabl":1,
                  "environ":1,
                  "shouldn":1,
                  "trivial":1,
                  "multi":1,
                  "coher":1,
                  "var":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":16118149,
      "questionId":16114572,
      "comments":[
        
      ],
      "creationDate":"2013-04-20",
      "lastActivityDate":"2013-04-20",
      "lastEditDate":"2013-04-20",
      "score":7,
      "isAccepted":true,
      "owner":{
        "type":"StackOverflowUser",
        "id":149138,
        "displayName":"BeeOnRope",
        "reputation":3980
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Yes, there are definitely cases where this is sensible, and as you suggest, volatile variables are one of those cases - even for single threaded access!</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[-365791618]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Yes, there are definitely cases where this is sensible, and as you suggest, volatile variables are one of those cases - even for single threaded access!</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "singl":1,
                    "suggest":1,
                    "thread":1,
                    "case":2,
                    "variabl":1,
                    "access":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Volatile writes are expensive, both from a hardware and a compiler/JIT perspective. At the hardware level, these writes might be 10x-100x more expensive that a normal write, since write buffers have to be flushed (on x86, the details will vary by platform). At the compiler/JIT level, volatile writes inhibit many common optimizations.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[-1997955167]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Volatile writes are expensive, both from a hardware and a compiler/JIT perspective. At the hardware level, these writes might be 10x-100x more expensive that a normal write, since write buffers have to be flushed (on x86, the details will vary by platform). At the compiler/JIT level, volatile writes inhibit many common optimizations.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jit":2,
                    "normal":1,
                    "buffer":1,
                    "inhibit":1,
                    "optim":1,
                    "common":1,
                    "perspect":1,
                    "vari":1,
                    "hardwar":2,
                    "flush":1,
                    "detail":1,
                    "compil":2,
                    "expens":2,
                    "platform":1,
                    "write":5,
                    "level":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Speculation, however, can only get you so far - the proof is always in the benchmarking. Here's a microbenchmark that tries your two strategies. The basic idea is to copy values from one array to another (pretty much System.arraycopy), with two variants - one which copies unconditionally, and one that checks to see if the values are different first.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[-973438041]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Speculation, however, can only get you so far - the proof is always in the benchmarking. Here's a microbenchmark that tries your two strategies. The basic idea is to copy values from one array to another (pretty much System.arraycopy), with two variants - one which copies unconditionally, and one that checks to see if the values are different first.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "uncondit":1,
                    "system":1,
                    "microbenchmark":1,
                    "idea":1,
                    "variant":1,
                    "strategi":1,
                    "specul":1,
                    "pretti":1,
                    "array":1,
                    "check":1,
                    "valu":2,
                    "proof":1,
                    "basic":1,
                    "arraycopi":1,
                    "copi":2,
                    "benchmark":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Here are the copy routines for the simple, non-volatile case (full source <a href=\"https://gist.github.com/anonymous/5425245\">here</a>):</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[-2003315470]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Here are the copy routines for the simple, non-volatile case (full source <a href=\"https://gist.github.com/anonymous/5425245\">here</a>):</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "github":1,
                    "simpl":1,
                    "anonym":1,
                    "full":1,
                    "https":1,
                    "routin":1,
                    "gist":1,
                    "href":1,
                    "sourc":1,
                    "copi":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":" // no check for (int i=0; i &lt; ARRAY_LENGTH; i++) { target[i] = source[i]; } // check, then set if unequal for (int i=0; i &lt; ARRAY_LENGTH; i++) { int x = source[i]; if (target[i] != x) { target[i] = x; } } "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[16118149]-[-78639843]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":" // no check "
                  },
                  {
                    "type":"ForLoopStatementNode",
                    "forControl":{
                      "type":"ForVarControlNode",
                      "variables":{
                        "type":"LocalVariableDeclarationStatementNode",
                        "modifiers":[
                          
                        ],
                        "declarators":{
                          "type":"VariableDeclaratorsNode",
                          "declarators":[
                            {
                              "type":"VariableDeclaratorNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"i",
                                "comments":[
                                  
                                ]
                              },
                              "arrayDepth":[
                                
                              ],
                              "assignment":{
                                "type":"VariableAssignmentNode",
                                "variableAssignment":{
                                  "type":"VariableExpressionInitNode",
                                  "expression":{
                                    "type":"LiteralNode",
                                    "node":{
                                      "type":"IntegerLiteralNode",
                                      "valueRep":"0"
                                    },
                                    "comments":[
                                      
                                    ]
                                  }
                                },
                                "comments":[
                                  
                                ]
                              },
                              "varType":{
                                "type":"PrimitiveTypeNode",
                                "name":"int",
                                "comments":[
                                  
                                ]
                              }
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "labels":[
                          
                        ],
                        "comments":[
                          
                        ]
                      },
                      "condition":{
                        "type":"BinaryExpressionNode",
                        "operator":{
                          "type":"OperatorNode",
                          "symbol":"<",
                          "comments":[
                            
                          ]
                        },
                        "left":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"i",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "right":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"ARRAY_LENGTH",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      "update":[
                        {
                          "type":"PostfixOperatorExpressionNode",
                          "argument":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"i",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "operator":{
                            "type":"OperatorNode",
                            "symbol":"++",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "statement":{
                      "type":"BlockNode",
                      "statements":[
                        {
                          "type":"ExpressionStatement",
                          "expression":{
                            "type":"BinaryExpressionNode",
                            "operator":{
                              "type":"OperatorNode",
                              "symbol":"=",
                              "comments":[
                                
                              ]
                            },
                            "left":{
                              "type":"ArrayAccessSelectorNode",
                              "identifier":{
                                "type":"QualifiedIdentifierNode",
                                "identifiers":[
                                  {
                                    "type":"IdentifierNode",
                                    "name":"target",
                                    "comments":[
                                      
                                    ]
                                  }
                                ],
                                "comments":[
                                  
                                ]
                              },
                              "dimExpression":{
                                "type":"DimExpressionNode",
                                "argument":{
                                  "type":"QualifiedIdentifierNode",
                                  "identifiers":[
                                    {
                                      "type":"IdentifierNode",
                                      "name":"i",
                                      "comments":[
                                        
                                      ]
                                    }
                                  ],
                                  "comments":[
                                    
                                  ]
                                },
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            },
                            "right":{
                              "type":"ArrayAccessSelectorNode",
                              "identifier":{
                                "type":"QualifiedIdentifierNode",
                                "identifiers":[
                                  {
                                    "type":"IdentifierNode",
                                    "name":"source",
                                    "comments":[
                                      
                                    ]
                                  }
                                ],
                                "comments":[
                                  
                                ]
                              },
                              "dimExpression":{
                                "type":"DimExpressionNode",
                                "argument":{
                                  "type":"QualifiedIdentifierNode",
                                  "identifiers":[
                                    {
                                      "type":"IdentifierNode",
                                      "name":"i",
                                      "comments":[
                                        
                                      ]
                                    }
                                  ],
                                  "comments":[
                                    
                                  ]
                                },
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ]
                        }
                      ],
                      "labels":[
                        
                      ],
                      "comments":[
                        {
                          "text":"// check, then set if unequal for (int i=0; i < ARRAY_LENGTH; i++) { int x = source[i]; if (target[i] != x) { target[i] = x; } } \n"
                        }
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "rawText":" // no check for (int i=0; i < ARRAY_LENGTH; i++) { target[i] = source[i]; } // check, then set if unequal for (int i=0; i < ARRAY_LENGTH; i++) { int x = source[i]; if (target[i] != x) { target[i] = x; } } \n",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "set":1,
                    "array":2,
                    "check":2,
                    "target":3,
                    "length":2,
                    "unequ":1,
                    "sourc":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    {
                      "type":"PrimitiveTypeNode",
                      "name":"int",
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    {
                      "type":"VariableDeclaratorNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"i",
                        "comments":[
                          
                        ]
                      },
                      "arrayDepth":[
                        
                      ],
                      "assignment":{
                        "type":"VariableAssignmentNode",
                        "variableAssignment":{
                          "type":"VariableExpressionInitNode",
                          "expression":{
                            "type":"LiteralNode",
                            "node":{
                              "type":"IntegerLiteralNode",
                              "valueRep":"0"
                            },
                            "comments":[
                              
                            ]
                          }
                        },
                        "comments":[
                          
                        ]
                      },
                      "varType":{
                        "type":"PrimitiveTypeNode",
                        "name":"int",
                        "comments":[
                          
                        ]
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The results using the above code to copy an array length of 1000, using <a href=\"http://code.google.com/p/caliper/\">Caliper</a> as my microbenchmark harness, are:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[-1805919687]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The results using the above code to copy an array length of 1000, using <a href=\"http://code.google.com/p/caliper/\">Caliper</a> as my microbenchmark harness, are:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "googl":1,
                    "microbenchmark":1,
                    "result":1,
                    "har":1,
                    "code":2,
                    "calip":2,
                    "array":1,
                    "length":1,
                    "href":1,
                    "http":1,
                    "copi":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":" benchmark arrayType ns linear runtime CopyNoCheck SAME 470 = CopyNoCheck DIFFERENT 460 = CopyCheck SAME 1378 === CopyCheck DIFFERENT 1856 ==== "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[16118149]-[-183696445]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":" benchmark "
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"arrayType",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"TextFragmentNode",
                    "text":" ns linear runtime "
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"CopyNoCheck",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"TextFragmentNode",
                    "text":"SAME 470 = "
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"CopyNoCheck",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"TextFragmentNode",
                    "text":"DIFFERENT 460 = "
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"CopyCheck",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"TextFragmentNode",
                    "text":"SAME 1378 === "
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"CopyCheck",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"TextFragmentNode",
                    "text":"DIFFERENT 1856 ==== "
                  }
                ]
              },
              "rawText":" benchmark arrayType ns linear runtime CopyNoCheck SAME 470 = CopyNoCheck DIFFERENT 460 = CopyCheck SAME 1378 === CopyCheck DIFFERENT 1856 ==== ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "runtim":1,
                    "array":1,
                    "check":4,
                    "linear":1,
                    "type":1,
                    "copi":4,
                    "benchmark":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"CopyNoCheck",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"CopyCheck",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>This also includes about 150ns of overhead per run to reset the target array each time. Skipping the check is much faster - about 0.47 ns per element (or around 0.32 ns per element after we remove the setup overhead, so pretty much exactly 1 cycle on my box).</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[1364257936]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>This also includes about 150ns of overhead per run to reset the target array each time. Skipping the check is much faster - about 0.47 ns per element (or around 0.32 ns per element after we remove the setup overhead, so pretty much exactly 1 cycle on my box).</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "remov":1,
                    "faster":1,
                    "run":1,
                    "skip":1,
                    "element":2,
                    "pretti":1,
                    "includ":1,
                    "overhead":2,
                    "array":1,
                    "check":1,
                    "reset":1,
                    "target":1,
                    "box":1,
                    "time":1,
                    "cycl":1,
                    "setup":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Checking is about 3x slower when the arrays are the same, and 4x slower then they are different. I'm surprised at how bad the check is, given that it is perfectly predicted. I suspect that the culprit is largely the JIT - with a much more complex loop body, it may be unrolled fewer times, and other optimizations may not apply.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[2118530939]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Checking is about 3x slower when the arrays are the same, and 4x slower then they are different. I'm surprised at how bad the check is, given that it is perfectly predicted. I suspect that the culprit is largely the JIT - with a much more complex loop body, it may be unrolled fewer times, and other optimizations may not apply.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jit":1,
                    "loop":1,
                    "fewer":1,
                    "culprit":1,
                    "bad":1,
                    "perfect":1,
                    "surpris":1,
                    "unrol":1,
                    "array":1,
                    "optim":1,
                    "larg":1,
                    "check":2,
                    "slower":2,
                    "suspect":1,
                    "predict":1,
                    "bodi":1,
                    "time":1,
                    "appli":1,
                    "complex":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Let's switch to the volatile case. Here, I've used <code>AtomicIntegerArray</code> as my arrays of volatile elements, since Java doesn't have any native array types with volatile elements. Internally, this class is just writing straight through to the array using <code>sun.misc.Unsafe</code>, which allows volatile writes. The assembly generated is substantially similar to normal array access, other than the volatile aspect (and possibly range check elimination, which may not be effective in the AIA case).</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[147596919]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Let's switch to the volatile case. Here, I've used <code>AtomicIntegerArray</code> as my arrays of volatile elements, since Java doesn't have any native array types with volatile elements. Internally, this class is just writing straight through to the array using <code>sun.misc.Unsafe</code>, which allows volatile writes. The assembly generated is substantially similar to normal array access, other than the volatile aspect (and possibly range check elimination, which may not be effective in the AIA case).</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"AtomicIntegerArray",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ClassDeclarationNode",
                    "modifiers":[
                      
                    ],
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"is",
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"sun",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"misc",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"Unsafe",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "assembl":1,
                    "similar":1,
                    "rang":1,
                    "normal":1,
                    "effect":1,
                    "sun":1,
                    "aspect":1,
                    "aia":1,
                    "possibl":1,
                    "element":2,
                    "code":4,
                    "array":5,
                    "check":1,
                    "misc":1,
                    "substanti":1,
                    "elimin":1,
                    "generat":1,
                    "atom":1,
                    "unsaf":1,
                    "straight":1,
                    "type":1,
                    "intern":1,
                    "write":2,
                    "access":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"sun",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"misc",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"Unsafe",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"AtomicIntegerArray",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Here's the code:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[487196453]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Here's the code:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "code":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":" // no check for (int i=0; i &lt; ARRAY_LENGTH; i++) { target.set(i, source[i]); } // check, then set if unequal for (int i=0; i &lt; ARRAY_LENGTH; i++) { int x = source[i]; if (target.get(i) != x) { target.set(i, x); } } "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[16118149]-[1469856430]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":" // no check "
                  },
                  {
                    "type":"ForLoopStatementNode",
                    "forControl":{
                      "type":"ForVarControlNode",
                      "variables":{
                        "type":"LocalVariableDeclarationStatementNode",
                        "modifiers":[
                          
                        ],
                        "declarators":{
                          "type":"VariableDeclaratorsNode",
                          "declarators":[
                            {
                              "type":"VariableDeclaratorNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"i",
                                "comments":[
                                  
                                ]
                              },
                              "arrayDepth":[
                                
                              ],
                              "assignment":{
                                "type":"VariableAssignmentNode",
                                "variableAssignment":{
                                  "type":"VariableExpressionInitNode",
                                  "expression":{
                                    "type":"LiteralNode",
                                    "node":{
                                      "type":"IntegerLiteralNode",
                                      "valueRep":"0"
                                    },
                                    "comments":[
                                      
                                    ]
                                  }
                                },
                                "comments":[
                                  
                                ]
                              },
                              "varType":{
                                "type":"PrimitiveTypeNode",
                                "name":"int",
                                "comments":[
                                  
                                ]
                              }
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "labels":[
                          
                        ],
                        "comments":[
                          
                        ]
                      },
                      "condition":{
                        "type":"BinaryExpressionNode",
                        "operator":{
                          "type":"OperatorNode",
                          "symbol":"<",
                          "comments":[
                            
                          ]
                        },
                        "left":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"i",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "right":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"ARRAY_LENGTH",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      "update":[
                        {
                          "type":"PostfixOperatorExpressionNode",
                          "argument":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"i",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "operator":{
                            "type":"OperatorNode",
                            "symbol":"++",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "statement":{
                      "type":"BlockNode",
                      "statements":[
                        {
                          "type":"ExpressionStatement",
                          "expression":{
                            "type":"MethodInvocationNode",
                            "qualifiedIdentifier":{
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"target",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"set",
                              "comments":[
                                
                              ]
                            },
                            "args":{
                              "type":"ExpressionListNode",
                              "arguments":[
                                {
                                  "type":"QualifiedIdentifierNode",
                                  "identifiers":[
                                    {
                                      "type":"IdentifierNode",
                                      "name":"i",
                                      "comments":[
                                        
                                      ]
                                    }
                                  ],
                                  "comments":[
                                    
                                  ]
                                },
                                {
                                  "type":"ArrayAccessSelectorNode",
                                  "identifier":{
                                    "type":"QualifiedIdentifierNode",
                                    "identifiers":[
                                      {
                                        "type":"IdentifierNode",
                                        "name":"source",
                                        "comments":[
                                          
                                        ]
                                      }
                                    ],
                                    "comments":[
                                      
                                    ]
                                  },
                                  "dimExpression":{
                                    "type":"DimExpressionNode",
                                    "argument":{
                                      "type":"QualifiedIdentifierNode",
                                      "identifiers":[
                                        {
                                          "type":"IdentifierNode",
                                          "name":"i",
                                          "comments":[
                                            
                                          ]
                                        }
                                      ],
                                      "comments":[
                                        
                                      ]
                                    },
                                    "comments":[
                                      
                                    ]
                                  },
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ]
                        }
                      ],
                      "labels":[
                        
                      ],
                      "comments":[
                        {
                          "text":"// check, then set if unequal for (int i=0; i < ARRAY_LENGTH; i++) { int x = source[i]; if (target.get(i) != x) { target.set(i, x); } } \n"
                        }
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "rawText":" // no check for (int i=0; i < ARRAY_LENGTH; i++) { target.set(i, source[i]); } // check, then set if unequal for (int i=0; i < ARRAY_LENGTH; i++) { int x = source[i]; if (target.get(i) != x) { target.set(i, x); } } \n",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "set":3,
                    "array":2,
                    "check":2,
                    "target":3,
                    "length":2,
                    "unequ":1,
                    "sourc":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    {
                      "type":"PrimitiveTypeNode",
                      "name":"int",
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    {
                      "type":"MethodInvocationNode",
                      "qualifiedIdentifier":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"target",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"set",
                        "comments":[
                          
                        ]
                      },
                      "args":{
                        "type":"ExpressionListNode",
                        "arguments":[
                          {
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"i",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"ArrayAccessSelectorNode",
                            "identifier":{
                              "type":"QualifiedIdentifierNode",
                              "identifiers":[
                                {
                                  "type":"IdentifierNode",
                                  "name":"source",
                                  "comments":[
                                    
                                  ]
                                }
                              ],
                              "comments":[
                                
                              ]
                            },
                            "dimExpression":{
                              "type":"DimExpressionNode",
                              "argument":{
                                "type":"QualifiedIdentifierNode",
                                "identifiers":[
                                  {
                                    "type":"IdentifierNode",
                                    "name":"i",
                                    "comments":[
                                      
                                    ]
                                  }
                                ],
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    {
                      "type":"VariableDeclaratorNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"i",
                        "comments":[
                          
                        ]
                      },
                      "arrayDepth":[
                        
                      ],
                      "assignment":{
                        "type":"VariableAssignmentNode",
                        "variableAssignment":{
                          "type":"VariableExpressionInitNode",
                          "expression":{
                            "type":"LiteralNode",
                            "node":{
                              "type":"IntegerLiteralNode",
                              "valueRep":"0"
                            },
                            "comments":[
                              
                            ]
                          }
                        },
                        "comments":[
                          
                        ]
                      },
                      "varType":{
                        "type":"PrimitiveTypeNode",
                        "name":"int",
                        "comments":[
                          
                        ]
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>And here are the results:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[-2136250531]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>And here are the results:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "result":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"arrayType benchmark us linear runtime SAME CopyCheckAI 2.85 ======= SAME CopyNoCheckAI 10.21 =========================== DIFFERENT CopyCheckAI 11.33 ============================== DIFFERENT CopyNoCheckAI 11.19 ============================= "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[16118149]-[1077579395]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"arrayType",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"TextFragmentNode",
                    "text":" benchmark us linear runtime SAME CopyCheckAI 2.85 ======= SAME CopyNoCheckAI 10.21 =========================== DIFFERENT CopyCheckAI 11.33 ============================== DIFFERENT CopyNoCheckAI 11.19 ============================= "
                  }
                ]
              },
              "rawText":"arrayType benchmark us linear runtime SAME CopyCheckAI 2.85 ======= SAME CopyNoCheckAI 10.21 =========================== DIFFERENT CopyCheckAI 11.33 ============================== DIFFERENT CopyNoCheckAI 11.19 ============================= ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "runtim":1,
                    "array":1,
                    "check":4,
                    "linear":1,
                    "type":1,
                    "copi":4,
                    "benchmark":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The tables have turned. Checking first is ~3.5x faster than the usual method. Everything is much slower overall - in the check case, we are paying ~3 ns per loop, and in the worst cases ~10 ns (the times above are in us, and cover the copy of the whole 1000 element array). Volatile writes really are more expensive. There is about 1 ns of overheaded included in the DIFFERENT case to reset the array on each iteration (which is why even the simple is slightly slower for DIFFERENT). I suspect a lot of the overhead in the &quot;check&quot; case is actually bounds checking.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[-1252275431]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The tables have turned. Checking first is ~3.5x faster than the usual method. Everything is much slower overall - in the check case, we are paying ~3 ns per loop, and in the worst cases ~10 ns (the times above are in us, and cover the copy of the whole 1000 element array). Volatile writes really are more expensive. There is about 1 ns of overheaded included in the DIFFERENT case to reset the array on each iteration (which is why even the simple is slightly slower for DIFFERENT). I suspect a lot of the overhead in the &quot;check&quot; case is actually bounds checking.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "method":1,
                    "faster":1,
                    "loop":1,
                    "simpl":1,
                    "worst":1,
                    "slight":1,
                    "pay":1,
                    "element":1,
                    "includ":1,
                    "overhead":2,
                    "tabl":1,
                    "array":2,
                    "cover":1,
                    "bound":1,
                    "check":4,
                    "usual":1,
                    "slower":2,
                    "iter":1,
                    "suspect":1,
                    "turn":1,
                    "lot":1,
                    "reset":1,
                    "quot":2,
                    "time":1,
                    "case":1,
                    "expens":1,
                    "write":1,
                    "copi":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>This is all single threaded. If you actual had cross-core contention over a volatile, the results would be much, much worse for the simple method, and just about as good as the above for the check case (the cache line would just sit in the shared state - no coherency traffic needed).</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[1065042664]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>This is all single threaded. If you actual had cross-core contention over a volatile, the results would be much, much worse for the simple method, and just about as good as the above for the check case (the cache line would just sit in the shared state - no coherency traffic needed).</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "singl":1,
                    "method":1,
                    "cach":1,
                    "simpl":1,
                    "sit":1,
                    "state":1,
                    "line":1,
                    "good":1,
                    "result":1,
                    "wors":1,
                    "share":1,
                    "thread":1,
                    "need":1,
                    "check":1,
                    "cross":1,
                    "content":1,
                    "traffic":1,
                    "core":1,
                    "actual":1,
                    "coher":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>I've also only tested the extremes of &quot;every element equal&quot; vs &quot;every element different&quot;. This means the branch in the &quot;check&quot; algorithm is always perfectly predicted. If you had a mix of equal and different, you wouldn't get just a weighted combination of the times for the SAME and DIFFERENT cases - you do worse, due to misprediction (both at the hardware level, and perhaps also at the JIT level, which can no longer optimize for the always-taken branch).</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[802577005]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>I've also only tested the extremes of &quot;every element equal&quot; vs &quot;every element different&quot;. This means the branch in the &quot;check&quot; algorithm is always perfectly predicted. If you had a mix of equal and different, you wouldn't get just a weighted combination of the times for the SAME and DIFFERENT cases - you do worse, due to misprediction (both at the hardware level, and perhaps also at the JIT level, which can no longer optimize for the always-taken branch).</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "jit":1,
                    "weight":1,
                    "test":1,
                    "due":1,
                    "branch":2,
                    "wors":1,
                    "mean":1,
                    "perfect":1,
                    "element":2,
                    "optim":1,
                    "mix":1,
                    "equal":2,
                    "algorithm":1,
                    "check":1,
                    "combin":1,
                    "wouldn":1,
                    "extrem":1,
                    "hardwar":1,
                    "mispredict":1,
                    "quot":6,
                    "longer":1,
                    "predict":1,
                    "time":1,
                    "case":1,
                    "level":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>So whether it is sensible, even for volatile, depends on the specific context - the mix of equal and unequal values, the surrounding code and so on. I'd usually not do it for volatile alone in a single-threaded scenario, unless I suspected a large number of sets are redundant. In heavily multi-threaded structures, however, reading and then doing a volatile write (or other expensive operation, like a CAS) is a best-practice and you'll see it quality code such as <code>java.util.concurrent</code> structures.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16118149]-[-390314934]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>So whether it is sensible, even for volatile, depends on the specific context - the mix of equal and unequal values, the surrounding code and so on. I'd usually not do it for volatile alone in a single-threaded scenario, unless I suspected a large number of sets are redundant. In heavily multi-threaded structures, however, reading and then doing a volatile write (or other expensive operation, like a CAS) is a best-practice and you'll see it quality code such as <code>java.util.concurrent</code> structures.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "scenario":1,
                    "read":1,
                    "number":1,
                    "singl":1,
                    "concurr":1,
                    "util":1,
                    "depend":1,
                    "redund":1,
                    "context":1,
                    "set":1,
                    "cas":1,
                    "structur":2,
                    "code":4,
                    "oper":1,
                    "thread":2,
                    "mix":1,
                    "larg":1,
                    "equal":1,
                    "specif":1,
                    "valu":1,
                    "suspect":1,
                    "qualiti":1,
                    "heavili":1,
                    "unequ":1,
                    "expens":1,
                    "practic":1,
                    "multi":1,
                    "write":1,
                    "surround":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":16114630,
      "questionId":16114572,
      "comments":[
        
      ],
      "creationDate":"2013-04-19",
      "lastActivityDate":"2013-04-19",
      "lastEditDate":"2013-04-19",
      "score":8,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":16287,
        "displayName":"Drew Dormann",
        "reputation":28289
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>Is it a sensible optimization to check whether a variable holds a specific value before writing that value?</p> \n <p>Are there any use cases that would benefit from the if statement?</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114630]-[1362586291]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>Is it a sensible optimization to check whether a variable holds a specific value before writing that value?</p> \n <p>Are there any use cases that would benefit from the if statement?</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "statement":1,
                    "blockquot":2,
                    "hold":1,
                    "optim":1,
                    "check":1,
                    "specif":1,
                    "case":1,
                    "benefit":1,
                    "variabl":1,
                    "write":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>It is when assignment is significantly more costly than an inequality comparison returning <code>false</code>.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114630]-[-1248561490]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>It is when assignment is significantly more costly than an inequality comparison returning <code>false</code>.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "comparison":1,
                    "return":1,
                    "inequ":1,
                    "assign":1,
                    "code":2,
                    "cost":1,
                    "signific":1,
                    "fals":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>A example would be a large* <code>std::set</code>, which may require many heap allocations to duplicate.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114630]-[-72659407]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>A example would be a large* <code>std::set</code>, which may require many heap allocations to duplicate.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "alloc":1,
                    "requir":1,
                    "set":1,
                    "std":1,
                    "code":2,
                    "larg":1,
                    "heap":1,
                    "duplic":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>*<em>for some definition of &quot;large&quot;</em></p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114630]-[1574588576]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>*<em>for some definition of &quot;large&quot;</em></p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "larg":1,
                    "quot":2,
                    "definit":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>Will the compiler always optimize-out the if statement?</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114630]-[-235418007]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>Will the compiler always optimize-out the if statement?</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "blockquot":2,
                    "optim":1,
                    "statement":1,
                    "compil":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>That's a fairly safe &quot;no&quot;, as are most questions that contain both &quot;optimize&quot; and &quot;always&quot;.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114630]-[1755245655]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>That's a fairly safe &quot;no&quot;, as are most questions that contain both &quot;optimize&quot; and &quot;always&quot;.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "question":1,
                    "fair":1,
                    "safe":1,
                    "optim":1,
                    "quot":6
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The C++ standard makes rare mention of optimizations, but never demands one.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114630]-[-2011484143]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The C++ standard makes rare mention of optimizations, but never demands one.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "standard":1,
                    "optim":1,
                    "mention":1,
                    "rare":1,
                    "make":1,
                    "demand":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<blockquote> \n <p>What if var is a volatile variable?</p> \n</blockquote>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114630]-[2021242180]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<blockquote> \n <p>What if var is a volatile variable?</p> \n</blockquote>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "blockquot":2,
                    "var":1,
                    "variabl":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Then it <em>may</em> perform the <code>if</code>, although <a href=\"http://stackoverflow.com/questions/12878344/volatile-in-c11\"><code>volatile</code> doesn't achieve what most people assume.</a></p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114630]-[493610694]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Then it <em>may</em> perform the <code>if</code>, although <a href=\"http://stackoverflow.com/questions/12878344/volatile-in-c11\"><code>volatile</code> doesn't achieve what most people assume.</a></p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "question":1,
                    "assum":1,
                    "code":4,
                    "stackoverflow":1,
                    "achiev":1,
                    "perform":1,
                    "href":1,
                    "peopl":1,
                    "http":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":16114697,
      "questionId":16114572,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":23020952,
          "postId":16114697,
          "creationDate":"2013-04-20",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":149138,
            "displayName":"BeeOnRope",
            "reputation":3980
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Not true for volatile variables, or variables shared across threads (volatile or not), in Java."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[16114697-cu23020952]-[215330812]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Not true for volatile variables, or variables shared across threads (volatile or not), in Java."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "share":1,
                        "thread":1,
                        "variabl":2,
                        "true":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2013-04-19",
      "lastActivityDate":"2013-04-19",
      "score":0,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":938694,
        "displayName":"Cubic",
        "reputation":6233
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>In java the answer is always no. All assignments you can do in Java are primitive. In C++, the answer is still pretty much always no - if copying is so much more expensive than an equality check, the class in question should do that equality check itself.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114697]-[-578951762]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>In java the answer is always no. All assignments you can do in Java are primitive. In C++, the answer is still pretty much always no - if copying is so much more expensive than an equality check, the class in question should do that equality check itself.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ClassDeclarationNode",
                    "modifiers":[
                      
                    ],
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"in",
                      "comments":[
                        
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "question":1,
                    "assign":1,
                    "pretti":1,
                    "equal":2,
                    "check":2,
                    "answer":2,
                    "expens":1,
                    "primit":1,
                    "copi":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":16114741,
      "questionId":16114572,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":23015893,
          "postId":16114741,
          "creationDate":"2013-04-20",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":144746,
            "displayName":"Voo",
            "reputation":12920
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"`definitely and always`.. and as with all definite and absolute statements this one is also false (think cache behavior among lots of threads). That said in the normal single threaded situation the Java JIT will produce usually similar code to `gcc -O2` if the language rules allow it."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[16114741-cu23015893]-[752073890]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"`definitely and always`.. and as with all definite and absolute statements this one is also false (think cache behavior among lots of threads). That said in the normal single threaded situation the Java JIT will produce usually similar code to `gcc -O2` if the language rules allow it."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "jit":1,
                        "singl":1,
                        "languag":1,
                        "cach":1,
                        "produc":1,
                        "similar":1,
                        "normal":1,
                        "rule":1,
                        "statement":1,
                        "gcc":1,
                        "code":1,
                        "situat":1,
                        "thread":2,
                        "definit":1,
                        "absolut":1,
                        "lot":1,
                        "fals":1,
                        "behavior":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":23020499,
          "postId":16114741,
          "creationDate":"2013-04-20",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":149138,
            "displayName":"BeeOnRope",
            "reputation":3980
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"If the variable is `volatile` in Java, check then set will almost certainly be faster if they variable is often equal (see my answer) - typically by a significant margin. Same for C++ for the equivalent construct (which is not `volatile`, but `std::atomic` stuff)."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[16114741-cu23020499]-[-1433547758]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"If the variable is `volatile` in Java, check then set will almost certainly be faster if they variable is often equal (see my answer) - typically by a significant margin. Same for C++ for the equivalent construct (which is not `volatile`, but `std::atomic` stuff)."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "margin":1,
                        "faster":1,
                        "equival":1,
                        "set":1,
                        "std":1,
                        "equal":1,
                        "check":1,
                        "typic":1,
                        "signific":1,
                        "stuff":1,
                        "answer":1,
                        "atom":1,
                        "variabl":2,
                        "construct":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2013-04-19",
      "lastActivityDate":"2013-04-19",
      "score":4,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":1919155,
        "displayName":"Mats Petersson",
        "reputation":74217
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>In C++, assigning a SIMPLE variable (that is, a normal integer or float variable) is definitely and always faster than checking if it already has that value and then setting it if it didn't have the value. I would be very surprised if this wasn't true in Java too, but I don't know how complicated or simple things are in Java - I've written a few hundred lines, and not actually studied how byte code and JITed bytecode actually works. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114741]-[278363321]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>In C++, assigning a SIMPLE variable (that is, a normal integer or float variable) is definitely and always faster than checking if it already has that value and then setting it if it didn't have the value. I would be very surprised if this wasn't true in Java too, but I don't know how complicated or simple things are in Java - I've written a few hundred lines, and not actually studied how byte code and JITed bytecode actually works. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "faster":1,
                    "simpl":2,
                    "line":1,
                    "bytecod":1,
                    "normal":1,
                    "complic":1,
                    "set":1,
                    "assign":1,
                    "thing":1,
                    "wasn":1,
                    "hundr":1,
                    "work":1,
                    "surpris":1,
                    "code":1,
                    "jite":1,
                    "check":1,
                    "written":1,
                    "true":1,
                    "studi":1,
                    "variabl":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Clearly, if the variable is very easy to check, but complicated to set, which could be the case for classes and other such things, then there may be a value. The typical case where you'd find this would be in some code where the &quot;value&quot; is some sort of index or hash, but if it's not a match, a whole lot of work is required. One example would be in a task-switch: </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114741]-[27373908]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Clearly, if the variable is very easy to check, but complicated to set, which could be the case for classes and other such things, then there may be a value. The typical case where you'd find this would be in some code where the &quot;value&quot; is some sort of index or hash, but if it's not a match, a whole lot of work is required. One example would be in a task-switch: </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "find":1,
                    "task":1,
                    "easi":1,
                    "complic":1,
                    "requir":1,
                    "set":1,
                    "thing":1,
                    "work":1,
                    "match":1,
                    "code":1,
                    "hash":1,
                    "check":1,
                    "typic":1,
                    "lot":1,
                    "class":1,
                    "quot":2,
                    "sort":1,
                    "variabl":1,
                    "index":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"if (current_process != new_process_to_run) current_process == new_process_to_run; "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[16114741]-[809782575]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"IfStatementNode",
                    "expression":{
                      "type":"BinaryExpressionNode",
                      "operator":{
                        "type":"OperatorNode",
                        "symbol":"!=",
                        "comments":[
                          
                        ]
                      },
                      "left":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"current_process",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "right":{
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"new_process_to_run",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    },
                    "statement":{
                      "type":"ExpressionStatement",
                      "expression":{
                        "type":"BinaryExpressionNode",
                        "operator":{
                          "type":"OperatorNode",
                          "symbol":"==",
                          "comments":[
                            
                          ]
                        },
                        "left":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"current_process",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "right":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"new_process_to_run",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      "labels":[
                        
                      ]
                    },
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "rawText":"if (current_process != new_process_to_run) current_process == new_process_to_run; ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "run":2,
                    "process":4,
                    "current":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Because here, a &quot;process&quot; is a complex object to alter, but the <code>!=</code> can be done on the ID of the process. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114741]-[-1329750902]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Because here, a &quot;process&quot; is a complex object to alter, but the <code>!=</code> can be done on the ID of the process. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "alter":1,
                    "process":2,
                    "object":1,
                    "code":2,
                    "quot":2,
                    "complex":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Whether the object is simple or complex, the compiler will almost certainly not understand what you are trying to do here, so it will probably not optimize it away - but compilers are more clever than you think SOMETIMES, and more stupid at other times, so I wouldn't bet either way. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114741]-[-148686002]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Whether the object is simple or complex, the compiler will almost certainly not understand what you are trying to do here, so it will probably not optimize it away - but compilers are more clever than you think SOMETIMES, and more stupid at other times, so I wouldn't bet either way. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "simpl":1,
                    "bet":1,
                    "understand":1,
                    "clever":1,
                    "object":1,
                    "optim":1,
                    "wouldn":1,
                    "compil":2,
                    "time":1,
                    "stupid":1,
                    "complex":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><code>volatile</code> should always force the compiler to read and write values to the variable, whether it &quot;thinks&quot; it is necessary or not, so it will definitely READ the variable and WRITE the variable. Of course, if the variable is <code>volatile</code> it probably means that it can change or represents some hardware, so you should be EXTRA careful with how you treat it yourself too... An extra read of a PCI-X card could incur several bus cycles (bus cycles being an order of magnitude slower than the processor speed!), which is likely to affect the performance much more. But then writing to a hardware register may (for example) cause the hardware to do something unexpected, and checking that we have that value first MAY make it faster, because &quot;some operation starts over&quot;, or something like that. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114741]-[-171397607]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><code>volatile</code> should always force the compiler to read and write values to the variable, whether it &quot;thinks&quot; it is necessary or not, so it will definitely READ the variable and WRITE the variable. Of course, if the variable is <code>volatile</code> it probably means that it can change or represents some hardware, so you should be EXTRA careful with how you treat it yourself too... An extra read of a PCI-X card could incur several bus cycles (bus cycles being an order of magnitude slower than the processor speed!), which is likely to affect the performance much more. But then writing to a hardware register may (for example) cause the hardware to do something unexpected, and checking that we have that value first MAY make it faster, because &quot;some operation starts over&quot;, or something like that. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":3,
                    "chang":1,
                    "bus":2,
                    "faster":1,
                    "magnitud":1,
                    "mean":1,
                    "regist":1,
                    "care":1,
                    "affect":1,
                    "code":4,
                    "oper":1,
                    "incur":1,
                    "check":1,
                    "slower":1,
                    "processor":1,
                    "pci":1,
                    "order":1,
                    "unexpect":1,
                    "think":1,
                    "perform":1,
                    "valu":1,
                    "hardwar":3,
                    "make":1,
                    "extra":2,
                    "quot":4,
                    "treat":1,
                    "compil":1,
                    "forc":1,
                    "variabl":4,
                    "card":1,
                    "start":1,
                    "cycl":2,
                    "repres":1,
                    "write":3,
                    "speed":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":16114661,
      "questionId":16114572,
      "comments":[
        
      ],
      "creationDate":"2013-04-19",
      "lastActivityDate":"2013-04-19",
      "score":1,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":165132,
        "displayName":"rmn",
        "reputation":1811
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>It would be sensible if you had read-write locking semantics involved, whenever reading is usually less disruptive than writing.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114661]-[453669003]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>It would be sensible if you had read-write locking semantics involved, whenever reading is usually less disruptive than writing.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":2,
                    "involv":1,
                    "disrupt":1,
                    "lock":1,
                    "semant":1,
                    "write":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":16114981,
      "questionId":16114572,
      "comments":[
        
      ],
      "creationDate":"2013-04-19",
      "lastActivityDate":"2013-04-19",
      "score":1,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":581994,
        "displayName":"Hot Licks",
        "reputation":27968
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>In Objective-C you have the situation where assigning a object address to a pointer variable may require that the object be &quot;retained&quot; (reference count incremented). In such a case it makes sense to see if the value being assigned is the same as the value currently in the pointer variable, to avoid having to do the relatively expensive increment/decrement operations.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114981]-[1810562141]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>In Objective-C you have the situation where assigning a object address to a pointer variable may require that the object be &quot;retained&quot; (reference count incremented). In such a case it makes sense to see if the value being assigned is the same as the value currently in the pointer variable, to avoid having to do the relatively expensive increment/decrement operations.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "sens":1,
                    "count":1,
                    "pointer":2,
                    "requir":1,
                    "assign":2,
                    "retain":1,
                    "avoid":1,
                    "object":3,
                    "oper":1,
                    "situat":1,
                    "decrement":1,
                    "refer":1,
                    "address":1,
                    "make":1,
                    "quot":2,
                    "expens":1,
                    "variabl":2,
                    "increment":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Other languages that use reference counting likely have similar scenarios.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114981]-[-1877668286]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Other languages that use reference counting likely have similar scenarios.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "scenario":1,
                    "count":1,
                    "languag":1,
                    "similar":1,
                    "refer":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>But when assigning, say, an <code>int</code> or a <code>boolean</code> to a simple variable (outside of the multiprocessor cache scenario mentioned elsewhere) the test is rarely merited. The speed of a store in most processors is at least as fast as the load/test/branch.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114981]-[-1310638587]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>But when assigning, say, an <code>int</code> or a <code>boolean</code> to a simple variable (outside of the multiprocessor cache scenario mentioned elsewhere) the test is rarely merited. The speed of a store in most processors is at least as fast as the load/test/branch.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "scenario":1,
                    "test":2,
                    "cach":1,
                    "simpl":1,
                    "branch":1,
                    "assign":1,
                    "store":1,
                    "load":1,
                    "code":4,
                    "mention":1,
                    "processor":1,
                    "rare":1,
                    "fast":1,
                    "multiprocessor":1,
                    "merit":1,
                    "variabl":1,
                    "speed":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":16114597,
      "questionId":16114572,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":23014475,
          "postId":16114597,
          "creationDate":"2013-04-19",
          "score":5,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":581994,
            "displayName":"Hot Licks",
            "reputation":27968
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"A case where it may make sense to do the check is when the target variable in question is heavily referenced in a multi-processor environment, and you want to avoid unnecessarily &quot;dirtying&quot; the cache line. But there are very few cases where it makes sense in &quot;normal&quot; programming."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[16114597-cu23014475]-[351194632]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"A case where it may make sense to do the check is when the target variable in question is heavily referenced in a multi-processor environment, and you want to avoid unnecessarily &quot;dirtying&quot; the cache line. But there are very few cases where it makes sense in &quot;normal&quot; programming."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "sens":2,
                        "program":1,
                        "question":1,
                        "cach":1,
                        "line":1,
                        "normal":1,
                        "avoid":1,
                        "unnecessarili":1,
                        "check":1,
                        "processor":1,
                        "make":2,
                        "quot":4,
                        "target":1,
                        "heavili":1,
                        "case":1,
                        "variabl":1,
                        "environ":1,
                        "dirti":1,
                        "multi":1,
                        "referenc":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":23014586,
          "postId":16114597,
          "creationDate":"2013-04-19",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":2254782,
            "displayName":"alexrider",
            "reputation":3753
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"@HotLicks With such broad questions there is never one fits all answer. And once usage scenario becomes common it will be reflected in operator= one way or another. And thanks for good example of special case."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[16114597-cu23014586]-[-387154927]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"@HotLicks With such broad questions there is never one fits all answer. And once usage scenario becomes common it will be reflected in operator= one way or another. And thanks for good example of special case."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"AnnotationNode",
                        "identifier":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"HotLicks",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "scenario":1,
                        "question":1,
                        "lick":1,
                        "broad":1,
                        "good":1,
                        "fit":1,
                        "oper":1,
                        "common":1,
                        "answer":1,
                        "usag":1,
                        "hot":1,
                        "special":1,
                        "reflect":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":23020426,
          "postId":16114597,
          "creationDate":"2013-04-20",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":149138,
            "displayName":"BeeOnRope",
            "reputation":3980
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"I don't think operator= can help here - the question seems geared towards primitives (hence the focus on `volatile`), and regardless Java doesn't have any ability to overload the = operation (which would be meaningless anyway since we are only talking about reference assignment here)."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[16114597-cu23020426]-[1504258651]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"I don't think operator= can help here - the question seems geared towards primitives (hence the focus on `volatile`), and regardless Java doesn't have any ability to overload the = operation (which would be meaningless anyway since we are only talking about reference assignment here)."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "question":1,
                        "overload":1,
                        "talk":1,
                        "assign":1,
                        "oper":2,
                        "gear":1,
                        "focus":1,
                        "refer":1,
                        "abil":1,
                        "primit":1,
                        "meaningless":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":23020555,
          "postId":16114597,
          "creationDate":"2013-04-20",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":555045,
            "displayName":"harold",
            "reputation":18666
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"You know compilers aren't filled with magic pixies, right? Compilers usually don't generate optimal code, they don't even pretend to do that. Especially when cache effects in multi-processor systems become relevant. Compilers are just not equipped to really take that into account. It would require knowledge that is too expensive to automatically infer."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[16114597-cu23020555]-[-456216911]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"You know compilers aren't filled with magic pixies, right? Compilers usually don't generate optimal code, they don't even pretend to do that. Especially when cache effects in multi-processor systems become relevant. Compilers are just not equipped to really take that into account. It would require knowledge that is too expensive to automatically infer."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "pixi":1,
                        "equip":1,
                        "cach":1,
                        "system":1,
                        "infer":1,
                        "knowledg":1,
                        "aren":1,
                        "requir":1,
                        "effect":1,
                        "relev":1,
                        "code":1,
                        "optim":1,
                        "automat":1,
                        "processor":1,
                        "fill":1,
                        "generat":1,
                        "magic":1,
                        "account":1,
                        "compil":3,
                        "expens":1,
                        "pretend":1,
                        "multi":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2013-04-19",
      "lastActivityDate":"2013-04-19",
      "score":8,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":2254782,
        "displayName":"alexrider",
        "reputation":3753
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>In general the answer is no. Since if you have simple datatype, compiler would be able to perform any necessary optimizations. And in case of types with heavy operator= it is responsibility of operator= to choose optimal way to assign new value.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16114597]-[1281400539]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>In general the answer is no. Since if you have simple datatype, compiler would be able to perform any necessary optimizations. And in case of types with heavy operator= it is responsibility of operator= to choose optimal way to assign new value.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "simpl":1,
                    "assign":1,
                    "oper":2,
                    "optim":2,
                    "datatyp":1,
                    "general":1,
                    "perform":1,
                    "heavi":1,
                    "answer":1,
                    "choos":1,
                    "compil":1,
                    "type":1,
                    "respons":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":16115489,
      "questionId":16114572,
      "comments":[
        
      ],
      "creationDate":"2013-04-20",
      "lastActivityDate":"2013-04-20",
      "score":4,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":144746,
        "displayName":"Voo",
        "reputation":12920
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>There are situations where even a trivial assignment of say a pointersized variable can be more expensive than a read and branch (especially if predictable).</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16115489]-[533036869]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>There are situations where even a trivial assignment of say a pointersized variable can be more expensive than a read and branch (especially if predictable).</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "branch":1,
                    "assign":1,
                    "situat":1,
                    "predict":1,
                    "expens":1,
                    "variabl":1,
                    "trivial":1,
                    "pointers":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Why? Multithreading. If several threads are only reading the same value, they can all share that value in their caches. But as soon as you write to it, you have to invalidate the cacheline and get the new value the next time you want to read it or you have to get the updated value to keep your cache coherent. Both situations lead to more traffic between the cores and add latency to the reads.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16115489]-[-1185487318]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Why? Multithreading. If several threads are only reading the same value, they can all share that value in their caches. But as soon as you write to it, you have to invalidate the cacheline and get the new value the next time you want to read it or you have to get the updated value to keep your cache coherent. Both situations lead to more traffic between the cores and add latency to the reads.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":3,
                    "lead":1,
                    "latenc":1,
                    "cach":2,
                    "updat":1,
                    "cachelin":1,
                    "share":1,
                    "situat":1,
                    "thread":1,
                    "multithread":1,
                    "invalid":1,
                    "traffic":1,
                    "time":1,
                    "core":1,
                    "add":1,
                    "coher":1,
                    "write":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>If the branch is pretty unpredictable though it's probably still slower.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[16115489]-[1309611072]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>If the branch is pretty unpredictable though it's probably still slower.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "pretti":1,
                    "branch":1,
                    "unpredict":1,
                    "slower":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}