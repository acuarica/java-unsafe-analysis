{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":1619593,
    "title":"What are &quot;typing models&quot;?",
    "comments":[
      
    ],
    "tags":[
      "java",
      "c++",
      "types",
      "type-theory"
    ],
    "creationDate":"2009-10-25",
    "lastActivityDate":"2009-10-25",
    "lastEditDate":"2009-10-25",
    "score":1,
    "viewCount":391,
    "owner":{
      "type":"StackOverflowUser",
      "id":82368,
      "displayName":"unj2",
      "reputation":10068
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>In Beyond Java(Section 2.2.9), Brute Tate claims that &quot;typing model&quot; is one of the problems of C++. What does that mean?</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[1619593]-[-1317343936]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>In Beyond Java(Section 2.2.9), Brute Tate claims that &quot;typing model&quot; is one of the problems of C++. What does that mean?</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "claim":1,
                  "model":1,
                  "problem":1,
                  "brute":1,
                  "section":1,
                  "quot":2,
                  "type":1,
                  "tate":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":1619598,
      "questionId":1619593,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":1486860,
          "postId":1619598,
          "creationDate":"2009-10-25",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":14065,
            "displayName":"Loki Astari",
            "reputation":126532
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Your points are well taken. But C++ is superior to C because of its strict static typing system. What you are talking about is the auto conversion between types (which unfortunately was inherited from C). Also Note: Conversion between two different enum is not valid (though unfortunately it does auto convert to int)."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[1619598-cu1486860]-[-607356837]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Your points are well taken. But C++ is superior to C because of its strict static typing system. What you are talking about is the auto conversion between types (which unfortunately was inherited from C). Also Note: Conversion between two different enum is not valid (though unfortunately it does auto convert to int)."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "strict":1,
                        "auto":2,
                        "point":1,
                        "system":1,
                        "superior":1,
                        "talk":1,
                        "inherit":1,
                        "note":1,
                        "convers":2,
                        "valid":1,
                        "type":2,
                        "convert":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2009-10-25",
      "lastActivityDate":"2009-10-25",
      "score":0,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":184528,
        "displayName":"cdiggins",
        "reputation":6244
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>That it is hard to type C++ code. :-p</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619598]-[-337600580]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>That it is hard to type C++ code. :-p</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "hard":1,
                    "type":1,
                    "code":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Seriously though, they are probably referring to the fact that C++ has a weak static type system, that can be easily circumvented. Some examples: typedefs are not real types, enumerated types are just ints, booleans and integers are equivalent in many cases, and so on. </p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619598]-[1880324562]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Seriously though, they are probably referring to the fact that C++ has a weak static type system, that can be easily circumvented. Some examples: typedefs are not real types, enumerated types are just ints, booleans and integers are equivalent in many cases, and so on. </p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "enumer":1,
                    "system":1,
                    "real":1,
                    "equival":1,
                    "exampl":1,
                    "weak":1,
                    "easili":1,
                    "fact":1,
                    "integ":1,
                    "boolean":1,
                    "typedef":1,
                    "int":1,
                    "refer":1,
                    "circumv":1,
                    "case":1,
                    "type":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":1619665,
      "questionId":1619593,
      "comments":[
        {
          "type":"StackOverflowComment",
          "id":1488022,
          "postId":1619665,
          "creationDate":"2009-10-25",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":33213,
            "displayName":"jalf",
            "reputation":153750
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Err, no abuse of C pointers is possible either. What you're doing is undefined behavior. It is no longer a C program. A C program is described by the C standard. Undefined behavior is not. If you don't respect the rules of the language, then yes, you can write some pure nonsense. But that's not because of any flaws in the language. It's because you didn't *know* the language you're using."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[1619665-cu1488022]-[1582843046]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Err, no abuse of C pointers is possible either. What you're doing is undefined behavior. It is no longer a C program. A C program is described by the C standard. Undefined behavior is not. If you don't respect the rules of the language, then yes, you can write some pure nonsense. But that's not because of any flaws in the language. It's because you didn't *know* the language you're using."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "program":2,
                        "languag":3,
                        "pointer":1,
                        "nonsens":1,
                        "standard":1,
                        "abus":1,
                        "rule":1,
                        "pure":1,
                        "flaw":1,
                        "undefin":2,
                        "err":1,
                        "respect":1,
                        "longer":1,
                        "behavior":2,
                        "write":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":1488100,
          "postId":1619665,
          "creationDate":"2009-10-25",
          "score":1,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":66517,
            "displayName":"pavpanchekha",
            "reputation":1398
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Not at all true. First of all, given that all compilers do the same thing when such abuse happens, you can hardly consider it undefined. Consider HTML, for example. The effects of invalid markup are undefined, but invalid markup nonetheless happens. And it mostly works anyway. Furthermore, the existence of `void*` pointers is part of the standard, and they are used in the standard library (well, the standard C library, but that's available in C++). The kernel of the matter is that in JAVA (and just about all modern languages), an `int` is an int, where in C++, an int is a bit pattern."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[1619665-cu1488100]-[-1494604720]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Not at all true. First of all, given that all compilers do the same thing when such abuse happens, you can hardly consider it undefined. Consider HTML, for example. The effects of invalid markup are undefined, but invalid markup nonetheless happens. And it mostly works anyway. Furthermore, the existence of `void*` pointers is part of the standard, and they are used in the standard library (well, the standard C library, but that's available in C++). The kernel of the matter is that in JAVA (and just about all modern languages), an `int` is an int, where in C++, an int is a bit pattern."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "nonetheless":1,
                        "kernel":1,
                        "languag":1,
                        "bit":1,
                        "pattern":1,
                        "pointer":1,
                        "exist":1,
                        "standard":3,
                        "effect":1,
                        "abus":1,
                        "thing":1,
                        "librari":2,
                        "work":1,
                        "modern":1,
                        "markup":2,
                        "invalid":2,
                        "undefin":2,
                        "true":1,
                        "compil":1,
                        "matter":1,
                        "part":1,
                        "html":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":1486916,
          "postId":1619665,
          "creationDate":"2009-10-25",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":14065,
            "displayName":"Loki Astari",
            "reputation":126532
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"You have show why C is not strictly typed not C++. The cast you use is a C cast a though it is usable from C++ it is still considered a C construct and it use is discouraged in preference to the C++ cast."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[1619665-cu1486916]-[-1448650608]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"You have show why C is not strictly typed not C++. The cast you use is a C cast a though it is usable from C++ it is still considered a C construct and it use is discouraged in preference to the C++ cast."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "strict":1,
                        "show":1,
                        "discourag":1,
                        "cast":3,
                        "consid":1,
                        "usabl":1,
                        "type":1,
                        "construct":1,
                        "prefer":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":1486937,
          "postId":1619665,
          "creationDate":"2009-10-25",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":14065,
            "displayName":"Loki Astari",
            "reputation":126532
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"This is a feature of C++ not detrimental. Admittedly it is open to abuse but it does not make it harder to write robust or secure software. Because of C++ strict static typing pointers are usually not random pointers (they may be because of abuse of reinterpret_cast&lt;&gt; or inexperienced programmers using C cast as above, but in good code that does not happen)."
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[1619665-cu1486937]-[1427378143]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"This is a feature of C++ not detrimental. Admittedly it is open to abuse but it does not make it harder to write robust or secure software. Because of C++ strict static typing pointers are usually not random pointers (they may be because of abuse of reinterpret_cast&lt;&gt; or inexperienced programmers using C cast as above, but in good code that does not happen)."
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"reinterpret_cast",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "random":1,
                        "strict":1,
                        "pointer":2,
                        "good":1,
                        "happen":1,
                        "inexperienc":1,
                        "abus":2,
                        "softwar":1,
                        "detriment":1,
                        "secur":1,
                        "open":1,
                        "code":1,
                        "reinterpret":1,
                        "cast":2,
                        "robust":1,
                        "programm":1,
                        "make":1,
                        "admit":1,
                        "featur":1,
                        "type":1,
                        "harder":1,
                        "write":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"StackOverflowComment",
          "id":1486959,
          "postId":1619665,
          "creationDate":"2009-10-25",
          "score":0,
          "isEdited":false,
          "owner":{
            "type":"StackOverflowUser",
            "id":86515,
            "displayName":"KitsuneYMG",
            "reputation":8030
          },
          "source":[
            {
              "type":"SourceInfo",
              "node":{
                "type":"XmlTextNode",
                "contents":"Java (sun's impl) does have pointers. See javadocs on sun.misc.Unsafe. Specifically getAddress(long address) and putAddress(long address, long x). Yes you have to use reflection to access Unsafe, and yes it isn't portable, but we are talking about intentional abuse here right?"
              },
              "units":[
                {
                  "type":"TextUnit",
                  "id":"[1619665-cu1486959]-[-2136995154]",
                  "astNode":{
                    "type":"TextFragmentNode",
                    "text":"Java (sun's impl) does have pointers. See javadocs on sun.misc.Unsafe. Specifically getAddress(long address) and putAddress(long address, long x). Yes you have to use reflection to access Unsafe, and yes it isn't portable, but we are talking about intentional abuse here right?"
                  },
                  "codeFragments":{
                    "type":"CodeFragmentSequence",
                    "fragments":[
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"getAddress",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"QualifiedIdentifierNode",
                        "identifiers":[
                          {
                            "type":"IdentifierNode",
                            "name":"putAddress",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      }
                    ]
                  },
                  "metaInformation":[
                    {
                      "type":"NaturalLanguageMetaInformation",
                      "tfMap":{
                        "pointer":1,
                        "portabl":1,
                        "intent":1,
                        "abus":1,
                        "sun":2,
                        "talk":1,
                        "impl":1,
                        "specif":1,
                        "isn":1,
                        "misc":1,
                        "address":4,
                        "put":1,
                        "unsaf":2,
                        "reflect":1,
                        "javadoc":1,
                        "access":1
                      }
                    },
                    {
                      "type":"CodeTypesMetaInformation",
                      "qualifiedTypes":[
                        
                      ],
                      "simpleTypes":[
                        
                      ],
                      "basicTypes":[
                        
                      ]
                    },
                    {
                      "type":"CodeInvocationMetaInformation",
                      "invocations":[
                        
                      ]
                    },
                    {
                      "type":"CodeVariablesMetaInformation",
                      "variables":[
                        
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "creationDate":"2009-10-25",
      "communityOwnedDate":"2009-10-25",
      "lastActivityDate":"2009-10-25",
      "lastEditDate":"2009-10-25",
      "score":3,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":66517,
        "displayName":"pavpanchekha",
        "reputation":1398
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>What he means is that objects in C++ don't intrinsically have types. While you might write</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[-894618245]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>What he means is that objects in C++ don't intrinsically have types. While you might write</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "mean":1,
                    "object":1,
                    "intrins":1,
                    "type":1,
                    "write":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"struct Dog { char* name; int breed; }; Dog ralph(&quot;Ralph&quot;, POODLE); "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[1619665]-[-2100218241]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"struct Dog { char* name; int breed; }; Dog "
                  },
                  {
                    "type":"MethodInvocationNode",
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"ralph",
                      "comments":[
                        
                      ]
                    },
                    "args":{
                      "type":"ExpressionListNode",
                      "arguments":[
                        {
                          "type":"LiteralNode",
                          "node":{
                            "type":"StringLiteralNode",
                            "valueRep":"\"Ralph\""
                          },
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"POODLE",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "rawText":"struct Dog { char* name; int breed; }; Dog ralph(\"Ralph\", POODLE); ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "dog":2,
                    "ralph":2,
                    "breed":1,
                    "struct":1,
                    "poodl":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    {
                      "type":"MethodInvocationNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"ralph",
                        "comments":[
                          
                        ]
                      },
                      "args":{
                        "type":"ExpressionListNode",
                        "arguments":[
                          {
                            "type":"LiteralNode",
                            "node":{
                              "type":"StringLiteralNode",
                              "valueRep":"\"Ralph\""
                            },
                            "comments":[
                              
                            ]
                          },
                          {
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"POODLE",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>in truth <code>ralph</code> doesn't have a type; it's just a bunch of bits, and the CPU doesn't give a damn about the fact that you call that collection of bits a <code>Dog</code>. For example, the following is valid:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[123796365]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>in truth <code>ralph</code> doesn't have a type; it's just a bunch of bits, and the CPU doesn't give a damn about the fact that you call that collection of bits a <code>Dog</code>. For example, the following is valid:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "bit":2,
                    "bunch":1,
                    "dog":1,
                    "code":4,
                    "fact":1,
                    "ralph":1,
                    "damn":1,
                    "cpu":1,
                    "valid":1,
                    "give":1,
                    "collect":1,
                    "type":1,
                    "truth":1,
                    "call":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlNode",
            "name":{
              "type":"XmlNameNode",
              "value":"pre"
            },
            "attributes":[
              
            ],
            "elements":[
              {
                "type":"XmlNode",
                "name":{
                  "type":"XmlNameNode",
                  "value":"code"
                },
                "attributes":[
                  
                ],
                "elements":[
                  {
                    "type":"XmlTextNode",
                    "contents":"struct Cat { int color; char* country_of_origin; }; Cat ralph_is_that_you = * (Cat*) &amp;ralph; "
                  }
                ]
              }
            ]
          },
          "units":[
            {
              "type":"StructuredFragmentUnit",
              "id":"[1619665]-[1569110837]",
              "astNode":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"TextFragmentNode",
                    "text":"struct Cat "
                  },
                  {
                    "type":"BlockDeclarationNode",
                    "modifiers":[
                      
                    ],
                    "block":{
                      "type":"BlockNode",
                      "statements":[
                        {
                          "type":"LocalVariableDeclarationStatementNode",
                          "modifiers":[
                            
                          ],
                          "declarators":{
                            "type":"VariableDeclaratorsNode",
                            "declarators":[
                              {
                                "type":"VariableDeclaratorNode",
                                "identifier":{
                                  "type":"IdentifierNode",
                                  "name":"color",
                                  "comments":[
                                    
                                  ]
                                },
                                "arrayDepth":[
                                  
                                ],
                                "varType":{
                                  "type":"PrimitiveTypeNode",
                                  "name":"int",
                                  "comments":[
                                    
                                  ]
                                }
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ],
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"TextFragmentNode",
                          "text":"char"
                        },
                        {
                          "type":"TextFragmentNode",
                          "text":"*"
                        },
                        {
                          "type":"TextFragmentNode",
                          "text":" "
                        },
                        {
                          "type":"ExpressionStatement",
                          "expression":{
                            "type":"QualifiedIdentifierNode",
                            "identifiers":[
                              {
                                "type":"IdentifierNode",
                                "name":"country_of_origin",
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "labels":[
                            
                          ]
                        }
                      ],
                      "labels":[
                        
                      ],
                      "comments":[
                        
                      ]
                    }
                  },
                  {
                    "type":"TextFragmentNode",
                    "text":"; Cat "
                  },
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"ralph_is_that_you",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"TextFragmentNode",
                    "text":" = * (Cat*) &ralph; "
                  }
                ]
              },
              "rawText":"struct Cat { int color; char* country_of_origin; }; Cat ralph_is_that_you = * (Cat*) &ralph; ",
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "countri":1,
                    "color":1,
                    "ralph":2,
                    "origin":1,
                    "struct":1,
                    "cat":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    {
                      "type":"PrimitiveTypeNode",
                      "name":"int",
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    {
                      "type":"VariableDeclaratorNode",
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"color",
                        "comments":[
                          
                        ]
                      },
                      "arrayDepth":[
                        
                      ],
                      "varType":{
                        "type":"PrimitiveTypeNode",
                        "name":"int",
                        "comments":[
                          
                        ]
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Watch in wonder as Professor C performs trans-species mutations between <code>Dog</code>s and <code>Cat</code>s! The point here is that since <code>ralph</code> is just a sequence of bits, you can just claim that that sequence of bits is really a <code>Cat</code> and nothing would go wrong... except that the &quot;<code>Cat</code>&quot;'s color would be some random large integer, and you better not try to read it's country of origin. The fundamental problems is that while a variable (as in, the name, not the object it represents) has a type, the underlying object does not.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[-1806805242]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Watch in wonder as Professor C performs trans-species mutations between <code>Dog</code>s and <code>Cat</code>s! The point here is that since <code>ralph</code> is just a sequence of bits, you can just claim that that sequence of bits is really a <code>Cat</code> and nothing would go wrong... except that the &quot;<code>Cat</code>&quot;'s color would be some random large integer, and you better not try to read it's country of origin. The fundamental problems is that while a variable (as in, the name, not the object it represents) has a type, the underlying object does not.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":1,
                    "random":1,
                    "point":1,
                    "claim":1,
                    "bit":2,
                    "professor":1,
                    "wrong":1,
                    "countri":1,
                    "problem":1,
                    "speci":1,
                    "watch":1,
                    "dog":1,
                    "color":1,
                    "mutat":1,
                    "object":2,
                    "code":10,
                    "ralph":1,
                    "larg":1,
                    "sequenc":2,
                    "origin":1,
                    "perform":1,
                    "quot":2,
                    "under":1,
                    "type":1,
                    "variabl":1,
                    "cat":3,
                    "fundament":1,
                    "repres":1,
                    "tran":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Compare this with JAVA, where not only types, but objects have intrinsic types. This may be due partly to the fact that there are no pointers and thus no access to memory, but the fact nonetheless exists that if you cast a <code>Dog</code> to an <code>Object</code>, you can't cast it back down to a <code>Cat</code>, because the object knows that deep down, it's actually a <code>Dog</code>, not a <code>Cat</code>.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[-1591351824]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Compare this with JAVA, where not only types, but objects have intrinsic types. This may be due partly to the fact that there are no pointers and thus no access to memory, but the fact nonetheless exists that if you cast a <code>Dog</code> to an <code>Object</code>, you can't cast it back down to a <code>Cat</code>, because the object knows that deep down, it's actually a <code>Dog</code>, not a <code>Cat</code>.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "nonetheless":1,
                    "due":1,
                    "pointer":1,
                    "exist":1,
                    "dog":2,
                    "object":3,
                    "code":10,
                    "fact":2,
                    "cast":2,
                    "deep":1,
                    "compar":1,
                    "back":1,
                    "intrins":1,
                    "part":1,
                    "type":2,
                    "cat":2,
                    "access":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>The weak typing present in C++ is rather detrimental, because it makes the compiler static type checks nearly useless if you want to truly abuse-proof your application, and also makes secure and robust software hard to write. For example, you need to be very careful whenever you access a &quot;pointer&quot; because it could really be any random bit pattern.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[-990600681]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>The weak typing present in C++ is rather detrimental, because it makes the compiler static type checks nearly useless if you want to truly abuse-proof your application, and also makes secure and robust software hard to write. For example, you need to be very careful whenever you access a &quot;pointer&quot; because it could really be any random bit pattern.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "random":1,
                    "bit":1,
                    "useless":1,
                    "hard":1,
                    "pattern":1,
                    "pointer":1,
                    "present":1,
                    "weak":1,
                    "abus":1,
                    "softwar":1,
                    "detriment":1,
                    "secur":1,
                    "care":1,
                    "check":1,
                    "robust":1,
                    "applic":1,
                    "proof":1,
                    "make":2,
                    "quot":2,
                    "compil":1,
                    "type":2,
                    "write":1,
                    "access":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><strong>EDIT 1: The comments had very good points, and I'd like to add them here.</strong></p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[1940243025]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><strong>EDIT 1: The comments had very good points, and I'd like to add them here.</strong></p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "point":1,
                    "good":1,
                    "strong":2,
                    "edit":1,
                    "comment":1,
                    "add":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><a href=\"http://stackoverflow.com/users/71859/kts\"title=\"kts\">kts</a> points out that Sun's JAVA does indeed have pointers if you look deeply enough. Thanks! I hadn't known, and that's rather cool. However, the fundamental point is that JAVA objects <em>are</em> typed and C types aren't. Yes, you can circumvent this, but this is the same as the difference between opt-in and opt-out spam: yes, you could abuse the JAVA pointers, but the default is that no abuse is possible. You'd have to opt in.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[-307599484]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><a href=\"http://stackoverflow.com/users/71859/kts\"title=\"kts\">kts</a> points out that Sun's JAVA does indeed have pointers if you look deeply enough. Thanks! I hadn't known, and that's rather cool. However, the fundamental point is that JAVA objects <em>are</em> typed and C types aren't. Yes, you can circumvent this, but this is the same as the difference between opt-in and opt-out spam: yes, you could abuse the JAVA pointers, but the default is that no abuse is possible. You'd have to opt in.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "kts":3,
                    "point":2,
                    "opt":3,
                    "pointer":2,
                    "aren":1,
                    "differ":1,
                    "abus":2,
                    "sun":1,
                    "titl":1,
                    "object":1,
                    "stackoverflow":1,
                    "cool":1,
                    "hadn":1,
                    "circumv":1,
                    "type":2,
                    "href":1,
                    "spam":1,
                    "http":1,
                    "deepli":1,
                    "fundament":1,
                    "user":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p><a href=\"http://stackoverflow.com/users/14065/martin-york\"title=\"martin-york\">martin-york</a> points out that the example I showed is a purely C phenomenon. This is true, but</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[-1640499505]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p><a href=\"http://stackoverflow.com/users/14065/martin-york\"title=\"martin-york\">martin-york</a> points out that the example I showed is a purely C phenomenon. This is true, but</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "point":1,
                    "martin":3,
                    "show":1,
                    "phenomenon":1,
                    "titl":1,
                    "pure":1,
                    "stackoverflow":1,
                    "true":1,
                    "href":1,
                    "http":1,
                    "user":1,
                    "york":3
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<ol> \n <li>C++ mostly contains C as a subset (the differences are usually too minor to list).</li> \n <li>C++ includes <code>reinterpret_cast&lt;T&gt;</code> specifically to allow hacks like this.</li> \n <li>Just because it's discouraged doesn't mean it isn't pervasive or dangerous. Basically, even if JAVA has opt-in pointers (as I'll call them), the fact is that the person using them has probably thought of the consequences. C's casts are so easy that they're at times done without thinking (To quote Stroustroup, &quot;But the new syntax was made deliberately ugly, because casting is still an ugly and often unsafe operation.&quot;). There's also the fact that the work needed to circumvent JAVA's type system is far more than what would make for a clever hack, while circumventing the C type system (and, yes, the C++ type system) is easy enough that I've seen it done just for a minor performance boost.</li> \n</ol>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[-1446630073]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<ol> \n <li>C++ mostly contains C as a subset (the differences are usually too minor to list).</li> \n <li>C++ includes <code>reinterpret_cast&lt;T&gt;</code> specifically to allow hacks like this.</li> \n <li>Just because it's discouraged doesn't mean it isn't pervasive or dangerous. Basically, even if JAVA has opt-in pointers (as I'll call them), the fact is that the person using them has probably thought of the consequences. C's casts are so easy that they're at times done without thinking (To quote Stroustroup, &quot;But the new syntax was made deliberately ugly, because casting is still an ugly and often unsafe operation.&quot;). There's also the fact that the work needed to circumvent JAVA's type system is far more than what would make for a clever hack, while circumventing the C type system (and, yes, the C++ type system) is easy enough that I've seen it done just for a minor performance boost.</li> \n</ol>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"QualifiedIdentifierNode",
                    "identifiers":[
                      {
                        "type":"IdentifierNode",
                        "name":"reinterpret_cast",
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"XmlNode",
                    "name":{
                      "type":"XmlNameNode",
                      "value":"T"
                    },
                    "attributes":[
                      
                    ],
                    "elements":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "easi":2,
                    "opt":1,
                    "system":3,
                    "pointer":1,
                    "thought":1,
                    "discourag":1,
                    "differ":1,
                    "stroustroup":1,
                    "clever":1,
                    "deliber":1,
                    "pervas":1,
                    "work":1,
                    "includ":1,
                    "code":2,
                    "oper":1,
                    "fact":2,
                    "syntax":1,
                    "consequ":1,
                    "reinterpret":1,
                    "cast":3,
                    "need":1,
                    "boost":1,
                    "subset":1,
                    "think":1,
                    "specif":1,
                    "perform":1,
                    "isn":1,
                    "person":1,
                    "make":1,
                    "ugli":2,
                    "quot":3,
                    "hack":2,
                    "circumv":2,
                    "unsaf":1,
                    "time":1,
                    "type":3,
                    "basic":1,
                    "call":1,
                    "made":1,
                    "list":1,
                    "danger":1,
                    "minor":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Anyway, discouraging something doesn't make it not happen. I discourage bad coding, but I haven't seen it get me anywhere...</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[-628684479]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Anyway, discouraging something doesn't make it not happen. I discourage bad coding, but I haven't seen it get me anywhere...</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "discourag":2,
                    "happen":1,
                    "bad":1,
                    "code":1,
                    "make":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>As for the feature being useful, it admittedly is (just look up &quot;fast inverse square root&quot; on Google or Wikipedia) but it is dangerous enough that, following Stroustroup's maxim that ugly operations should be ugly, the difficulty threshold should be significantly higher.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[1619665]-[-858207525]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>As for the feature being useful, it admittedly is (just look up &quot;fast inverse square root&quot; on Google or Wikipedia) but it is dangerous enough that, following Stroustroup's maxim that ugly operations should be ugly, the difficulty threshold should be significantly higher.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "invers":1,
                    "googl":1,
                    "root":1,
                    "higher":1,
                    "stroustroup":1,
                    "difficulti":1,
                    "oper":1,
                    "wikipedia":1,
                    "maxim":1,
                    "signific":1,
                    "threshold":1,
                    "admit":1,
                    "ugli":2,
                    "quot":2,
                    "fast":1,
                    "featur":1,
                    "squar":1,
                    "danger":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}