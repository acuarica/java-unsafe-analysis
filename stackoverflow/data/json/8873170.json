{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":8873170,
    "title":"java: volatile array to publish data change",
    "comments":[
      
    ],
    "tags":[
      "java",
      "multithreading",
      "volatile"
    ],
    "creationDate":"2012-01-15",
    "lastActivityDate":"2012-01-15",
    "score":1,
    "viewCount":210,
    "owner":{
      "type":"StackOverflowUser",
      "id":403700,
      "displayName":"Andy Nuss",
      "reputation":400
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I have a complex map, which doesn't need locking for the frequent gets and infrequent changes, because the keys uniquely determine the behavior of their referenced elements.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[8873170]-[2094450815]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I have a complex map, which doesn't need locking for the frequent gets and infrequent changes, because the keys uniquely determine the behavior of their referenced elements.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "infrequ":1,
                  "uniqu":1,
                  "determin":1,
                  "map":1,
                  "lock":1,
                  "element":1,
                  "key":1,
                  "behavior":1,
                  "referenc":1,
                  "frequent":1,
                  "complex":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>That is, if the key is the same, the structure it references will always have the same behavior. In fact, the key is immutable final and the referenced value is effectively final and/or threadsafe.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[8873170]-[-1469284570]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>That is, if the key is the same, the structure it references will always have the same behavior. In fact, the key is immutable final and the referenced value is effectively final and/or threadsafe.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "threadsaf":1,
                  "effect":1,
                  "immut":1,
                  "structur":1,
                  "key":2,
                  "fact":1,
                  "refer":1,
                  "behavior":1,
                  "referenc":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Lets say I have a volatile reference to the underlying volatile array of references in my custom hashmap. My hashmap algorithm for this array uses the ar.length member as the modulus so if in the get function, the caller sees a non-current array, all of its references will still be good, and still obey the hashing slots, so if it succeeds without mutex to get a non-null value, that's the right one.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[8873170]-[-1791281731]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Lets say I have a volatile reference to the underlying volatile array of references in my custom hashmap. My hashmap algorithm for this array uses the ar.length member as the modulus so if in the get function, the caller sees a non-current array, all of its references will still be good, and still obey the hashing slots, so if it succeeds without mutex to get a non-null value, that's the right one.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "succeed":1,
                  "custom":1,
                  "good":1,
                  "hashmap":2,
                  "mutex":1,
                  "array":3,
                  "hash":1,
                  "algorithm":1,
                  "member":1,
                  "function":1,
                  "refer":3,
                  "modulus":1,
                  "under":1,
                  "length":1,
                  "current":1,
                  "slot":1,
                  "see":1,
                  "let":1,
                  "obey":1,
                  "caller":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>My plan is whenever a get fails, the caller then constructs the correct value for the key does a put which does locking relative to other puts and stuffs an object into the array. Just before exiting the critical section the put code reassigns the volatile array field &quot;ar&quot; to itself, hopefully as a message to the compiler and hotspot compiler to create a fence relative to the gets which use the volatile array reference to find a hashed value.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[8873170]-[1010665548]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>My plan is whenever a get fails, the caller then constructs the correct value for the key does a put which does locking relative to other puts and stuffs an object into the array. Just before exiting the critical section the put code reassigns the volatile array field &quot;ar&quot; to itself, hopefully as a message to the compiler and hotspot compiler to create a fence relative to the gets which use the volatile array reference to find a hashed value.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "find":1,
                  "fail":1,
                  "critic":1,
                  "field":1,
                  "relat":2,
                  "fenc":1,
                  "correct":1,
                  "lock":1,
                  "section":1,
                  "hotspot":1,
                  "object":1,
                  "key":1,
                  "code":1,
                  "array":3,
                  "hash":1,
                  "stuff":1,
                  "refer":1,
                  "exit":1,
                  "put":3,
                  "quot":2,
                  "compil":2,
                  "messag":1,
                  "creat":1,
                  "construct":1,
                  "plan":1,
                  "reassign":1,
                  "caller":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>This will work as long as the compiler doesn't nop the &quot;ar = ar&quot; assignment:</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[8873170]-[-231483200]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>This will work as long as the compiler doesn't nop the &quot;ar = ar&quot; assignment:</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "nop":1,
                  "assign":1,
                  "work":1,
                  "quot":2,
                  "compil":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlNode",
          "name":{
            "type":"XmlNameNode",
            "value":"pre"
          },
          "attributes":[
            
          ],
          "elements":[
            {
              "type":"XmlNode",
              "name":{
                "type":"XmlNameNode",
                "value":"code"
              },
              "attributes":[
                
              ],
              "elements":[
                {
                  "type":"XmlTextNode",
                  "contents":"private volatile Object[] ar; public Object get (Object key) { Object[] ar = this.ar; // get the value from the correct hash slot } public synchronized Object put (Object key, Object val) { { ... stuff a new object into the correct hash slot ar = ar; // will the compiler truly compile this statement with // normal volatile fencing relative to the get function?? ... if a race condition causes a value to already be mapped, return and use that ... rather than the one we created and passed to put (different than normal put ... contract) } "
                }
              ]
            }
          ]
        },
        "units":[
          {
            "type":"StructuredFragmentUnit",
            "id":"[8873170]-[1851159913]",
            "astNode":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"FieldDeclaratorNode",
                  "modifiers":[
                    {
                      "type":"KeywordModifierNode",
                      "value":"private",
                      "comments":[
                        
                      ]
                    },
                    {
                      "type":"KeywordModifierNode",
                      "value":"volatile",
                      "comments":[
                        
                      ]
                    }
                  ],
                  "variables":{
                    "type":"VariableDeclaratorsNode",
                    "declarators":[
                      {
                        "type":"VariableDeclaratorNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"ar",
                          "comments":[
                            
                          ]
                        },
                        "arrayDepth":[
                          
                        ],
                        "varType":{
                          "type":"ArrayTypeNode",
                          "typeNode":{
                            "type":"ReferenceTypeNode",
                            "ids":[
                              {
                                "type":"ParameterizedTypeNode",
                                "identifier":{
                                  "type":"IdentifierNode",
                                  "name":"Object",
                                  "comments":[
                                    
                                  ]
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "depth":[
                            {
                              "type":"ArrayDimensionNode",
                              "comments":[
                                
                              ]
                            }
                          ]
                        }
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  "comments":[
                    
                  ]
                },
                {
                  "type":"MethodDeclaratorNode",
                  "modifiers":[
                    {
                      "type":"KeywordModifierNode",
                      "value":"public",
                      "comments":[
                        
                      ]
                    }
                  ],
                  "returnType":{
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"Object",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  },
                  "identifier":{
                    "type":"IdentifierNode",
                    "name":"get",
                    "comments":[
                      
                    ]
                  },
                  "parameters":{
                    "type":"FormalParametersNode",
                    "parameters":{
                      "type":"FormalParameterDeclsNode",
                      "modifiers":[
                        
                      ],
                      "parameterType":{
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"Object",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "nextDeclarator":{
                        "type":"AdditionalFormalParameterDeclNode",
                        "variableDeclarator":{
                          "type":"VariableDeclaratorNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"key",
                            "comments":[
                              
                            ]
                          },
                          "arrayDepth":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    },
                    "comments":[
                      
                    ]
                  },
                  "arrayReturnType":[
                    
                  ],
                  "body":{
                    "type":"BlockNode",
                    "statements":[
                      {
                        "type":"LocalVariableDeclarationStatementNode",
                        "modifiers":[
                          
                        ],
                        "declarators":{
                          "type":"VariableDeclaratorsNode",
                          "declarators":[
                            {
                              "type":"VariableDeclaratorNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"ar",
                                "comments":[
                                  
                                ]
                              },
                              "arrayDepth":[
                                
                              ],
                              "assignment":{
                                "type":"VariableAssignmentNode",
                                "variableAssignment":{
                                  "type":"VariableExpressionInitNode",
                                  "expression":{
                                    "type":"QualifiedIdentifierNode",
                                    "identifiers":[
                                      {
                                        "type":"IdentifierNode",
                                        "name":"this",
                                        "comments":[
                                          
                                        ]
                                      },
                                      {
                                        "type":"IdentifierNode",
                                        "name":"ar",
                                        "comments":[
                                          
                                        ]
                                      }
                                    ],
                                    "comments":[
                                      
                                    ]
                                  }
                                },
                                "comments":[
                                  
                                ]
                              },
                              "varType":{
                                "type":"ArrayTypeNode",
                                "typeNode":{
                                  "type":"ReferenceTypeNode",
                                  "ids":[
                                    {
                                      "type":"ParameterizedTypeNode",
                                      "identifier":{
                                        "type":"IdentifierNode",
                                        "name":"Object",
                                        "comments":[
                                          
                                        ]
                                      },
                                      "comments":[
                                        
                                      ]
                                    }
                                  ],
                                  "comments":[
                                    
                                  ]
                                },
                                "depth":[
                                  {
                                    "type":"ArrayDimensionNode",
                                    "comments":[
                                      
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "labels":[
                          
                        ],
                        "comments":[
                          {
                            "text":"// get the value from the correct hash slot } public synchronized Object put (Object key, Object val) { { ... stuff a new object into the correct hash slot ar = ar; // will the compiler truly compile this statement with // normal volatile fencing relative to the get function?? ... if a race condition causes a value to already be mapped, return and use that ... rather than the one we created and passed to put (different than normal put ... contract) } \n"
                          }
                        ]
                      }
                    ],
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  },
                  "comments":[
                    
                  ]
                }
              ]
            },
            "rawText":"private volatile Object[] ar; public Object get (Object key) { Object[] ar = this.ar; // get the value from the correct hash slot } public synchronized Object put (Object key, Object val) { { ... stuff a new object into the correct hash slot ar = ar; // will the compiler truly compile this statement with // normal volatile fencing relative to the get function?? ... if a race condition causes a value to already be mapped, return and use that ... rather than the one we created and passed to put (different than normal put ... contract) } \n...\n}",
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "relat":1,
                  "map":1,
                  "fenc":1,
                  "normal":2,
                  "condit":1,
                  "correct":2,
                  "statement":1,
                  "object":8,
                  "key":2,
                  "hash":2,
                  "race":1,
                  "function":1,
                  "stuff":1,
                  "pass":1,
                  "put":3,
                  "compil":2,
                  "slot":2,
                  "creat":1,
                  "val":1,
                  "contract":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"Object",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  {
                    "type":"VariableDeclaratorNode",
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"ar",
                      "comments":[
                        
                      ]
                    },
                    "arrayDepth":[
                      
                    ],
                    "varType":{
                      "type":"ArrayTypeNode",
                      "typeNode":{
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"Object",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "depth":[
                        {
                          "type":"ArrayDimensionNode",
                          "comments":[
                            
                          ]
                        }
                      ]
                    }
                  },
                  {
                    "type":"VariableDeclaratorNode",
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"key",
                      "comments":[
                        
                      ]
                    },
                    "arrayDepth":[
                      
                    ]
                  },
                  {
                    "type":"VariableDeclaratorNode",
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"ar",
                      "comments":[
                        
                      ]
                    },
                    "arrayDepth":[
                      
                    ],
                    "assignment":{
                      "type":"VariableAssignmentNode",
                      "variableAssignment":{
                        "type":"VariableExpressionInitNode",
                        "expression":{
                          "type":"QualifiedIdentifierNode",
                          "identifiers":[
                            {
                              "type":"IdentifierNode",
                              "name":"this",
                              "comments":[
                                
                              ]
                            },
                            {
                              "type":"IdentifierNode",
                              "name":"ar",
                              "comments":[
                                
                              ]
                            }
                          ],
                          "comments":[
                            
                          ]
                        }
                      },
                      "comments":[
                        
                      ]
                    },
                    "varType":{
                      "type":"ArrayTypeNode",
                      "typeNode":{
                        "type":"ReferenceTypeNode",
                        "ids":[
                          {
                            "type":"ParameterizedTypeNode",
                            "identifier":{
                              "type":"IdentifierNode",
                              "name":"Object",
                              "comments":[
                                
                              ]
                            },
                            "comments":[
                              
                            ]
                          }
                        ],
                        "comments":[
                          
                        ]
                      },
                      "depth":[
                        {
                          "type":"ArrayDimensionNode",
                          "comments":[
                            
                          ]
                        }
                      ]
                    }
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":8873300,
      "questionId":8873170,
      "comments":[
        
      ],
      "creationDate":"2012-01-15",
      "lastActivityDate":"2012-01-15",
      "score":2,
      "isAccepted":true,
      "owner":{
        "type":"StackOverflowUser",
        "id":144746,
        "displayName":"Voo",
        "reputation":12920
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>A volatile write can't be optimized away, so yes you'll get the memory guarantees here. And since reading a value from an array also (at least conceptually) means that you read the volatile variable of the array you should get one guaranteed volatile read either.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[8873300]-[1018548345]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>A volatile write can't be optimized away, so yes you'll get the memory guarantees here. And since reading a value from an array also (at least conceptually) means that you read the volatile variable of the array you should get one guaranteed volatile read either.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "read":3,
                    "mean":1,
                    "array":2,
                    "guarante":2,
                    "optim":1,
                    "variabl":1,
                    "conceptu":1,
                    "write":1,
                    "memori":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>So while this should work - if you're using Hotspot the usual way to do this is with <code>sun.misc.Unsafe</code> - you can look at the concurrent collections in Java5 upwards where that pattern is demonstrated often enough. (And yes we can all look forward to getting arrays of volatile elements in the future - afaik Doug Lea and Co are working on a specification for that, but no idea how far they are.)</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[8873300]-[14937315]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>So while this should work - if you're using Hotspot the usual way to do this is with <code>sun.misc.Unsafe</code> - you can look at the concurrent collections in Java5 upwards where that pattern is demonstrated often enough. (And yes we can all look forward to getting arrays of volatile elements in the future - afaik Doug Lea and Co are working on a specification for that, but no idea how far they are.)</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"sun",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"misc",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"Unsafe",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "concurr":1,
                    "pattern":1,
                    "doug":1,
                    "idea":1,
                    "sun":1,
                    "afaik":1,
                    "forward":1,
                    "demonstr":1,
                    "work":2,
                    "hotspot":1,
                    "element":1,
                    "code":2,
                    "array":1,
                    "futur":1,
                    "usual":1,
                    "specif":1,
                    "misc":1,
                    "unsaf":1,
                    "collect":1,
                    "upward":1,
                    "lea":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"sun",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"misc",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        },
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"Unsafe",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Although the question is why you implement this yourself - there's Cliff's non blocking hashmap that has some pretty strong correctness guarantees (afaik they checked it with CHESS for one and lots of people have looked at the underlying state machine) and excellent performance compared to the ConcurrentHashMap from the JDK.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[8873300]-[1251045247]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Although the question is why you implement this yourself - there's Cliff's non blocking hashmap that has some pretty strong correctness guarantees (afaik they checked it with CHESS for one and lots of people have looked at the underlying state machine) and excellent performance compared to the ConcurrentHashMap from the JDK.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"ConcurrentHashMap",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "question":1,
                    "chess":1,
                    "concurr":1,
                    "state":1,
                    "map":1,
                    "correct":1,
                    "look":1,
                    "hashmap":1,
                    "afaik":1,
                    "strong":1,
                    "pretti":1,
                    "excel":1,
                    "guarante":1,
                    "block":1,
                    "hash":1,
                    "check":1,
                    "machin":1,
                    "compar":1,
                    "cliff":1,
                    "perform":1,
                    "implement":1,
                    "lot":1,
                    "under":1,
                    "peopl":1,
                    "jdk":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    {
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"ConcurrentHashMap",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>And certainly faster than having a synchronized <code>put</code> operation.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[8873300]-[-1456982426]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>And certainly faster than having a synchronized <code>put</code> operation.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "put":1,
                    "faster":1,
                    "oper":1,
                    "code":2
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}