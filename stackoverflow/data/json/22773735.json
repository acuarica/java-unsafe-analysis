{
  "type":"StackOverflowArtifact",
  "question":{
    "type":"StackOverflowQuestion",
    "id":22773735,
    "title":"How to perform white box testing on void methods?",
    "comments":[
      {
        "type":"StackOverflowComment",
        "id":34720828,
        "postId":22773735,
        "creationDate":"2014-03-31",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":2864740,
          "displayName":"user2864740",
          "reputation":26567
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"I recommend testing at the class/contract level for &quot;non-pure&quot; methods. Modifying the original method just to facilitate testing (i.e. &quot;print&quot; or &quot;counter&quot;) should *not* be done, but use of interfaces can really help out mocking.. also, separating the UI from the controlling logic *really* helps testability."
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[22773735-cu34720828]-[-362789515]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"I recommend testing at the class/contract level for &quot;non-pure&quot; methods. Modifying the original method just to facilitate testing (i.e. &quot;print&quot; or &quot;counter&quot;) should *not* be done, but use of interfaces can really help out mocking.. also, separating the UI from the controlling logic *really* helps testability."
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "recommend":1,
                      "method":2,
                      "test":2,
                      "mock":1,
                      "print":1,
                      "separ":1,
                      "interfac":1,
                      "pure":1,
                      "logic":1,
                      "help":1,
                      "origin":1,
                      "modifi":1,
                      "testabl":1,
                      "counter":1,
                      "quot":6,
                      "control":1,
                      "facilit":1,
                      "contract":1,
                      "level":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"StackOverflowComment",
        "id":34896189,
        "postId":22773735,
        "creationDate":"2014-04-04",
        "score":0,
        "isEdited":false,
        "owner":{
          "type":"StackOverflowUser",
          "id":3300451,
          "displayName":"jf1034",
          "reputation":5
        },
        "source":[
          {
            "type":"SourceInfo",
            "node":{
              "type":"XmlTextNode",
              "contents":"@user2864740, your comment is actually the answer that I'd pick. Can you post it as an answer? It also correlates with my professor's response to the question: 1) test &quot;non-pure&quot; methods at the class level (need to test in the GUI's true environment) and 2) add print/counter statements for debugging purposes only, not for testing. I will try to separate the UI from the controlling logic. Thanks for everyone's advice!"
            },
            "units":[
              {
                "type":"TextUnit",
                "id":"[22773735-cu34896189]-[1001570290]",
                "astNode":{
                  "type":"TextFragmentNode",
                  "text":"@user2864740, your comment is actually the answer that I'd pick. Can you post it as an answer? It also correlates with my professor's response to the question: 1) test &quot;non-pure&quot; methods at the class level (need to test in the GUI's true environment) and 2) add print/counter statements for debugging purposes only, not for testing. I will try to separate the UI from the controlling logic. Thanks for everyone's advice!"
                },
                "codeFragments":{
                  "type":"CodeFragmentSequence",
                  "fragments":[
                    {
                      "type":"ClassDeclarationNode",
                      "modifiers":[
                        
                      ],
                      "identifier":{
                        "type":"IdentifierNode",
                        "name":"level",
                        "comments":[
                          
                        ]
                      },
                      "labels":[
                        
                      ],
                      "comments":[
                        
                      ]
                    }
                  ]
                },
                "metaInformation":[
                  {
                    "type":"NaturalLanguageMetaInformation",
                    "tfMap":{
                      "question":1,
                      "method":1,
                      "post":1,
                      "test":3,
                      "professor":1,
                      "advic":1,
                      "print":1,
                      "separ":1,
                      "statement":1,
                      "pure":1,
                      "logic":1,
                      "debug":1,
                      "correl":1,
                      "pick":1,
                      "comment":1,
                      "true":1,
                      "answer":2,
                      "counter":1,
                      "quot":2,
                      "control":1,
                      "respons":1,
                      "environ":1,
                      "add":1,
                      "purpos":1,
                      "gui":1,
                      "user":1,
                      "level":1
                    }
                  },
                  {
                    "type":"CodeTypesMetaInformation",
                    "qualifiedTypes":[
                      
                    ],
                    "simpleTypes":[
                      
                    ],
                    "basicTypes":[
                      
                    ]
                  },
                  {
                    "type":"CodeInvocationMetaInformation",
                    "invocations":[
                      
                    ]
                  },
                  {
                    "type":"CodeVariablesMetaInformation",
                    "variables":[
                      
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "tags":[
      "java",
      "swing",
      "unit-testing"
    ],
    "creationDate":"2014-03-31",
    "lastActivityDate":"2014-03-31",
    "score":0,
    "viewCount":65,
    "owner":{
      "type":"StackOverflowUser",
      "id":3300451,
      "displayName":"jf1034",
      "reputation":5
    },
    "source":[
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>I am trying to perform white box testing on the method below. It's a method for blinking an array list (lightUpSequence) of JButtons in Swing using a timer. </p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[22773735]-[1740996155]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>I am trying to perform white box testing on the method below. It's a method for blinking an array list (lightUpSequence) of JButtons in Swing using a timer. </p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"QualifiedIdentifierNode",
                  "identifiers":[
                    {
                      "type":"IdentifierNode",
                      "name":"lightUpSequence",
                      "comments":[
                        
                      ]
                    }
                  ],
                  "comments":[
                    
                  ]
                }
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "method":2,
                  "test":1,
                  "swing":1,
                  "array":1,
                  "blink":1,
                  "sequenc":1,
                  "jbutton":1,
                  "perform":1,
                  "box":1,
                  "light":1,
                  "white":1,
                  "timer":1,
                  "list":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>My question is as follows:</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[22773735]-[-21153791]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>My question is as follows:</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "question":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>since this is a void method, how would one check the expected output? I plan to create different sizes of array lists as the inputs. For white box testing, is one allowed to add any codes such as print/counter statements inside the method being tested? I feel hesitant to add any modifications to the method and think that the method should be tested as is.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[22773735]-[-1021638775]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>since this is a void method, how would one check the expected output? I plan to create different sizes of array lists as the inputs. For white box testing, is one allowed to add any codes such as print/counter statements inside the method being tested? I feel hesitant to add any modifications to the method and think that the method should be tested as is.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "method":4,
                  "test":3,
                  "feel":1,
                  "size":1,
                  "print":1,
                  "modif":1,
                  "statement":1,
                  "code":1,
                  "array":1,
                  "check":1,
                  "insid":1,
                  "allow":1,
                  "hesit":1,
                  "expect":1,
                  "counter":1,
                  "box":1,
                  "output":1,
                  "creat":1,
                  "add":2,
                  "white":1,
                  "input":1,
                  "plan":1,
                  "list":1
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlTextNode",
          "contents":"<p>Thank you very much.</p>"
        },
        "units":[
          {
            "type":"TextUnit",
            "id":"[22773735]-[-2064015463]",
            "astNode":{
              "type":"TextFragmentNode",
              "text":"<p>Thank you very much.</p>"
            },
            "codeFragments":{
              "type":"CodeFragmentSequence",
              "fragments":[
                
              ]
            },
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  
                ],
                "basicTypes":[
                  
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  
                ]
              }
            ]
          }
        ]
      },
      {
        "type":"SourceInfo",
        "node":{
          "type":"XmlNode",
          "name":{
            "type":"XmlNameNode",
            "value":"pre"
          },
          "attributes":[
            
          ],
          "elements":[
            {
              "type":"XmlNode",
              "name":{
                "type":"XmlNameNode",
                "value":"code"
              },
              "attributes":[
                
              ],
              "elements":[
                {
                  "type":"XmlTextNode",
                  "contents":" private void blinkSequence() { final Timer timer = new Timer(BLINKING_TIMER_DELAY, null); timer.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if (lightUpSequence.size() == 0) { timer.stop(); } // Turn button ON if (!isON &amp;&amp; lightUpSequence.size() &gt; 0) { int elementIndex = lightUpSequence.get(0); buttonArrayList.get(elementIndex).setBackground( Color.yellow); isON = true; // Turn button OFF if it's ON already. Then remove the // element. } else if (isON &amp;&amp; lightUpSequence.size() &gt; 0) { int elementIndex = lightUpSequence.get(0); buttonArrayList.get(elementIndex).setBackground(null); lightUpSequence.remove(0); isON = false; } } }); timer.start(); timer.setRepeats(true); } "
                }
              ]
            }
          ]
        },
        "units":[
          {
            "type":"StructuredFragmentUnit",
            "id":"[22773735]-[-136098133]",
            "astNode":{
              "type":"CodeFragmentSequence",
              "fragments":[
                {
                  "type":"TextFragmentNode",
                  "text":" "
                },
                {
                  "type":"MethodDeclaratorNode",
                  "modifiers":[
                    {
                      "type":"KeywordModifierNode",
                      "value":"private",
                      "comments":[
                        
                      ]
                    }
                  ],
                  "returnType":{
                    "type":"PrimitiveTypeNode",
                    "name":"void",
                    "comments":[
                      
                    ]
                  },
                  "identifier":{
                    "type":"IdentifierNode",
                    "name":"blinkSequence",
                    "comments":[
                      
                    ]
                  },
                  "parameters":{
                    "type":"FormalParametersNode",
                    "comments":[
                      
                    ]
                  },
                  "arrayReturnType":[
                    
                  ],
                  "body":{
                    "type":"BlockNode",
                    "statements":[
                      {
                        "type":"LocalVariableDeclarationStatementNode",
                        "modifiers":[
                          {
                            "type":"KeywordModifierNode",
                            "value":"final",
                            "comments":[
                              
                            ]
                          }
                        ],
                        "declarators":{
                          "type":"VariableDeclaratorsNode",
                          "declarators":[
                            {
                              "type":"VariableDeclaratorNode",
                              "identifier":{
                                "type":"IdentifierNode",
                                "name":"timer",
                                "comments":[
                                  
                                ]
                              },
                              "arrayDepth":[
                                
                              ],
                              "assignment":{
                                "type":"VariableAssignmentNode",
                                "variableAssignment":{
                                  "type":"VariableExpressionInitNode",
                                  "expression":{
                                    "type":"ConstructorCreatorNode",
                                    "creatorType":{
                                      "type":"ReferenceTypeNode",
                                      "ids":[
                                        {
                                          "type":"ParameterizedTypeNode",
                                          "identifier":{
                                            "type":"IdentifierNode",
                                            "name":"Timer",
                                            "comments":[
                                              
                                            ]
                                          },
                                          "comments":[
                                            
                                          ]
                                        }
                                      ],
                                      "comments":[
                                        
                                      ]
                                    },
                                    "expressionArgs":{
                                      "type":"ExpressionListNode",
                                      "arguments":[
                                        {
                                          "type":"QualifiedIdentifierNode",
                                          "identifiers":[
                                            {
                                              "type":"IdentifierNode",
                                              "name":"BLINKING_TIMER_DELAY",
                                              "comments":[
                                                
                                              ]
                                            }
                                          ],
                                          "comments":[
                                            
                                          ]
                                        },
                                        {
                                          "type":"LiteralNode",
                                          "node":{
                                            "type":"NullLiteralNode"
                                          },
                                          "comments":[
                                            
                                          ]
                                        }
                                      ],
                                      "comments":[
                                        
                                      ]
                                    },
                                    "comments":[
                                      
                                    ]
                                  }
                                },
                                "comments":[
                                  
                                ]
                              },
                              "varType":{
                                "type":"ReferenceTypeNode",
                                "ids":[
                                  {
                                    "type":"ParameterizedTypeNode",
                                    "identifier":{
                                      "type":"IdentifierNode",
                                      "name":"Timer",
                                      "comments":[
                                        
                                      ]
                                    },
                                    "comments":[
                                      
                                    ]
                                  }
                                ],
                                "comments":[
                                  
                                ]
                              }
                            }
                          ],
                          "comments":[
                            
                          ]
                        },
                        "labels":[
                          
                        ],
                        "comments":[
                          
                        ]
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"timer"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"."
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"addActionListener"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"("
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"new"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":" "
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"ActionListener"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"("
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":")"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":" "
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"{"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":" "
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"public"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":" "
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"void"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":" "
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"actionPerformed"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"("
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"ActionEvent"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":" "
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":"e"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":")"
                      },
                      {
                        "type":"TextFragmentNode",
                        "text":" "
                      },
                      {
                        "type":"BlockNode",
                        "statements":[
                          {
                            "type":"IfStatementNode",
                            "expression":{
                              "type":"BinaryExpressionNode",
                              "operator":{
                                "type":"OperatorNode",
                                "symbol":"==",
                                "comments":[
                                  
                                ]
                              },
                              "left":{
                                "type":"MethodInvocationNode",
                                "qualifiedIdentifier":{
                                  "type":"QualifiedIdentifierNode",
                                  "identifiers":[
                                    {
                                      "type":"IdentifierNode",
                                      "name":"lightUpSequence",
                                      "comments":[
                                        
                                      ]
                                    }
                                  ],
                                  "comments":[
                                    
                                  ]
                                },
                                "identifier":{
                                  "type":"IdentifierNode",
                                  "name":"size",
                                  "comments":[
                                    
                                  ]
                                },
                                "args":{
                                  "type":"ExpressionListNode",
                                  "arguments":[
                                    
                                  ],
                                  "comments":[
                                    
                                  ]
                                },
                                "comments":[
                                  
                                ]
                              },
                              "right":{
                                "type":"LiteralNode",
                                "node":{
                                  "type":"IntegerLiteralNode",
                                  "valueRep":"0"
                                },
                                "comments":[
                                  
                                ]
                              },
                              "comments":[
                                
                              ]
                            },
                            "statement":{
                              "type":"BlockNode",
                              "statements":[
                                {
                                  "type":"ExpressionStatement",
                                  "expression":{
                                    "type":"MethodInvocationNode",
                                    "qualifiedIdentifier":{
                                      "type":"QualifiedIdentifierNode",
                                      "identifiers":[
                                        {
                                          "type":"IdentifierNode",
                                          "name":"timer",
                                          "comments":[
                                            
                                          ]
                                        }
                                      ],
                                      "comments":[
                                        
                                      ]
                                    },
                                    "identifier":{
                                      "type":"IdentifierNode",
                                      "name":"stop",
                                      "comments":[
                                        
                                      ]
                                    },
                                    "args":{
                                      "type":"ExpressionListNode",
                                      "arguments":[
                                        
                                      ],
                                      "comments":[
                                        
                                      ]
                                    },
                                    "comments":[
                                      
                                    ]
                                  },
                                  "labels":[
                                    
                                  ]
                                }
                              ],
                              "labels":[
                                
                              ],
                              "comments":[
                                {
                                  "text":"// Turn button ON if (!isON && lightUpSequence.size() > 0) { int elementIndex = lightUpSequence.get(0); buttonArrayList.get(elementIndex).setBackground( Color.yellow); isON = true; // Turn button OFF if it's ON already. Then remove the // element. } else if (isON && lightUpSequence.size() > 0) { int elementIndex = lightUpSequence.get(0); buttonArrayList.get(elementIndex).setBackground(null); lightUpSequence.remove(0); isON = false; } } }); timer.start(); timer.setRepeats(true); } \n"
                                }
                              ]
                            },
                            "labels":[
                              
                            ],
                            "comments":[
                              
                            ]
                          }
                        ],
                        "labels":[
                          
                        ],
                        "comments":[
                          
                        ]
                      }
                    ],
                    "labels":[
                      
                    ],
                    "comments":[
                      
                    ]
                  },
                  "comments":[
                    
                  ]
                }
              ]
            },
            "rawText":" private void blinkSequence() { final Timer timer = new Timer(BLINKING_TIMER_DELAY, null); timer.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if (lightUpSequence.size() == 0) { timer.stop(); } // Turn button ON if (!isON && lightUpSequence.size() > 0) { int elementIndex = lightUpSequence.get(0); buttonArrayList.get(elementIndex).setBackground( Color.yellow); isON = true; // Turn button OFF if it's ON already. Then remove the // element. } else if (isON && lightUpSequence.size() > 0) { int elementIndex = lightUpSequence.get(0); buttonArrayList.get(elementIndex).setBackground(null); lightUpSequence.remove(0); isON = false; } } }); timer.start(); timer.setRepeats(true); } \n...\n}...\n}",
            "metaInformation":[
              {
                "type":"NaturalLanguageMetaInformation",
                "tfMap":{
                  "remov":2,
                  "delay":1,
                  "size":3,
                  "event":1,
                  "background":2,
                  "set":3,
                  "color":1,
                  "stop":1,
                  "element":5,
                  "array":2,
                  "button":4,
                  "listen":2,
                  "blink":2,
                  "sequenc":7,
                  "yellow":1,
                  "perform":1,
                  "true":2,
                  "turn":2,
                  "fals":1,
                  "repeat":1,
                  "start":1,
                  "light":6,
                  "add":1,
                  "action":4,
                  "timer":8,
                  "list":2,
                  "index":4
                }
              },
              {
                "type":"CodeTypesMetaInformation",
                "qualifiedTypes":[
                  
                ],
                "simpleTypes":[
                  {
                    "type":"ReferenceTypeNode",
                    "ids":[
                      {
                        "type":"ParameterizedTypeNode",
                        "identifier":{
                          "type":"IdentifierNode",
                          "name":"Timer",
                          "comments":[
                            
                          ]
                        },
                        "comments":[
                          
                        ]
                      }
                    ],
                    "comments":[
                      
                    ]
                  }
                ],
                "basicTypes":[
                  {
                    "type":"PrimitiveTypeNode",
                    "name":"void",
                    "comments":[
                      
                    ]
                  }
                ]
              },
              {
                "type":"CodeInvocationMetaInformation",
                "invocations":[
                  {
                    "type":"MethodInvocationNode",
                    "qualifiedIdentifier":{
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"lightUpSequence",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"size",
                      "comments":[
                        
                      ]
                    },
                    "args":{
                      "type":"ExpressionListNode",
                      "arguments":[
                        
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  },
                  {
                    "type":"MethodInvocationNode",
                    "qualifiedIdentifier":{
                      "type":"QualifiedIdentifierNode",
                      "identifiers":[
                        {
                          "type":"IdentifierNode",
                          "name":"timer",
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    },
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"stop",
                      "comments":[
                        
                      ]
                    },
                    "args":{
                      "type":"ExpressionListNode",
                      "arguments":[
                        
                      ],
                      "comments":[
                        
                      ]
                    },
                    "comments":[
                      
                    ]
                  }
                ]
              },
              {
                "type":"CodeVariablesMetaInformation",
                "variables":[
                  {
                    "type":"VariableDeclaratorNode",
                    "identifier":{
                      "type":"IdentifierNode",
                      "name":"timer",
                      "comments":[
                        
                      ]
                    },
                    "arrayDepth":[
                      
                    ],
                    "assignment":{
                      "type":"VariableAssignmentNode",
                      "variableAssignment":{
                        "type":"VariableExpressionInitNode",
                        "expression":{
                          "type":"ConstructorCreatorNode",
                          "creatorType":{
                            "type":"ReferenceTypeNode",
                            "ids":[
                              {
                                "type":"ParameterizedTypeNode",
                                "identifier":{
                                  "type":"IdentifierNode",
                                  "name":"Timer",
                                  "comments":[
                                    
                                  ]
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "expressionArgs":{
                            "type":"ExpressionListNode",
                            "arguments":[
                              {
                                "type":"QualifiedIdentifierNode",
                                "identifiers":[
                                  {
                                    "type":"IdentifierNode",
                                    "name":"BLINKING_TIMER_DELAY",
                                    "comments":[
                                      
                                    ]
                                  }
                                ],
                                "comments":[
                                  
                                ]
                              },
                              {
                                "type":"LiteralNode",
                                "node":{
                                  "type":"NullLiteralNode"
                                },
                                "comments":[
                                  
                                ]
                              }
                            ],
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      },
                      "comments":[
                        
                      ]
                    },
                    "varType":{
                      "type":"ReferenceTypeNode",
                      "ids":[
                        {
                          "type":"ParameterizedTypeNode",
                          "identifier":{
                            "type":"IdentifierNode",
                            "name":"Timer",
                            "comments":[
                              
                            ]
                          },
                          "comments":[
                            
                          ]
                        }
                      ],
                      "comments":[
                        
                      ]
                    }
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "answers":[
    {
      "type":"StackOverflowAnswer",
      "id":22773814,
      "questionId":22773735,
      "comments":[
        
      ],
      "creationDate":"2014-03-31",
      "lastActivityDate":"2014-03-31",
      "score":1,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":2803660,
        "displayName":"MrHaze",
        "reputation":664
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Well, there is nothing stopping you from making it return a boolean, but if you want to keep it the way it is you can use <code>assert</code> statements.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[22773814]-[-791257658]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Well, there is nothing stopping you from making it return a boolean, but if you want to keep it the way it is you can use <code>assert</code> statements.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "stop":1,
                    "statement":1,
                    "code":2,
                    "make":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>have a look at <a href=\"http://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html\"rel=\"nofollow\"><code>assert</code></a></p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[22773814]-[-425097402]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>have a look at <a href=\"http://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html\"rel=\"nofollow\"><code>assert</code></a></p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "languag":1,
                    "guid":1,
                    "rel":1,
                    "oracl":1,
                    "doc":2,
                    "technot":1,
                    "code":2,
                    "nofollow":1,
                    "javas":1,
                    "html":1,
                    "href":1,
                    "http":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type":"StackOverflowAnswer",
      "id":22773880,
      "questionId":22773735,
      "comments":[
        
      ],
      "creationDate":"2014-03-31",
      "lastActivityDate":"2014-03-31",
      "score":0,
      "isAccepted":false,
      "owner":{
        "type":"StackOverflowUser",
        "id":1358722,
        "displayName":"GingerHead",
        "reputation":4454
      },
      "source":[
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>For testing void method I use the following startegy:</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[22773880]-[-676605196]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>For testing void method I use the following startegy:</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "method":1,
                    "startegi":1,
                    "test":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>Granulize the variables of the method through globalizing them.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[22773880]-[915015618]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>Granulize the variables of the method through globalizing them.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "global":1,
                    "granul":1,
                    "method":1,
                    "variabl":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>So if you have an array, check the size before and after calling it.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[22773880]-[-2080672406]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>So if you have an array, check the size before and after calling it.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "call":1,
                    "size":1,
                    "check":1,
                    "array":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>If the size is the same, check the state of the objects in the array and compare them as before and after calling the method, like if they are lit or not.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[22773880]-[-1946738725]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>If the size is the same, check the state of the objects in the array and compare them as before and after calling the method, like if they are lit or not.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "method":1,
                    "size":1,
                    "state":1,
                    "lit":1,
                    "object":1,
                    "array":1,
                    "check":1,
                    "compar":1,
                    "call":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        },
        {
          "type":"SourceInfo",
          "node":{
            "type":"XmlTextNode",
            "contents":"<p>In this way you can effectively comply to the white box testing rules.</p>"
          },
          "units":[
            {
              "type":"TextUnit",
              "id":"[22773880]-[-2026789277]",
              "astNode":{
                "type":"TextFragmentNode",
                "text":"<p>In this way you can effectively comply to the white box testing rules.</p>"
              },
              "codeFragments":{
                "type":"CodeFragmentSequence",
                "fragments":[
                  
                ]
              },
              "metaInformation":[
                {
                  "type":"NaturalLanguageMetaInformation",
                  "tfMap":{
                    "test":1,
                    "effect":1,
                    "rule":1,
                    "box":1,
                    "compli":1,
                    "white":1
                  }
                },
                {
                  "type":"CodeTypesMetaInformation",
                  "qualifiedTypes":[
                    
                  ],
                  "simpleTypes":[
                    
                  ],
                  "basicTypes":[
                    
                  ]
                },
                {
                  "type":"CodeInvocationMetaInformation",
                  "invocations":[
                    
                  ]
                },
                {
                  "type":"CodeVariablesMetaInformation",
                  "variables":[
                    
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}